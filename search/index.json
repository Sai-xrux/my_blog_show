[{"content":"1. 理解 Hugo 目录结构 Hugo 站点的目录结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 my-blog/ ├── content # 存放所有内容文件 │ ├── _index.md # 博客首页内容 │ ├── posts # 博客文章 │ │ ├── first-post.md │ │ └── second-post.md │ └── pages # 博客页面 │ └── about.md # 关于页面 ├── data # 存放站点数据 │ ├── authors.yml # 作者信息 │ └── config.toml # 站点配置文件 ├── i18n # 国际化语言文件 │ ├── en.toml # 英文语言文件 │ └── zh.toml # 中文语言文件 ├── layouts # 存放页面模板 │ ├── _default # 默认模板 │ ├── partials # 模板片段 │ └── index.html # 首页模板 ├── assets # 存放编译前的资源文件 │ ├── css # 存放 CSS 源文件 │ ├── js # 存放 JavaScript 源文件 │ └── images # 存放图片源文件 ├── resources # 存放生成的资源文件 │ └── _gen # 生成的资源文件 ├── static # 存放静态资源（如图片、CSS、JS） │ ├── css # 存放编译后的 CSS 文件 │ ├── js # 存放编译后的 JavaScript 文件 │ └── images # 存放图片文件 ├── public # 生成的网站文件 ├── themes # 存放主题文件 │ └── my-theme # 自定义主题文件 │ ├── layouts # 存放页面模板 │ ├── static # 存放主题静态资源 │ └── theme.toml # 主题配置文件 ├── archetypes # 内容模板文件 │ ├── default.md # 默认内容模板 │ └── post.md # 博客文章模板 └── hugo_build.lock # Hugo 包管理文件 ","date":"2025-07-14T21:41:07+08:00","permalink":"https://example.com/p/my-first-post/","title":"My First Post"},{"content":"1.前言 程序员是世界上最理性、最睿智的群体，耶稣也反驳不了我，我说的！\n程序员不是吃青春饭的，而是吃技术饭的。\n态度 首先要做的，就是端正自己的态度，不要天天扯着脖子叫唤：我 35 就失业了，我还能干啥。大部分这样叫嚷的，都是有谋杀嫌疑的，你把悲观带给别人，导致别人也悲观，从而无所事事，跟谋杀没什么区别。\n假设现在有一个问题让你解决，如果你解决不了，那你纠结个毛啊；如果你能解决，那你又纠结个毛啊。所以，不用纠结，踏踏实实干事才是正途。\n在 IT 行业，永远是技术至上的，一门新的技术盛行，肯定有其原因，要么就是性能提升了不少，要么就是用起来更简单。而我们作为开发者，需要做的就是不断学习，不断了解新技术。\n如果你遇到新技术不主动学习，就在那感叹薪资提升慢，35 岁就被干掉，上班就摸摸鱼上几个小时大号。那么就对不起，程序员涨薪不是靠熬年龄，被干掉更不是因为年龄，而是因为不思进取。\n有人就不爽了，年龄就是工作经验啊，工作经验长才能拿高薪啊。\n错！8 年工作经验中有 7 年都在 ctrl+c、ctrl+v 的不是 8 年经验，是 1 年经验。建议大家招人的时候看下面试者的手形，左手大拇指和食指磨损严重的就是用的 Mac，左手小指和食指磨损严重的就是用的 Windows，总之：只要左手食指磨损严重的，就是平时CV惯了，就要重点关照了。\n总之，年龄大不是被干掉的原罪，也不是拿高薪的借口，技术才是王道，所以，你需要的态度就是：学好技术，技术就是一切。\n乐观的态度是前进的动力，态度比能力更重要。\n目标 好，现在，你已经准备学好技术了，那么，该学什么技术呢？\n这就要看你的目标了，程序员的职业道路只有两条：管理路线和技术路线。并不是说管理路线就不需要学技术，而是要求不那么高深了。但是做管理前，还是需要技术达标才能晋升，所以你还是要先学好技术，不然难以服众。\n假如你现在定了目标：我要成为一个前端专家。\n那么，你可以去招聘软件上看看，前端专家都有哪些要求，然后把这些要求列出来，逐条去努力，去实现。你也可以看看你们公司的高级前端，他每天都在做什么，他做的事你是否能做到，如果做不到，你要怎么才能做到。总之，你要想方设法去找到“实现你的目标的条件”，然后让自己逐个满足这些条件。\n你每天可以反思一下，今天做了什么，做的这些是否让自己距离目标近了些；当然，这不是一日可成的，这些都是需要坚持的。当你想放弃的时候，不妨就想象下自己已经达到目标的情景，指不定你的动力就又来了。\n没目标的人朝三暮四，有目标的人始终如一。\n坚持 当你有了目标之后，你要做的就是坚持不懈地向目标走，你可能坚持不下去了，想放弃；或者你看到别人在吃喝玩乐禁不住诱惑，没关系，你想想他 35 被辞退的情景，你就觉得挺爽的。\n我曾经读过一本书，叫做《Utliers》，中文名叫做《异类》，这本书告诉我一个道理：坚持不懈地做一件事，只要花上 10000 小时，你就能成为专家。这叫做 10000 小时法则。\n10000 小时，猛一听挺唬人的，按照每天 8 小时算，就是 1250 天，按每周工作 40 小时算，也就是 300 周，大概 6 年时间，6 年的时间就能成为专家？按照 23 岁毕业来算，也就是 30 岁就能成为专家，有几个人成了呢？这个法则不对吗？肯定是对的，比如：钢琴师朗朗，魔术师刘谦，他们都是世界级的人物了。那就说明：凡是 30 岁没成为专家的，都是没有坚持的，因为大部分程序员每天真正干活的可能也就三四个小时，剩余的时间没有去学习、写代码；而是在摸鱼。唉，我替你们老板求你们上会儿班吧。\n坚持是一件很可怕的事，会积少成多，会将微弱优势叠加，产生质变的效果。而且坚持会成为一种习惯，一旦养成了习惯，改都改不掉，一个好习惯将会使你受益终生。\n我有个同学坚持刷leetcode 7 年了，真不是人啊，当初我嘲笑他，现在他过着令我羡慕的生活。现在后悔也没用了，知来者之可追，所以现在，我也要坚持了，耶稣也挡不住我，我说的！\n理性 理性是程序员的本性，就像物体的密度一样，不会随着时间、空间的变化而改变。\n即使不理性的人，一旦当了程序员，也会变成理性，因为你要面对的是代码、是计算机。代码只跟你讲道理，胡搅蛮缠、煽情那一套对代码是没用的。\n理性就是做事有理有据，错的为什么错，对的为什么对，都是要做到心中有数的。比方说：今天我 review 代码，我发现这一块逻辑不太对，应该会出 Bug，但实际却正常运行，结果对了我就不去纠结了吗？这肯定是不行的，如果将来出错了呢？换句话说，我们去纠结一个代码的出发点应该是：实际结果跟我预想的不对。而不是：结果不对。\n或者说：决定我们是否做一件事应该是理论导向的，不应该是结果导向的。\n比如，我在同事的代码中看到很多直接在 UI 线程操作文件的，我就嘀咕：文件操作是 IO 密集型的耗时操作啊，应该在 IO 线程啊，为啥在 UI 线程呢？那个同事说：这个文件很小，几十毫秒就完事了，不会造成 UI 卡顿。\n他说的没错，但是不对！因为他这么做的原因是：文件不大，不会卡顿 UI，这就是根据结果做出的判断，也就是结果导向的。\n结果在后面我们发现，ANR 率上升了 0.04%，最后定位到是这个文件引起的，明明文件不大啊，这是咋回事呢？因为部分性能差的手机，ANR 率就高了，还有就是有的用户选择了一些大文件。那么这个问题怎么避免呢？\n我们这么理解：理论是根据大部分场景综合得出的结果，就像正态分布，独立概率一样，都是经过大量实验、场景得出的结论，所以适用于大部分场景；而你自己的结论，只是根据你自己的所见所闻得出的，而你自己的见闻远不如理论提出者。 所以，我们要尊重理论，根据理论来下决定，而理论说：文件是耗时操作，应该放在 IO 线程，那么我们放在 IO 线程就行了。这就是理论导向。\n我们要做理论导向，不要做结论导向。\n理性不是无情，程序员也是有感情的，也会开心，愤怒。我们要做的，就是不在愤怒时下决定，愤怒时是感性占上风的，此时做的决定大部分是从情绪出发的，很容易错，我们要避免之。\n清醒时做事，糊涂时读书，大怒时睡觉，独处时思考。\n基础 最后，要说的，就是基础！我们一定要重视基础。\n基础很重要！！！基础衍生出其他所有知识。学得越深，基础越重要。\n基础就是通用性技能。平时感觉不到它的存在，但是一旦遇到问题，你就知道它的重要性了。\n有的人在遇到问题不能解决时就开始怀疑人生，怀疑这个怀疑那个，甚至怀疑自己学过的东西都没学对，这其实就是基础不牢，这也不能确定那也不能确定，就导致不能排除无用的信息，进而无法及时解决问题。\n比如，我有个同事用ArrayList写了个用户列表，后面发现列表中有两个一样的人，不知道是服务器返回错了，还是客户端自己加错了，其实这就是他不知道ArrayList是否具有去重性，只能先写个 demo 确定一下，这就浪费了时间，其实我觉得像这种基础不牢的，应该先把ArrayList源码抄 100 遍再说。\n高手之间的较量，拼的就是基础，拼的就是对方犯错。你可以不会高级 API，但是不能基础不牢，因为高级的 API 都是基础 API 实现的，基础 API 也能实现，比如正则表达式，你可能记不住，但是只要你知道字符串的基础 API，你也能实现同样的效果。\n基础是重中之重，两手都要抓，且两手都要硬。\n结语 程序员为什么是最理性、最睿智的群体呢？\n因为我们整天跟电脑打交道，能跟电脑讲理的人，能不理性、不睿智吗？\n我们要做的就是：端正态度，定好目标，坚持不懈，理性做事，打牢基础。诚能如此，吾等前方，绝无敌手，三界之内，没人能挡住我们的脚步。\n那么，下一节，就从基础开始，一步步迈向胜利之路。\n2.二进制:计算机程序的\u0026quot;细胞\u0026quot; 一个数的大小，就是它各个位置的数字乘以对应进制的该数字所在位置（从低位到高位的位置）减 1 次方的和。\n引出问题：为什么是十进制？ 我们的日常生活中，大都采取十进制，比如 10 厘米等于 1 分米，10 两等于 1 斤，这是为什么呢？\n这是习惯决定的！\n因为我们有 10 个手指，在没有纸笔和计算器的年代，我们是采用数手指的方式来计数的，这样很方便，久而久之，就形成了习惯。所以，十进制不是一个科学性的定义，而是一个习惯性的定义。\n我们知道十进制有两个特点：\n只有 0 ～ 9 这十个数字，大于 9 的就要用两位数字来表示。 计算的时候满 10 就要进 1，高位上的数字是相邻低位的 10 倍。 废话？\n不，往下看！\n追根溯源：十进制的基本规则 我们假设 N=10，那么上面两个点换种说法就是：\nN 进制只有 0 到（N-1）这 N 个数字，大于（N-1）的就要用两位数字表示。 计算的时候满 N 就要进 1，高位上的数字是相邻低位的 N 倍。 好，没毛病。\n在十进制中，𝑎𝑏𝑐=𝑎×100+𝑏×10+𝑐×1。 也就是：𝑎𝑏𝑐=𝑎×\n$$ 10^{2} $$+𝑏×\n$$ 10^{1} $$+𝑐×$$ 10^{0} $$，那么既然 N=10， 那就是：𝑎𝑏𝑐=𝑎×\n$$ N^{2} $$+𝑏×\n$$ N^{1} $$+𝑐×$$ N^{0}\n$$ 。也没毛病。\n所以，我们可以得到结论：对于十进制来说，任意一个数字，它的大小就是各个位置的数字，乘以 10 的这个位置（从低位到高位的位置）减 1 次方的和。\n比如，上面的 abc：\n𝑎𝑏𝑐=𝑎× $$\n10^{2} $$+𝑏×$$ 10^{1} $$+𝑐×*$$ 10^{0}\n$$ *，\n从低位往高位看，c 在第 1 位，b 在第 2 位，a 在第 3 位，所以它们的位置依次是 1、2、3，那么这些位置减 1，就分别是 0、1、2，那么 10 的“位置减 1”次方就是： $$\n10^{0} $$、$$ 10^{1} $$、$$ 10^{2} $$，那么对应数字乘以 10 的位置减 1 次方的和就是：𝑎×$$ 10^{2} $$+𝑏×$$ 10^{1} $$+𝑐×*$$ 10^{0}\n$$ *。\n这正是上述的结论。\n那么，既然 N=10 都没毛病，那么上述结论就变成：对于 N 进制来说，任意一个数字，它的大小就是各个位置的数字，乘以 N 的这个位置（从低位到高位的位置）减 1 次方的和。\n这正是文章开头的结论。\n这到底对不对呢？答案已经有了。\n打开格局：进制的最基础原理 我们上面得出了一个结论：\n对于 N 进制来说，任意一个数字，它的大小就是：各个位置的数字，乘以 N 的这个位置（从低位到高位的位置）减 1 次方的和。\n这是针对十进制演变来的的，那么，如果不是十进制呢？如果是二进制呢？那么就是：\n对于二进制来说，任意一个数字，它的大小就是：各个位置的数字，乘以 2 的这个位置（从低位到高位的位置）减 1 次方的和。\n我们让 N=2，然后来验证下，还是 abc：\n𝑎𝑏𝑐=𝑎× $$\n2^{2} $$+𝑏×$$ 2^{1} $$+𝑐×*$$ 2^{0}\n$$ *\n又因为这是二进制，最大的数字就是 2-1，也就是 1，所以 abc 只能取 0 或 1。\n如果 abc 是 110，那么就是: 1×4+1×2+0×1，也就是 6，搜索一下这明显是对的。我们看到，这跟十进制的计算没什么区别，也就是说，这个结论可以用于任何进制。\n所以，我们上述结论是对的：\n对于 N 进制来说，任意一个数字，它的大小就是各个位置的数字，乘以 N 的这个位置（从低位到高位的位置）减 1 次方的和。\n这正是文章开头给出的结论。\n由此，我们可以得出一个结论：N 进制的特点。\n最大数字是 N-1，大于 N 就用两位数表示；高位的数字是低位的 N 倍。 也就是上述的结论。 好，现在你应该会表示并且计算二进制了，那么计算机为什么采用二进制呢？\n触类旁通：计算机为什么用二进制？ 因为简单！\n计算机的底层是基于晶体管实现的，可以简单地理解为一组开关，打开就表示 1，关闭就表示 0，所以，采用二进制的话，计算机只需要简单地打开/关闭这些开关即可。\n事物只有两种状态：有和无！用数字表示就是 0 和 1！\n假设我们的计算机有 1 个开关，打开表示天亮，关闭表示天黑；打开表示对，关闭表示错；打开表示 1，关闭表示 0，这种例子有很多。那么如果是十进制呢？用谁表示打开，用谁表示关闭呢？又怎么表示 1，怎么表示 9 呢？太麻烦了！\n我们来看二进制的最大优点：位运算。\n我们高中时候都学过真值表，学了与或运算，如下：\np q p 与 q p 或 q 0 0 0 0 1 0 0 1 0 1 0 1 1 1 1 1 我们知道：p 与 q 等于取交集，全部为 1 才为 1；p 或 q 等于取并集，全部为 0 才为 0。\nOK，现在我们是二进制，只有 0 和 1。那么根据上述法则:\n100∩011=000，100∪011=111。\n好，那么有个问题：给定一个数 n，怎么判断 n 是不是 2 的 n 次方呢？\n很简单啊，直接求余就行了。\n1 2 3 4 5 6 7 8 9 void is2Power(int n) { if (n \u0026lt;= 0) return false; int temp = n; while (temp \u0026gt; 1) { if (temp % 2 != 0) return false; temp /= 2; } return true; } 嗯，代码没毛病，不过不够好。看下面代码：\n1 2 3 public boolean isPowerOfTwo(int n) { return (n\u0026gt;0) \u0026amp;\u0026amp; ((n \u0026amp; (n - 1)) == 0); } 我们知道，10 的 n 次方最高位是 1，其他位都是 0；2 的 n 次方也是同理。也就是说：如果一个数 a 是 2 的 n 次方，那么 a 的最高位就是 1，其他位全是 0；那么，a-1 呢，就变成高位是 0，其他位全是 1 了。\n比如：a = 10000，a-1 就是 01111，根据真值表，我们知道:\n10000∩01111=0\n所以如果 a 是 2 的 n 次方，那么就有:\n𝑎∩(𝑎−1)=0\n根据这个特性，我们只需要进行简单的按位与运算，就能很快得到正确的结果。这就是位运算的强大之处。大家可以在 leetcode 上试一下，对比下运行速度便知。\n灵活运用二进制的位运算不仅能提高速度，熟练使用二进制还能节省内存。\n在很多人的认知中，最省内存的就是基本数据类型，也就是布尔值、短整型、byte 类型等。\n但是，这不是最省的。比如，我要存储一个人的年龄和性别，我们可以用两个字段：\n1 2 int age; boolean isMan; 这大概是所有人的写法了，也确实符合逻辑，但是，我们可以用更少的空间来记录的。我们知道，一个人的年龄最多也就是三位数，一个人的性别要么是男、要么是女，雌雄同体和人妖除外。\n那么，一位数就能表示性别，三位数就能表示年龄。也就是说，一个二进制就能表示性别：0 表示女，1 表示男。人的年龄很少超过 120 岁，而一个 byte 最大表示 127，我们用一个 byte 就能表示年龄，一个 byte 是 8 位二进制，那就是说，我们只需要 9 个二进制位就能表示人的年龄和性别。也就是两个 byte。而一个 int 是 4 个 byte 呢，这样我们就直接节省了一半以上的内存。\n那么二进制怎么表示一个 32 岁的男性呢？像这样：1_0010_0000，我们用首位的 1 表示性别，后面的 8 位表示年龄。这样只需要两个 byte 就足够。\n有人可能会说：这有点小题大做啊，至于吗？\n嗯，对于大部分场景，是意义不大的，但是对于一些很多人用的公共库、工程代码以及一些追求极致的设备上，这就很重要了。\n比如 Java 的字节码，我们知道，我们写的语言都是最后要跑在 CPU 里面的，而 CPU 只认识机器码，也就是二进制；所以我们写的代码要有个编译过程，Java 语言的这个过程的产物就是字节码文件，这个文件要尽可能紧凑，尽可能小，那么上述的小题就不大做了。\n我们可能会看到一些源码里面有很多 flag 变量，对这些 flag 进行按位与或按位或运算来检测标记，从而判断是否开启了某个功能。他为什么不直接用布尔值呢？很简单，这样效率高还节省内存。比如Android源码中的测量过程，就用到MeasureSpec这个类，它是一个int类型，用高两位表示测量模式，用低 30 位表示测量值，这样只用一个变量就保存了多个信息，有兴趣的同学可以去看下相关源码。\n归纳总结：本节要点 本节的知识点很简单，可以简单概括为两点：\nN 进制的数字范围为：[0, N-1]，大于 N-1 的就要用两位数字来表示。 对于 N 进制来说，任意一个数字，它的大小就是各个位置的数字，乘以 N 的这个位置（从低位到高位的位置）减 1 次方的和。 所以，我们不必纠结于几进制了，只要理解或者牢记上述两个结论，即使是 100 进制，也能直接把它按在地上摩擦。\n本节的每个小标题都有个前缀，这就是本小册的核心思想：自顶向下再向上的思维。因为底层原理共通，所以我们先站在 A 的角度理透 A 的逻辑，然后去研究 A 的底层，然后再利用 A 的底层去扩展到 B 的底层，最后，利用 B 的底层，就可以推出 B 的逻辑。这是快速扩张知识面的手段之一，也是解决非认知领域知识的方法之一，希望大家能够理解并运用。\n下一节我们就详细讲解二进制中的位运算的法则和实现原理，我们下一节见。\n3.位运算:程序高速运行的基石 我们知道，在十进制中，数字前面用减号来表示负数，而计算机只有 0 和 1，没有其他任何符号，它怎么表示负数呢？\n这就涉及到编码的问题了。\n计算机中的编码 计算机内部用补码表示数字，高位为符号位，0开头表示正数，1开头表示负数。\n二进制中的原码、反码和补码描述如下。\n原码：就是数字本身。比如 1110 的原码就是 1110。 反码：将原码除符号位按位取反就是反码。比如 1110 的反码是 1001。 补码：将反码加 1 就是补码。比如 1110 的反码是 1001，补码就是 1010。 正数的原码、反码、补码都相同，都等于原码；负数的反码等于除符号位按位取反，负数的补码等于反码末位加1。\n比如0110，是以0开头的，就是正数，它的原码、反码、补码都是0110；再比如上述的1110，它是以1开头的，就是负数，所以就用上述方式计算它的反码和补码。\n这听着真费劲，那为什么要有补码呢？\n为了简化减法运算！使用补码可以将减法变成加法。这怎么理解呢？\n十进制的补码等于用 9 减去各个位置的数字后末位再加 1，比如 1 的补码是 9，2 的补码是 8……以此类推。\n先来看个问题：比如：9-4，4 的补码是 6，我们就变成 9+6，结果是 15，我们再去掉最高位的 1，结果是 5，所以 9-4=5。换句话说就是：数 A 减去数 B 等于数 A 加上数 B 的补码，然后砍掉最高位。\n再比如：81-21=81+(78+1)=81+79=160，去掉最高位的 1，就是 60，结果也是成立的。\n有人说，这不对啊，你这计算补码的时候，要用 9 减去各个位子的数字，这本身就做了一次减法啊。是！但是这是 10 进制，二进制就不需要了，二进制只需要按位取反，末位再加 1，就行了。\n比如：二进制的减法：0110−0001，-0001的原码是1001，那反码就是 1110，补码就是 1111。换成补码计算就是 0110+1111，结果是：10101，去掉最高位就是 0101，也就是 5，答案明显是对的。\n唉，等等等等，那就是说：0110-0001=0110+1111，而我们又知道：0110-0001=0110+(-0001)，那是不是意味着 -0001 就等于 1111 呢。\n聪明！\n如果用补码表示二进制，那么高位就表示符号位置：如果高位是 1，就表示负数；如果高位是 0，就表示正数。\n所以 1111 就表示负数，它对应的原码等于对它再次求补码，1111 的反码是 1000，补码就是 1001，高位是 1，表示负数，所以就是 -0001，所以就有：1111=(-0001)。这就是二进制的神奇之处。\n所以，为什么要用补码呢？\n因为可以避免负数和减法，利用高位溢出，将减法变成加法。这样，计算机就不用设计减法器了，直接用加法器就可以做减法了。\n计算机只有加法器，没有减法器。\n那么，只有负数使用补码表示吗？\n不是，在计算机中，所有数字都使用补码表示，只不过正数的补码等于原码，负数的补码等于对应的正数按位取反后末位加1，所以，我们一般的计算中，只需要注意负数就行了。\n计算机用补码表示所有数字。正数的反码和补码都等于原码，负数的反码等于除符号位外其他位按位取反，负数的补码等于反码加 1。\n二进制 反码 补码 正数 等于原码 等于原码 负数 除符号位按位取反 反码加 1 现在我们知道了二进制的加法和减法，那么二进制的乘除怎么计算呢？\n那就是位运算了。\n位运算 按位与（\u0026amp;） 按位与运算就是：将各个数位的数字进行逻辑与，都是 1 才为 1，否则为 0。\n比如：110\u0026amp;011=010。因为只有第二位都是 1，那么其他位都为 0，所以就是 010。\n再比如：1111\u0026amp;111=0111，由于 111 是三位数，所以高位补个 0，那么结果就是 0111。\n你说这些我都知道了，所以这有什么用？\n使用与运算可以消除指定位置的数字。也可以判断是否具有某个标记。\n比如：我要取一个 8 位数的高 4 位，那么我就让它和 1111 0000 进行按位与运算，这样，它的低 4 位一定都是 0，高 4 位原来是 1 还是 1，原来是 0 还是 0，这样也就等于：消除了它的低 4 位，只取它的高 4 位。\n好，这我也知道了，所以这又有啥用呢？要不上个代码我看看？\n好，上代码，现在来模拟某奇艺的会员制度：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int vip = 0000 0001 // 表示vip 能看收费剧了 int svip = 0000 0011 // 表示svip 能看提前播放的剧了 int vipp = 0000 0111 // 表示vip中p // 能跳过vip广告了 int svipp = 0000 1111 // 表示svip中p // 能跳过svip广告了 int tvip = 0001 1111 // 表示电视vip，能投屏了。 // 是否是vip boolean isVip(int flag) { return vip\u0026amp;flag == vip; } // 是否是svip boolean isSvip(int flag) { return svip\u0026amp;flag == svip; } // 是否是tvip boolean isTvip(int flag) { return tvip\u0026amp;flag == tvip; } ... 现在假设你的 vip 标记和我的 vip 标记如下：\n1 2 3 int uFlag = 0000 0011 // 你的vip标记 int mFlag = 1111 1111 // 我的vip标记 好，现在拿着你的 vip 标记uFlag去试试，是不是 vip 呢？计算了下是，而且也是 svip。但是也仅仅是 svip 了。拿着我的去呢？直接挑最大的 tvip 试试，发现是的，那么也是其他的 vip 了。\n这里你可以看到，一个 int 型的 flag 值，就可以表示这么多 vip 了，这不比你用一个个的布尔值表示来得香？\n代码 x 格直接上升了一个 level，可以去跟比人装 x 了。\n按位或（|） 按位或运算就是：将各个数位的数字进行逻辑或，都是 0 才为 0，否则为 1。\n理解了上述的按位与运算，这个就很好理解了。\n比如还是上述的两个数：110∣011=111，1111∣111=1111，011∣001=011。\n这里就不再解释了。那么它有啥子用呢？\n使用或运算可以给指定位置添加标记。 说白了就是，可以给指定位置设置为 1。\n比如：0011 1001 这个数字，我要将它的低 4 位全部设置成 1，而高 4 位不变。那么就让它跟 0000 1111 进行或运算：00111001∥00001111=00111111，因为跟 0 进行或运算，结果是本身，跟 1 进行或运算，结果是 1，所以答案就不解释了。\n嗯，你又知道了，这又有啥子用呢？\n上代码。还是上述的 vip，比如你现在充了 10086 块钱，开了个视频 vip，那么我怎么给你开通呢？很简单：\n1 2 3 4 5 6 7 ... int tvip = 0001 1111 // 表示电视vip，能投屏了。 // 开通tvip int openTvip(int flag){ return tvip|flag; } 假设你啥都不是，只要进行了openTvip()操作，就直接是 tvip 了，这就是或运算的添加标记功能。\n现在，你已经能用与运算和或运算来实现：添加、删除、判断，这些操作了。后面如果有类似的需求，请大胆地使用它们。\n异或（^） 异或运算就是：将各个位置数字进行异或，相同为 0，不同为 1。\n比如：1111 ^ 1111 = 0000，0000 ^ 1111 = 1111。\n说白了就是：将相同的除去。\n一个数和 0 异或等于它本身。\n如果你原来是 1，那么就和 0 不同，不同的两个数异或等于 1，就是你本身；如果是 0，就和 0 相同，相同的两个数异或等于 0，还是你本身，所以：一个数和 0 异或等于它本身。\n一个数和自身异或等于 0。\n这个就不解释了，因为相同，异或肯定是 0。\n那这有啥用呢？除去相同的。\n我们先来看一个骚操作：交换两个变量的值。\n一般的写法：\n1 2 3 int temp = a; a = b; b = temp; 二般的写法：\n1 2 3 a = a + b; b = a - b; a = a - b; 三般的写法：\n1 2 3 a = a ^ b; b = a ^ b; a = a ^ b; 二般的写法就不说了，虽然是对的，但是有溢出的风险。而且也容易看懂。\n三般的这里解释下：\na = a ^ b; 此时 a 就是 a^b; b = a ^ b; 也就是 b = (a^b) ^b = a^b ^b = a^(b ^b) ；而相同的数字异或等于 0，那就是 a^0，也就是 a，此时 b=a 了。 a = a ^ b; 此时经过第一步运算 a=a^b，经过第二步运算 b=a，所以 a = (a^b) ^a = a ^a ^b = 0^b，也就是 b。 好，这里就不废话了。\n我们再来看实际的应用，比如：我们开发了个打卡机，每天要进行签到签退，每次签到签退都会记录员工号，那么既然如此，一个人的工号肯定出现偶数次，如果是奇数次，就肯定有缺卡记录，那么怎么找出来呢？\n很简单，异或啊！\n我们直接遍历所有的员工号，挨个进行异或，那么最后得出的那个数字，就是缺卡的那个员工。因为其他的都经过两次异或变为 0 了。\n代码如下：\n1 2 3 4 5 6 7 int findNumber(int[] nums) { int result = nums[0]; for (int i = 1; i \u0026lt; nums.Length; i++){ result ^= nums[i]; } return result; } 这里就不废话了，直接看代码即可。\n非（!） 按位非就是：将所有位置的数字取反，原来是 0 就变为 1，原来是 1 就变为 0。\n那么它有啥用途呢？\n首先我们能想到的就是：求反码。\n再比如：开关操作。\n考察如下代码：\n1 2 3 4 5 if(a = false) { a = true; } else { a = false; } 这看着可真别扭啊，直接改成：\n1 a = !a； 简单明了。\n左移（\u0026laquo;） 左移运算就是：将所有数字向左边移动 n 位，右边补 0。\n比如我们先看 10 进制的左移，100，向左边移动 2 位，100__ ，然后右边补 0：10000，等于变为原来的 100 倍了。\n同样的二进制也是这样，比如 0011，左移 3 位就变成 11000，原来是 3，现在是 24，变为原来的 8 倍了，所以可以得出结论，**在 2 进制中，左移动 n 位，就等于乘以 $$\n2^{n}\n$$ 倍**。\n这个结论可以用于乘法运算，比如，要计算：𝑎×15，考虑到 15=16-1，16 是 $$\n2^{4}\n$$ ，所以就可以计算为：𝑎\u0026laquo;4−𝑎，这样就不用计算乘法了（计算机计算乘法的效率比较低）。\n左移运算还有个用途，就是可以丢掉高位，比如一个 8 位数：1000 1111，左移 4 位就变成：1111 0000，原来的高 4 位，被移出去了，只剩下低 4 位了。\n左移运算在不溢出的情况下等于乘法，在溢出的情况下等于裁掉高位。\n右移（\u0026raquo;） 右移运算就是：将所有数字向右边移动 n 位，左边补符号位，正数就补 0，负数就补 1。\n这个也很好理解，比如：0111\u0026raquo;1=0011，因为是正数，所以左边补 0。\n切记，对于负数的右移要转为补码来计算。\n比如：要计算-5右移1位，\n先计算-5的补码，也就是1011 执行位运算: 1011\u0026raquo;1=1101，因为1011是负数，所以高位补1 再把1101求一次补码，得到原码: 1011，因为1101是负数，所以就是-3。 这就有问题了，-5右移1位不应该也是除以2吗，那就应该是-2啊，怎么是-3呢？ 没错，它就是不等于，原因就在于高位补符号位置了，这个不用纠结了，即使强迫症晚上睡不着觉也没法。\n那么，负数的右移不等于除法，我要怎么快速计算呢？很简单，先使用正数做右移，完了再转成负数就行了。\n比如，还是-5，我们想除以2，我们可以先计算5的右移:\n0101\u0026raquo;1=0010，也就是2，也就是0010，我们把最高位符号位改为1，就是1010，也就是-2的原码，这样我们就计算出了-5除以2的结果。\n其实你不用纠结，这个原理我们只要知道就行，至于这些计算的事情，让计算机去干！\n正数的右移运算等于做除法，负数的右移不等于做除法。\n比如，上述的 0111\u0026raquo;1，因为最低位的 1 被移出去了，就变成变为 011，又因为符号位为 0，所以高位补 0，就变成了 0011，也就是 3，而原来的 0111 是 7，对于整型来说：7/2=3，等于除以 2。\n所以，**在 2 进制中，正数右移 n 位，就等于除以 $$\n2^{n}\n$$ 倍**。\n右移运算在任何情况下都等于裁掉低位。\n上述与运算我们说到，按位与可以消除指定位，如果配上右移，那就更合适了。比如我们用 1111 0100，这个数字的高 4 位表示年龄，低 4 位表示成绩，现在要知道这个人的年龄和成绩分别是多少。\n用与运算获取成绩：11110100\u0026amp;00001111 = 0000 0100，得到成绩。 用右移运算获取年龄：11110100\u0026raquo;4=11111111，然后再用按位与运算去掉高 4 位的符号位，就得到 00001111，也就是年龄。 有人说，计算年龄有点费劲，我们有更简单的计算方法：无符号右移。\n无符号右移（\u0026raquo;\u0026gt;） 无符号右移跟右移一样，只不过左边永远补 0。\n还是上面获取年龄的例子，1111 0100，无符号右移 4 位，高位补 0，就成了 0000 1111，直接就获取到了年龄。\n移位运算分为逻辑移位和算数移位，如果你用二进制表示数值，那么高位就是符号位，此时为算术移位，右移则高位补符号位。如果你用二进制表示逻辑，比如上述的flag，那此时就是逻辑移位，右移则高位永远补0.\n总结 本节我们讲了逻辑位运算和算术位运算，其实逻辑位运算就是一张真值表。\np q p 与 q p 或 q !p p异或q 0 0 0 0 1 0 1 0 0 1 0 1 0 1 0 1 1 1 1 1 1 1 0 0 至于怎么使用，就像海贼王的果实开发一样，全靠个人想象。\n左移：低位补 0，等于乘法。 右移：高位补符号位，正数等于除法，负数可以先按正数计算，然后转成负数。 无符号右移：高位补 0。 最后，一定要多使用逻辑位运算的添加、删除、判断 flag 位的功能，以及使用移位运算的乘除功能。\n4.代码的基元:初识数据类型 前面说了，计算机是使用二进制保存所有数据的，那我们写代码的时候不可能全部用 0101 这样的方式去写，这样多费劲啊。所以，我们就在二进制的基础上，衍生出其他人能看懂的数据类型，然后用人能看懂的语言来操作这些数据类型，这种语言就叫做高级语言。相应的，那些由 0101 组成的语言就叫做机器语言。\n那么，由二进制衍生出的数据类型有哪些呢？\n我们可以将这些数据类型分为两大类，值类型和引用类型。\n值类型 首先要说的，就是值类型，我们按照表示的范围可以划分为如下几种类型。\n比特类型（byte）：8 位二进制。 短整型（short int）：16 位二进制。 整型（int）：32 位二进制。 长整型（long）：64 位二进制。 布尔类型（boolean）：默认是使用 int 表示的，也就是 32 位二进制。 字符类型（char）：16 位二进制。 单精度浮点（float）：32 位二进制。 双精度浮点（double）64 位二进制。 其中，我们将 8 位二进制称作一个字节，也就是 1byte，也就是: 1byte = 8bit，也就是 8 个二进制位；因为最高位要用来表示符号位，所以，1 个 byte 的大小范围就是 [− $$\n2^{7} $$ ~ $$ 2^{7}\n$$ −1]。\n在 Java 语言中，boolean 比较特殊，当它单独使用时，就是一个 int 的大小，也就是 4 个字节；当它用作数组元素使用，就只占用 1 个字节，这也是为什么很多服务器在定义数据时，将 boolean 定义为 1 和 0 的原因。\n我们将上述描述整理下，如表格所示：\n这属于理解性知识，我们不用死记硬背，会查表即可。\n不过有同学可能会有疑问了，一个 byte 明明是 8 位，最大应该是：1111 1111，应该是 $$\n2^{8} $$−1，就像 10 进制中，8 位数最大就是 9999 9999 一样啊，也就是 $$ 10^{8}\n$$ −1。\n不是这样的，因为你那个 9999 9999，并不是 8 位数，而是 9 位数，你还有个符号位呢，也就是 +9999 9999，而我们上一节说到，二进制中所有数据都用 0 和 1 表示，所以 8 位二进制最高位是符号位，也就是实际只有 7 位表示数据，所以最大就是 $$\n2^{7}\n$$ −1。\n那这也不对啊，最大是 $$\n2^{7} $$−1，最小不应该是 −$$ 2^{7} $$−1 吗，怎么会是 −$$ 2^{7}\n$$ 呢？这样不就等于负数比正数多一个吗？\n不，我们仔细想一下，负数范围为：− $$\n2^{7} $$ ~ -1，也就是共有 $$ 2^{7} $$个负数；正数范围为：1 ~ $$ 2^{7} $$−1，共有 $$ 2^{7} $$−1 个，确实少一个。唉，0 呢？0 的符号位是 0，也算是正数，所以正数应该是：0 ~ $$ 2^{7} $$−1 ，也是 $$ 2^{7}\n$$ 个，跟负数总数是一样的。\n上述表格中的浮点数，采用的是规格化计数法，比如单精度浮点型 float 的范围： 1.4E-45 ~ 3.4E+38，其中 E 表示以 10 为底的指数，E 后面为 + 就表示正指数，- 就表示负指数；这个范围就是：最小是 1.4 乘以 10 的 -45 次方，最大是 3.4 乘以 10 的 38 次方。\n对于浮点数，还有个精度失真问题，比如：\n1 2 3 float a = 0.11f; float b = 0.22f; println((a+b)==0.33);// 输出false 结果是 0.11+0.22 并不等于 0.33；这么奇葩吗？这是因为计算机是使用二进制存放数据的。根本无法获取精确的小数，比如：0.1 用二进制怎么表示呢？$\\frac{1}{2}$ 是 0.5，大了；$\\frac{1}{4}$ 是 0.25，大了；$\\frac{1}{8}$ 是 0.125，大了；$\\frac{1}{16}$ 是 0.0625，小了，需要再加点更小的；以此类推，就像十进制永远表述不出来 $\\frac{1}{3}$ 一样，只能无限接近，就是不能精确等于。\n所以，我们做数据敏感的项目时，要使用其他的 api，比如 BigDecimal。\n引用类型 引用类型有三大类：字符串（string）、数组（array）和对象。准确地说，字符串和数组也是对象，只不过比较特殊，这里单独拎出来照顾照顾。\n引用和值最大的不同在于：值类型是实实在在的一个数值，而引用类型则指向内存中的一个地址，修改一个引用类型可能带来其他风险，所以我们要慎之又慎，为了彻底解决这个问题，很多高级语言中直接就在函数调用的时候，按值传递，也就是把引用类型变量拷贝一份作为参数传递，而不是直接传递原有的引用。\n1 2 3 4 5 6 7 // 值类型demo int a = 10; function(a); void function(int num) { num = 11; } println(a); // a还是10，没变化 1 2 3 4 5 6 7 // 引用类型demo int[] nums = {1,2,3,4,5}; function(nums); void function(int[] nums) { nums[0] = 100; } println(nums[0]); // nums[0]不是1了，而是100了。 上述例子简单明了地讲解了值类型和引用类型的区别，所以我们要尽量小心地使用引用类型，其实只要你尽量少地修改参数即可避免这类问题。\n这里还有个 tips：能声明为局部变量的就不要声明为成员变量，能声明为成员变量的尽量不要声明为全局变量。因为变量的范围越大，越有可能被修改，风险就越高，所以我们要坚持 小范围优先原则。\n字符串 字符串是引用类型，但是编译器对其做了特殊处理，使其使用起来就像值类型，那么这是为什么呢？\n很简单，就是为了不可变。\n字符串是代码中使用最多的类型，如果所有的数据类型只能保留一个，那么这个类型肯定是字符串，看看 json 就知道了。\n我们一定要像保护我方水晶一样保护我方字符串。\n所以，字符串这么重要，肯定要保证它是安全的，如果它是引用类型，那么就很容易被修改，所以编译器就把它特殊处理了下，使其使用起来就像一个值类型一样。你看 java 的 String 就是 final 的，不但不让你改，也不让你继承。\n有人说这不对啊，String 是为了不可变，那么字符串执行自加运算是怎么执行的呢？ 比如：\n1 2 String a = \u0026#34;abc\u0026#34;; a+=\u0026#34;def\u0026#34;; // 结果a就是abcdef了。 这不就变了吗，是变了，但不是字符串对象变了，是 a 指向了另一个地址。 说白了就是：\n1 2 String a = \u0026#34;abc\u0026#34;; // a执行内存地址001，001放的是\u0026#34;abc\u0026#34;; a+=\u0026#34;def\u0026#34;; // a指向内存地址002，002放的是\u0026#34;abcdef\u0026#34;; 001放的还是\u0026#34;abc\u0026#34;; 也就是说，a 指向了 \u0026ldquo;abcdef\u0026rdquo; 的内存地址而已，而原来存放 \u0026ldquo;abc\u0026rdquo; 的那个地址的值还是 \u0026ldquo;abc\u0026rdquo;，并没有变化。\n也就是说： 字符串每次相加都会创建新字符串对象。\n而我们知道，创建对象本来就是个高代价操作，所以要尽量避免频繁执行字符串的相加操作，比如：\n1 2 3 4 String name = \u0026#34;\u0026#34;; for(int i = 0; i \u0026lt; names.length; i++){ name+=names[i]; } 写这种代码的人，先拉出去批斗一顿再说。\n那么，怎么办呢？也不能不加啊，可以用字符串提供的 API，比如 Java 中的 StringBuilder、StringBuffer （名字起得真好，简写就是国粹）。\n数组 数组是比较特殊的引用类型，数组指向的是第一个元素在内存中的地址，而且数组是占用一块连续的内存空间，这样一来，我们只要知道第一个元素的位置，就可以根据数组存储的变量类型的大小，计算出数组中每个元素在内存中的地址了。很多高级语言就是利用这个特点，衍生出了顺序存储的可变长度的线性集合。\n数组这么设计有个特点：快！非常快！\n比如： int[] nums = {1,2,3,4,5};，nums 就指向元素 1 在内存中的地址，假如 1 的地址是 0x0001，那么因为一个 int 占用 4 个 byte，元素 2 的地址就是 0x0005，元素 3 的地址就是 0x0009，依次类推。\n这样就导致我们只需要知道数组的地址，也就是第一个元素的地址，就能快速定位到第 n 个元素的地址，这也是数组可以根据下标访问元素的原因。\n那要这么说的话，我全部用数组不就行了吗？\n那可不行！因为数组这个特点必须要连续的内存空间，如果现在我的内存没有那么大一块连续的可咋整呢？那就不申请了吗？就像你要 100 亩连续的地皮，但是我在朝阳区有 30 亩，海淀区有 30 亩，昌平区有 40 亩；我怎么给你整呢？\n这就导致一个问题，数组对内存的要求太苛刻了，一旦存满了想扩容，就有可能扩容失败，所以它的缺点就是：内存要求高，扩展性差。\n所以，当你对随机访问要求不高的时候，尽量不选择数组，可以选择我们后面要讲的链表。\n对象 普天之下，莫非类；率土之滨，莫非对象。\n世间万物皆是对象，自从我干了程序员之后，我发现我做任何事都要分好几步。\n比如吃年夜饭的时候，我就说：第一步拿碗筷；第二步：盛饭；第三步：端桌子上；第四步：吃饭；第五步：收拾碗筷；第六步：端走；第七步：洗碗；第八步：收碗筷。并且一定要确保步骤是偶数的，因为这样才左右对称，才有完整的生命周期。\n在这 8 个步骤之中，碗筷和饭都是对象，其中碗筷属于长生命周期的对象，随着我家的存在而存在，随着我家的消失而消失；而饭则属于短生命周期的对象，随着出锅而出生，随着被吃下去而消失。\n所以，任何对象都有它的生命周期；局部变量的生命周期，随着函数的调用出生，随着函数调用结束死亡。比如：\n1 2 3 4 5 6 7 8 9 fun userName() { let user = new User(); // 对象出生 println(user.name); return user.name; // 对象死亡 } fun test(){ let name = userName(); } 这个很好理解，因为调用一个函数的时候，会将函数的数据读入内存，而调用完了，也就会把读入的数据清空。\n所以，我们给每个变量都定义了叫做作用域的东西，上述例子说白了就是：局部变量的作用域仅限于它所在的函数。一旦函数调用完毕，作用域结束，生命周期也走完了，就等于死亡了。\n还有一种可能，即使函数没走完，对象也可能死掉，比如：\n1 2 3 4 void test() { Object obj = new User(); // 创建了一个User对象，并用obj这个引用指向它 obj = new String(); // 创建了一个String对象，并用obj这个引用指向它，此时User对象已经没有引用指向了。 } 在上述代码中，当执行完obj = new String();之后，User 对象已经没有引用指向了，如果此时进行垃圾回收，那么就可以被回收掉，也就是死亡了。那么，这又是为啥呢？\n其实我们全部可以概括为一点：一个对象是否可以被回收，取决于执行垃圾回收时它有没有被引用。\n第一个例子中因为函数调用完了，引用也不存在了，所以 User 没有被引用；第二个例子中虽然函数没执行完，但是引用指向了另一个对象，所以也导致 User 没有被引用。所以它们都会被回收，也就是被干掉。\n有人说，我还记得有个置为 null 的，这跟上述的有什么区别？\n没区别！因为 null 也是个对象，只不过是个名字叫做 null 的里面啥都没有的对象而已。你可以这么理解：\n1 2 3 Object null = new Object(); // 创建一个空对象 User user = new User(); // 创建一个User对象，并用user这个引用指向它 user = null; // 将user指向null，原来的User对象没人指向了，就可以回收了。 这样是不是就很好理解了？\n总结 本章我们重点讲了值类型和引用类型，值类型存放的是具体数值，而引用类型存放的是数据的地址；并且，我们讲解了字符串、数组和对象这三大引用类型的特点。\n字符串：是引用类型，用起来却是值类型；为了安全设置为不可变的。 数组：数组指向的地址就是第一个元素的地址，可以快速地访问其他元素。 对象：对象的生命周期跟着作用域走，如果没有引用指向它，它就可能提前死亡。 另外，我们一定要注意浮点数的精度问题，下一节，我们就来看一下这些数据类型该如何选择。\n5.代码优化:挑选合适的数据类型 上一章我们讲了值类型和引用类型两大类型的数据，本章我们就来讲它们的使用。\n众所周知，算法的执行效率就两个考量因素：空间和时间。而代码是算法的结合体，需要考量的也是这两个因素。看具体需求选择合适的数据类型就成了必备技能。\n空间筛选 首先，我们在了解了数据类型大小以及范围的时候，优先考虑空间筛选，因为空间筛选决定的是对错问题，这是最重要的，比如，为了省内存，选了个小的，结果线上出了 bug，这就不是优化时间性能可以改变的了。\n优先选择小的 在满足需求的情况下，优先选择更小的数据类型。\n比如，我们知道 boolean 单独使用时其实是用 int 表示的，那么我们就用更小的 byte 来表示，0 表示女，1 表示男，也很形象。\n而当我们使用 boolean 数组时候，再用 boolean 来表示。\n但是，有时候我们也不能光顾着省内存，而忽略了程序本身的正确性。\n比如，我现在要创建一个所有用户的历史消息表，那么它的 id 用什么来表示呢？\n我想想啊，一个 int 就足够了，因为不可能有十亿多条数据，这是不对的，因为你这是历史数据，历史的积累是很可怕的，比如微信 APP，动不动几个 G 的数据，而且卸载了之后，历史聊天记录也没了，为啥呢？因为历史数据太多了，历史的积累太可怕了。\n所以，你应该选择 long 类型的 id，并且做好数据扩充。\n优先选择容易改变的 在满足条件的情况下，优先选择容易改变的数据类型。\n上一章我们讲到，利用数组可以快速访问每一个元素，但是数组有个缺点就是扩容很费劲，需要连续的内存空间，如果扩容失败，就会造成很严重的影响。\n那么，作为一个大工程项目，我们在选择容器类数据类型时，就要优先选择容易改变的，比如后面要讲到的链表。\n因为我们的需求不是一成不变的，如果你们产品发了毒誓、立了字据说不会改，那你也不能信！产品的嘴，骗人的鬼。\n一定要选易变的，一定要选易变的。\n如果是你们自己内定的需求，比如你给服务器传递参数，或者 SDK 层给 API 层传递数据，那你就可以用数组这类不可变长的数据结构。\n总之，对于空间这方面的要求就两个：大小和易变性，优先选小的，优先选易变的。\n接下来我们看时间筛选。\n时间筛选 选择合适的数据结构能提高程序运行的性能，这是大部分程序员拉开水平的另一个纬度，也是最容易被忽略的维度。\n很多程序员觉得：写对就成，能跑就行。你放心，你 35 岁绝对能跑。\n优先选数字类型的 首先，我们在选择类型时候，要优先选择数字类型的，比如int、long等，而不是String或对象类型的，为啥呢？\n因为数字类型的效率更高，不管是做算术运算、逻辑运算、还是比较运算，数字类型的效率都比引用类型的高，这就等价于提高了程序运行的速度，进而提高了性能。\n我们可以看一下 Long 类型和 String 类型的equals()方法，就会发现，Long 类型简单得多，直接比较数值大小就行；而 String 类型呢，先比较长度，再逐个比较每个字符。这一对比，效率就出来了啊。\n凡是带有去重功能的集合，比如 Set、Map 等，都是使用 equals 比较两个元素是否相同，相同就删除一个，这样的操作的，就导致 equals 函数被频繁调用；如果集合过大，那么 Long 类型的效率和 String 类型的效率差距就很大，就造成了量变引起质变的效果，所以我们一定要优先使用数字类型的变量。\n再比如，我们经常用的 switch 语句，它的实现也很简单，就是将 case 语句排队，然后使用传入的元素，去逐个比较，也是调用了equals()函数，如果相同，那么就执行对应的case分支。\n这里有个技巧：使用 switch 语句时，尽量选择连续的值作为case的code。因为编译器对switch有个优化过程，如果 code 是连续的，就会优化为一个类似于升序的数组，而我们又知道，数组的存取效率很高，所以我们要尽量选择连续的数字类型作为switch的 code。\n类似的用法我们也可以用在基数排序和桶排序上。\n多使用移位操作 在前面第三章中，我们提到了位运算，我们知道，移位运算效率很高，所以我们平常的乘除法就可以用移位运算。\n比如，现在有个商品，单价是 16，买了 15 份，那简单啊，直接：\n1 2 3 int price = 16; int count = 15; int sum = price * count; //结果是240 直接就得到总价了，确实不错，写得好，写得妙，写得呱呱叫。但是，我们是可以优化的，因为单价是 16，也就是 2 的 4 次方，我们直接让买的数量左移 4 位不就行了吗？\n1 2 3 int price = 16; // 单价是2的4次方 int count = 15; int sum = count\u0026lt;\u0026lt;4; // 单价也是240 15 是 1111，左移 4 位是 1111 0000，也就是 $$\n2^{7} $$+ $$ 2^{6} $$ + $$ 2^{5} $$ + $$ 2^{4}\n$$ ，也是 240。但是计算效率高了很多。\n有人说，你这单价是 16，正好是 2 的 4 次放，我要是单价是 15 呢，你怎么算？\n好，假如单价是 15，我买 20 份，那么我就可以这么算：因为 15 是 16-1，也就是 2 的 4 次方 -1，那么我让它左移 4 位，然后再减去自身不就行了吗？也就如下：\n1 2 3 int price = 15; int count = 20; int sum = (count\u0026lt;\u0026lt;4) - count; 这样一来，不用做乘除法，只需要做移位和加减法，就可以了。\n那人又说了，你这属于取巧，15 距离 16 就差一，我要是单价是 13 呢？\n13 等于 8+4+1，也就是 $$\n2^{3} $$+$$ 2^{2}\n$$ +1，那就是：\n1 2 3 int price = 13; int count = 20; int sum = (count\u0026lt;\u0026lt;3) + (count\u0026lt;\u0026lt;2)+count; 直接移位相加就可以了，连减法都不用了。\n其实，电脑做乘除法用的就是加法的原则，比如：25×11，电脑就是将 25 累加 11 次得出的结果，你要是没有背乘法表的情况下，让你来加，你能急炸了。但是人家是电脑，电脑计算的速度非常快，很快就得出结果了。\n但是我还是比较善良的，完全站在电脑的角度替它着想了，所以就优化成移位运算了，这样也可以避免量变引起质变的后果。\n大数据的使用 上一章我们提到浮点类型的时候说到，二进制存在精度问题，那么在我们对数据的精度要求高的情况下，要怎么办呢？\n我们可以采用 API 中提供的大数据类型，直接在编辑器中敲 Big 关键词应该都有的，比如 Java 中的BigDecimal这个类。它就可以保证我们的精度问题，其实这类 API 内部采用的都是字符串，然后将数据分段表示。\n比如，Long 最大能表示 64 位数，如果我要表示 100 位呢？\n嗯，我用BigInteger，它内部其实是个字符串，然后按照正常的加减运算执行，然后将结果用字符串表示出来，没办法，因为 Long 表示不下啊。这就是字符串的强大之处，正如前面我们说的，如果所有的数据类型只能保留一个，那么这个类型肯定是字符串。\n我们来模拟一个加法，来了解下大数据的实现原理。\n题目：将两个字符串相加，并将结果以字符串方式放回。比如：\n1 2 3 num1 = \u0026#34;11\u0026#34;; num2 = \u0026#34;123\u0026#34;; num1+num2 = \u0026#34;134\u0026#34;; 这里我就不秀代码了，直接贴官方答案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public String addStrings(String num1, String num2) { // add表示进位 int i = num1.length() - 1, j = num2.length() - 1, add = 0; StringBuffer ans = new StringBuffer(); while (i \u0026gt;= 0 || j \u0026gt;= 0 || add != 0) { // 如果还有数据，就取这个数据，否则就是0 int x = i \u0026gt;= 0 ? num1.charAt(i) - \u0026#39;0\u0026#39; : 0; int y = j \u0026gt;= 0 ? num2.charAt(j) - \u0026#39;0\u0026#39; : 0; // 本次相加的结果，需要加上上一次的进位 int result = x + y + add; // 缀上相结果的个位数，比如相加得到15，就缀上5 ans.append(result % 10); // 结果大于10就是有进位 add = result / 10; i--; j--; } // 计算完以后的答案需要翻转过来 ans.reverse(); return ans.toString(); } 核心思路说白了就是，将每一位相加，相加后的进位算到下一次里面去，结果用字符串保存下来，这样不管数据有多大，都不会越界，都能得到正确的结果。\n自定义数据类型 有人说，这些数据类型都不满足我啊，怎么办呢？这时候你就可以使用自定义数据类型了，也就是类。\n比如，现在我有辆车，车又不是 int 类型的，也不是 String 类型的，嗯，那我就定义一个类型，这个类型就叫做“车”。\n1 class Car {} 那么，怎么使用呢？跟一般的类型一样，比如你用 int 的时候就是：\n1 int a; 那么你用自定义的“车”的时候，就是：\n1 Car car; 没啥区别，其实对于电脑来说就是：一个类型，一个变量，劳资不管你是啥，你只要是这个原则，我照单全收。\n等等，等等，刚刚我们说到，数组的缺点是扩容难，那么既然我们都可以自定义数据类型了，我们能不能定义一个扩容简单的呢？\n当然可以！\n我们这就可以定义一个链表，我们知道，数组扩容难，是因为它需要元素连续，我们只要让元素不连续不就行了吗？ 那不连续怎么找下一个元素呢？我们可以让上一个元素持有下一个元素的地址啊。\n1 2 3 4 class Node { int value; Node next; } 嗯，好了。\n啥？就这么点代码就是链表了？\n对啊，就这么简单。\n比如，现在有元素 1、2、3，我要存放进去，那么就如下：\n1 2 3 4 5 6 7 8 9 10 11 Node node3 = new Node(); node3.value = 3; node3.next = null; Node node2 = new Node(); node2.value = 2; node2.next = node3; Node node1 = new Node(); node1.value = 1; node1.next = node2; 就可以了，我们只需要知道链表的第一个元素，也就是 node1 就行了，我们要获取到 node3 的话，就先用 node1 获取到 node2，然后再用 node2 获取到 node3 ；也就是：\n1 2 node2 = node1.next; node3 = node2.next; 那这也太费劲了，得挨个去问一遍，但是这样不需要占用连续的内存啊，就算 node1 在地球，node2 在月球，node3 在木叶忍者村，只要根据 next 就能获取到啊。\n那这确实挺不错的，有时候还挺有用的。\n总结 本章我们讲了怎么选择合适的数据类型，以及使用大数据类型和自定义数据类型。\n优先选择小的，因为小的更省内存。 优先选择容易扩容的，项目是多变的，要面向改变编程。 优先选择数字类型的，数字类型的效率更高。 多使用移位操作，移位操作可以提高程序的运行速度。 遇到越界或精度问题可以使用大数据，大数据的核心是使用字符串实现的。 自定义数据类型，当现有数据类型不能满足时，就用自定义数据类型。 那么下一章，我们就来看这些数据是怎么被读入内存并执行的。\n6.计算机的思维:代码的工作流程 前面我们讲了二进制，讲了数据类型，那么这些东西都是怎么跑起来的呢？\n其实，代码就是用控制语句操作数据类型，实现自己的逻辑，然后交给计算器去执行。其大概流程就是：我们用高级语言写的代码 -\u0026gt; 编译成机器代码 -\u0026gt; 读入内存中 -\u0026gt; CPU 执行。\n这一系列操作需要调动 IO、控制器、运算器、寄存器、程序计数器等元件。我们就挨个来了解下这些元件的作用。\n计算机的元件 众所周知，计算机是由控制器、运算器、存储器、输入设备、输出设备这五部分组成的，其中输入设备就是键盘和鼠标，输出设备就是显示器，这我们都见过了，那么控制器、运算器、存储器又是啥呢？CPU 又是啥玩意儿呢？我们来一一揭晓。\n控制器 控制器是 CPU 的一部分，用来控制程序的执行流程。\n程序计数器就是控制器的一部分。我们的代码被编译为机器码之后，就是从上到下逐行执行的，那么要执行哪一行，就是程序计数器来控制的。\n比方说，我写了如下代码：\n1 2 3 int a = 10; int b = 10; int c = a + b; 那么，执行起来大概是这样：\n在代码的执行过程中，每执行一行代码，程序计数器就会加 1，当执行的指令占据多个内存地址时，就会增加与指令长度相应的数值。然后，控制器就会参照程序计数器的数值，从内存中读取命令并执行。也就是说，程序计数器决定着程序的流程。\n比如上述，程序计数器指向 0100 地址时，CPU 就读取这一行的指令，也就是：“将 a 读入寄存器”；由于这一行指令只占用一个内存地址，所以程序计数器只加 1，变成 0101；接着 CPU 就读取下一个地址 0101，然后将 b 读入寄存器；如此反复执行，直到程序结束。\n运算器 运算器也是 CPU 的一部分，它和控制器共同组成 CPU。\n运算器的职责很简单，就是执行运算，比如上面的指令，执行到 0102 时，就需要将 a 和 b 相加，这个时候，运算器就会将两个寄存器的值，也就是 a 和 b 执行加法操作，然后将结果放入寄存器中，以备执行下一步。\n运算器的原理很简单，就是使用我们高中都学过的门电路，举个例子，我们都知道按位与操作是：两个都为真才为真，那么，运算器怎么实现这个逻辑运算呢？\n很简单，我们使用“串联”电路，我们构造一条电路，上面有多个开关，开关闭合表示“真”，开关打开表示“假”，这样，当所有开关都闭合，也就是所有条件都是“真”时，灯泡才亮，我们就当灯泡亮表示真，这就达到了“全真才真”的目的。同样的，或操作就可以使用“并联”电路，只要有一个开关闭合，也就是只要有一个条件为真，灯泡就会亮，这也达到了或操作的“一真则真”的目的。\n用计算机来表示就是 1 表示灯泡亮，也就表示真；0 表示灯泡灭，也就是表示假。真是巧妙的设计！\n有人说，运算器不是从内存中读数据的吗，怎么是从寄存器读数据呢？这跟我理解的不太一样啊。\n寄存器 寄存器是在 CPU 内的，也是 CPU 的一部分。\n因为寄存器是 CPU 的一部分，所以 CPU 从寄存器读写数据非常快，其实，我们通常说的：CPU 从内存中读数据，就是把数据读入寄存器中，但是我们的数据不是直接从内存读入寄存器的，而是先读入一个高速缓存中，然后才读入寄存器的。\n这是为啥呢？因为从内存中读数据太慢了。\n你可以这么理解：CPU 先把数据读入高速缓存中，以备使用，真正使用的时候，就从高速缓存中读入寄存器；当寄存器使用完毕后，就把数据写回到高速缓存中，然后高速缓存再在合适的时机将数据写入到存储器。\nCPU 运算速度非常快，而从内存读数据非常慢，如果每次都从内存中读写数据，那么势必会拖累 CPU 的运算速度，可能执行 100s，有 99s 都在读取数据。为了解决这个问题，我们就在 CPU 和存储器之间放了个高速缓存，而 CPU 和高速缓存之间的读写速度是很快的，CPU 只管和高速缓存互相读写数据，而不管高速缓存和存储器之间是怎么同步数据的。这样就解决了内存读写慢的问题。\n举个例子就是：我每次去书架拿书都很费劲，于是我就直接从书架把书取下来，放在我桌子上，这样就不用频繁去书架取了，等到读完了，就再把桌子上的书送回书架即可。\n那这样有个问题啊，如果别人也想要书架上的那一本书怎么办？\n问得好！这就是多线程问题，其实解决方案很简单，就是一个同步问题，要么你等我看完了再看，要么就多弄几本。这个问题我们在后面的操作系统部分再详细展开。\n程序的执行流 经过上面的说明，我们大致了解了程序的执行过程：我们的代码先被编译成一条一条的指令，要执行的时候就先读入高速缓存，然后将要执行的指令地址放在程序计数器中，控制器控制着这些指令按序执行，遇到数据就读入寄存器来让运算器执行，执行完毕后就放回寄存器执行下一条，全部执行完毕后就把数据写回高速缓存，高速缓存在合适时机就将数据同步回内存。\n唉，等等等等，这好像不对啊，程序不一定是按顺序执行的，比如遇到if-else语句呢？遇到return语句呢？还会按顺序执行吗？\n肯定不会，其实程序的执行流程可以分为：顺序执行、条件分支和循环执行这三种。\n条件分支和循环 考察如下代码:\n1 2 3 4 5 6 7 8 int a = 2; int b = 10; int c; if(a \u0026gt; 3) { c = a + b; }else { c = 2 * a; } 这个例子中有个条件分支，代码肯定不会顺序执行，那我们来看它是怎么执行的。\n我们看到，在执行到指令 0102 时候，由于不满足a\u0026gt;3这个条件，就直接跳转到 0104 这个指令去执行了；而且，计算机很聪明，如果它在编译期间发现 a 永远不可能大于 3，它就会直接删除 0103 这条指令，然后，0104 这条指令就变成了下一条指令，直接顺序执行，也就是编译器的优化。\n那么，计算机怎么知道 a 是不大于 3 呢？很简单，做减法，计算机使用 a-3，发现结果小于 0，就知道 a 小于 3 了。\n计算机中的比较操作，就是做减法，结果大于 0 就是大于，结果小于 0 就是小于，结果等于 0 就是相等。\n其他的循环语句和跳转语句，也是类似的过程，这里不多废话。\n上面我们讲的都是单个函数，那么如果是多个函数互相调用呢，会是什么样的结果呢？\n函数的调用流程 函数的调用需要用到函数的调用和返回指令，我们看个例子：\n1 2 3 4 5 6 int a = 10; int b = 11; void int sum(int a, int b) { return a + b; } 代码的执行过程大概是如下这样：\n这里执行函数的时候，使用的是call指令，而不是if-else中的跳转指令，我们要注意，call 指令和 return 指令总是成对出现的，也就是说：有函数调用，就有函数返回。\ncall指令会把调用函数后的下一条指令存入栈中，然后执行函数逻辑，在函数执行完后，return指令会把栈中的下一条指令弹出，并写入程序计数器中，这样就接着执行下一条指令了。又因为 call 和 return 是成对出现的，所以即使多个函数调用嵌套调用，也不会出现问题。\n比如上述例子中，在执行到 0102 时候，call指令就把 0103 压入栈中，接着执行函数逻辑；当执行完毕后，return指令就把 0103 这个再弹出写回到程序计数器，这样程序计数器就接着执行 0103 对应的指令，程序就按照我们的逻辑执行了。如此一来，程序的执行非常有序且流畅。\n机器指令 其实，CPU 的处理流程很简单，就是按照给定的指令去执行，CPU 的指令有以下几种。\n数据传送指令：执行数据的读取操作，比如从寄存器读数据，将数据写入寄存器。 运算指令：执行算数运算和逻辑运算，比如加法运算，按位与运算，比较运算。 跳转指令：条件分支、循环、跳转等操作。 调用/返回指令：函数调用/返回操作。 这些指令可能包含很多汇编指令，但是就是这么几种类型，只要用以上这些指令，就能完成所有的程序流程。是不是很简单呢？\n总结 本章我们讲解了控制器、运算器、寄存器的作用，以及程序的工作流程，其实，所有这些都可以用简单的几条指令来概括，我们只需要了解其原理即可，不必死记硬背。\n指令类型 功能 数据传送指令 执行数据的读取操作，比如从寄存器读数据，将数据读入寄存器等 运算指令 执行算数运算和逻辑运算，比如加法运算，按位与运算，比较运算等 跳转指令 条件分支、循环、跳转等操作 调用/返回指令 函数调用/返回操作 那么，下一节，我们就来看下该怎么优化我们的程序流，以让代码变得更高效。\n7.替朋友找想:优化我们的程序流 上一章我们讲了程序的执行流程，知道代码是怎么运行的了，那么，我们该怎么让我们的代码更高效呢？\n条件语句的优化 我们先来看条件语句的优化，我们知道，条件语句只有两种：if-else和switch。\nif-else 语句的优化 根据上一章，我们知道 CPU 在遇到条件语句时，会执行跳转逻辑，那么，我们的优化点就是让 CPU 尽量不跳转，或者少跳转。\n考察如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public String check(int age, int sex) { String msg = \u0026#34;\u0026#34;; if(age \u0026gt; 18) { if(sex == 1) { msg = \u0026#34;符合条件\u0026#34;; }else { msg = \u0026#34;不符合条件\u0026#34;; } }else { msg = \u0026#34;不符合条件\u0026#34;; } return msg; } 逻辑很简单，就是筛选出age\u0026gt;18并且sex==1的人，代码一点儿问题都没有，但是太啰嗦，站在 CPU 的角度来看，需要执行两次跳转操作，当age\u0026gt;18时，就进入内层的if-else继续判断，也就意味着要再次跳转。\n其实我们可以直接优化下这个逻辑，我们知道，逻辑与操作有个特点：全真才真，那就意味着，只要第一个不满足条件，后面的就不用看了。根据这个特点，我们就直接优化成如下代码：\n1 2 3 4 5 6 7 8 9 public String check(int age, int sex) { String msg = \u0026#34;\u0026#34;; if(age \u0026gt; 18 \u0026amp;\u0026amp; sex == 1) { msg = \u0026#34;符合条件\u0026#34;; }else { msg = \u0026#34;不符合条件\u0026#34;; } return msg; } 这样一来，只需要执行一次判断，也就是只需要执行一次跳转逻辑，就可以了，这就节省了 CPU 的力气；其实这不是最简单的，还可以更简化，比如：\n1 2 3 4 public String check(int age, int sex) { if(age \u0026gt; 18 \u0026amp;\u0026amp; sex == 1) return \u0026#34;符合条件\u0026#34;; return \u0026#34;不符合条件\u0026#34;; } 这样是不是更好了，连else语句都省了，不仅效率提高了，而且连可读性也提高了。\n其实，这些都可以总结为一点：逻辑能提前结束就提前结束。\n比如，上述的两层if-else判断逻辑，因为只要有一个不符合就能直接提前结束，所以我们就使用逻辑与操作来提前结束。\n多个判断的if-else逻辑，我们也可以优化，比如：\n1 2 3 4 5 6 7 public String getPrice(int level) { if(level \u0026gt; 10) return 100; if(level \u0026gt; 9) return 80; if(level \u0026gt; 6) retrn 50; if(level \u0026gt; 1) return 20; return 10; } 我们不用添加else分支，尽量提前结束即可，这样执行效率高，可读性也强。\nswitch 语句的优化 其实switch语句和if-else语句的区别不大，只不过写法不同而已，但是，switch语句有个特殊的优化点，那就是数组。\n比如还是上述代码，我们改成 switch 语句：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public int getPrice(int level) { switch(level) case 10: return 100; case 9: return 80; case 8: case 7: case 6: return 50; case 5: case 4: case 3: case 2: case 1: return 20; default: return 10; } 看着没啥区别，其实编译器会把它优化成一个数组，其中数组的下标为 0 到 10，不同下标对应的价格就是 return 的数值，也就是：\n而我们又知道，数组是支持随机访问的，速度极快，所以，编译器对switch的这个优化就会大大提升程序的运行效率，这可比一条一条执行命令快多了。\n那么，我还写个毛的if-else语句啊，我直接全部写switch不就行了？\n不行！因为编译器对 switch 的优化是有条件的，它要求你的 code 必须是紧凑的。\n紧凑是啥意思呢？必须小吗？不是，是连续的，比如：你的 code 是 1、50、51、101、110。这不是紧凑。 而你的 code 是 1000、1001、1002、1003。这就是紧凑。\n这是为什么呢？因为我要用数组来优化你啊，你如果不是紧凑的，比如上述的最小 1，最大 110，我就要创建一个长度 110 的数组来存放你，而这么长的数组中，只有：1、50、51、101、110 这几个位置有用，岂不是浪费空间！\n那这也不对啊，你那个 1000 开头的虽然紧凑，但是它大啊，你要创建一个长度为 1003 的数组呢。\n真是老实人啊，我不需要创建那么大，我只需要创建长度为 4 的数组就行了，下标分别为 0、1、2、3。计算的时候，我就用实际数字减去 1000，就得到对应的下标了，这就是个减法问题，效率是很高的。\n所以，我们在使用switch的时候，尽量保证 code 是紧凑的，也就是连续的；也尽量使用数字类型的，因为你使用引用类型的话，它实际执行的 code 是引用类型的 hashcode，hashcode 是个 int 类型的数字，也不能保证是连续的。\n循环语句的优化 其实循环语句跟条件语句很类似，只不过写法不同而已，循环语句的优化点也是以减少指令为主。\n我们先来看一个中二的写法：\n1 2 3 4 5 6 7 8 9 10 // 找出名字为张三的人 public User findUserByName(Users users) { User user = null; for(int i = 0; i \u0026lt; users.length; i++) { if(users[i].name.equals(\u0026#34;张三\u0026#34;)) { user = users[i]; } } return user; } 哈哈哈哈哈，真是人才啊，如此代码，先拉出去打一顿再说。\n大哥，你说你这都找到人了，直接返回不行吗？还要接着遍历干啥？如果数组长度是 10086，第一个人就叫张三，那后面那 10085 次遍历不就白做了，真拿 CPU 不当人啊，生产队的驴看了都流泪。\n你直接这样写不就行了：\n1 2 3 4 5 6 7 8 // 找出名字为张三的人 public User findUserByName(Users users) { for(int i = 0; i \u0026lt; users.length; i++) { // 找到了就趁早返回，别在那墨迹了 if(users[i].name.equals(\u0026#34;张三\u0026#34;)) return user[i]; } return null; } 这样写效率高，可读性强，也符合我们上述的逻辑能提前结束就提前结束这个观点。CPU 直接感谢你全家。\n其实，这里还有一点可以优化的地方，就是我们的数组长度可以提取出来，不必每次都访问，也就是这样：\n1 2 3 4 5 6 7 8 9 10 // 找出名字为张三的人 public User findUserByName(Users users) { // 将数组长度提取出来，不必每次循环都访问 int length = users.length; for(int i = 0; i \u0026lt; length; i++) { // 找到了就趁早返回，别在那墨迹了 if(users[i].name.equals(\u0026#34;张三\u0026#34;)) return user[i]; } return null; } 这看起来好像有点吹毛求疵了，确实是，但是如果考虑到性能的话，还是有点用的。比如有的集合的size()函数，不是简单的属性访问，而是每次都需要计算一次，这种场景就是一次很大的优化了，因为省了很多次函数调用的过程，也就是省了很多个call和return指令，这无异是提高了代码的效率的。尤其是在循环语句这种容易量变引起质变的情况下，差距就是从这个细节拉开的。\n对于循环这种操作，我们要考虑的肯定是提前结束，越提前结束，效率越高。那么，遍历的时候，我们就要考虑一下遍历的方向了。\n比如，我们要找一个年龄为 60 岁的人，而根据我们的经验，越早注册的用户，年龄越大，也就越早被添加到数据库中，也就越靠前，而 60 岁本来就是一个比较大的年龄，所以我们应该从前往后遍历，这样就能提前命中。而如果我们要找一个 20 岁的用户，则正好相反，就要从后往前遍历，这样才能更提前命中。\n这些原因，还是那句话：逻辑能提前结束就提前结束。所以我们的工作重点就变成了：怎么让逻辑提前结束？\n我们在执行循环的时候，尽量不要在循环体内创建变量，比如：\n1 2 3 4 5 int sum; for(int a = 0; a \u0026lt; 10; a++) { int b = a*2; sum +=b; } 这每次循环，都创建一个 b，而前面我们讲过，局部变量的生命周期跟当前函数绑定，只要这个函数没调用完，它就一直存在，这真是没事找事，大大浪费内存，如果在循环体内创建对象，就更罪不可赦了。\n要是真需要的话，可以改为如下代码：\n1 2 3 4 5 6 int sum; int b; for(int a = 0; a \u0026lt; 10; a++) { b = a*2; sum +=b; } 这样只有一个变量，降低了内存使用率，也提升了代码的执行速度。\n另外一个点就是，我们在遍历集合的时候，应该优先使用迭代器，这里面的原因就不多说了，大家去看一下相关的源码就明白了。\n递归的优化 递归是一门伟大的发明，我们可以通过简单的函数调用，实现很复杂的逻辑。比如，求斐波那契数列的代码:\n1 2 3 4 5 6 public int fib(int n) { if(n \u0026lt; 0) throw new IllegalArgumentException(\u0026#34;参数不合法\u0026#34;); if(n == 0) return 0; if(n == 1) return 1; return fib(n-1) + fib(n-2); // 递归 } 代码很精彩，也没毛病，但是我们仔细想一下，假如n=10，流程如下：\nf(10) = f(9) + f(8); //分别计算f(9)和f(8)； f(9) = f(8) + f(7); //分别计算f(8)和f(7)，唉等等，上面我们计算过了f(8)啊，这里怎么还要计算； f(8) = f(7) + f(6); //分别计算f(7)和f(6)，又计算了一遍f(7)。 想必你已经看出问题了，我们做了好多次重复计算，这显然是不应该的。那么，我们能不能把这些重复的计算只做一次呢？\n当然可以，不过我们就需要把重复计算的结果保存下来了，我们可以定义一个数组，将每个f(n)都保存下来，后面需要的时候直接去取就行了，修改后的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 // 修改后的代码，用一个数组保存计算过的结果 public int fib2(int n) { if (n == 0) return 0; int[] fibs = new int[n + 1]; // 用来保存从0到n的n个斐波那契数 fibs[0] = 0; // 存0 fibs[1] = 1; // 存1 for (int i = 2; i \u0026lt;= n; i++) { fibs[i] = fibs[i - 1] + fibs[i - 2];// 这里不用递归计算了，直接用前面计算过的结果即可 } return fibs[n]; } 改版后的代码不再是递归的了，而是采用一个数组缓存了计算的结果，后面的每个计算，直接去数组里获取即可。这种思维其实叫做动态规划（Dynamic Programming），简称为 DP。\n那么，什么情况下我们的递归函数可以使用动态规划呢？\n当我们的递归函数是运算类型的，并且里面有大量重复的运算的时候，就该想到采用动态规划。\n关于动态规划的更多知识，我们会在后面的数据结构部分详细展开。\n总结 本章详细讲解了几个程序流的优化方案，其实说白了就是一点：逻辑能提前结束就提前结束，最后还对递归进行了一个优化讲解，也就是避免大量的重复计算。\n我们再来回顾下：\n对条件语句的优化，需要逻辑提前结束； 对 switch 语句的优化，需要 code 是数字类型的，且尽量紧凑； 对循环语句的优化，也需要逻辑提前结束，并且不在循环体内声明变量； 对递归函数调用的优化，不做大量重复计算。 这些所有优化都围绕着一个核心：减少 CPU 执行的指令数，减少 CPU 执行的运算次数。说白了就是，替我们的好朋友 CPU 着想，别光顾着自己写着爽。\n那么，下一章，我们就来看下我们人类和计算机之间的区别到底在哪里。\n8.不同的思维:面向过程和面向对象 前面说到，代码是由我们写的，写完后就交给编译器去编译为电脑认识的东西，然后电脑再把它放到 CPU 里面去高速执行，最后再将结果展示给我们。这里面涉及到两次视角转换：一次是我们将写的转换为电脑认识的；一次是电脑执行完后转换为我们认识的。\n换句话说就是：我们写的代码是面向我们的，编译为电脑执行的代码就是面向计算机的。\n正如下图所示：\n我们发现，人看的东西很直白，但是效率又很低；而电脑看的东西则根本无法读懂，但是效率又很高；那么怎么让人容易看明白，电脑执行起来又高效呢？\n这就涉及到一个问题：面向对象和面向过程。\n面向过程 面向过程是以当前发生的事情为目标进行编程，以过程为核心，不考虑将来可能发生的事情。\n简单直白点说就是：我只管现在的，将来啥样我不管，将来好不好改我也不管，我重视的就是当前这个过程，这就是计算机的思维。比如 C 语言，就是这个原理，C 语言是没有对象的，有对象的 C 语言叫 OC，虽然被骂的自己都不认识自己了，但是起码人家有了对象。\n比如，现在要做个车库管理软件，用面向过程的思维就是：只有一个类，你要干啥全部写在这里面，趁早把肚子里的需求直接梭哈，否则将来不好改我不改，或者你加钱。我不管好不好改，我只管现在写着爽不爽，快不快，刺激不刺激。\n那么？面向过程这么垃圾的，为什么还存在呢？\n因为有用啊！\n面向过程本来就不是用来做客户软件的，是用来写计算机硬件的，谁家计算机硬件天天改？\n而且，面向过程主要是针对计算机的，你跟计算机谈扩展性？跟计算机谈可读性和可维护性？抱歉，劳资是计算机，懂吗，计算机！我一秒一亿次的速度你有吗？就算我可读性再差，我也能用速度击败你。\n其实，面向过程的速度并不差，反而更快！\n为啥子呢？因为面向过程只注重当前，不注重未来的拓展性，所以就没有多余的逻辑，反而执行得更快。\n考察如下代码：\n1 2 3 4 5 6 7 8 9 10 int getPrice(int level){ if(level\u0026gt;10) { return 100; }else if(level\u0026gt;9) { return 90; }else if(level\u0026gt;5) { return 50; } return 10; } 这是面向过程的，如果将来加了其他 level，那就继续加 if-else 分支，拓展性真是差的一批，看不下去了，我去看面向对象的写法。\n1 2 3 4 5 6 7 8 9 10 11 interface IGetPrice { int getPrice(int level); } class Level10 implements IGetPrice{ int getPrice(int level) { return 100; } } class Level9 implements IGetPrice { } class .... 嗯，拓展了多了类，用反射根据 level 创建出对应的对象就可以了，将来增加需求只需增加一个类就行了，拓展性确实强。\n但是，哪个效率高啊，明显是面向过程效率高啊，只需要调用函数，甚至连对象都不用创建，就可以了。\n所以，你看，面向过程还是有用的，尤其是在开发需求修改不频繁，比如写一些工程算法或者写系统软件的时候，就应该采用面向过程，因为这时候要求的不是拓展性，而是速度，是性能！\n那么，不要求速度的时候呢？那就应该考虑面向对象了。\n面向对象 什么是面向对象呢？\n面向对象就是将世间万物都视为对象，针对这些对象的具体行为进行编码。\n面向对象有三大特点: 封装、继承和多态。\n封装 封装就是把现实事物封装成抽象的类，并可以将类的权限加以修改，把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。\n简单来说就是：你只能看我给你看的，只能改我让你改的，别的你都不可以。\n封装是面向对象的特征之一，是对象和类概念的主要特性，如果没有封装，那么继承就是无意义的，多态也就不存在了。\n封装让对象针对不同的角色有不同的表现，让程序更有层级感。\n有人说，封装不就是将一些属性改为私有的，一些属性改为公有的吗，也就是改个权限吗？\n不是！\n修改权限只不过是封装的一部分，而且是次要部分，封装的主要部分是：将具体事物抽象成类这个过程。\n比如，现实中的一辆汽车，你把它抽象为一个类：\n1 class Car {} 这才是封装的主要部分。\n继承 继承是让类拥有另一个类的数据和函数，表达一种我也是你的关系。\n继承的类叫做子类，也叫做派生类；被继承的类叫做父类，也叫基类。\n就像人类只有一个亲爹一样，子类也只能有一个父类。C++ 这种就另当别论。\n比如，上述的汽车，我们具体封装如下：\n1 2 3 4 5 6 7 8 9 10 class Car { private int speed = 100; public int price = 100; public void run() { println(\u0026#34;run\u0026#34;); } } class AudiCar extends Car { } 我们的AudiCar只需要继承一下Car，那么它就自己带有了Car里面的price和run()了，因为继承了就表示我也是你，那么奥迪车也是车，也有价格、也会跑。那么，里面有个speed是私有的属性，AudiCar有没有这个属性呢？答案是有的，其实也确实是继承了的，只不过不可见而已，不可见且不可修改，那也就等于没有继承。\n那你这继承有啥用呢？我自己再写一份不就行了吗？\n继承可以省略大量代码，并且容易拓展，子类的公有属性和行为都可以放在父类中，而子类只需要放自己特有的属性和行为就可以了，这样可以统一处理子类的共有属性，方便管理；而子类的特有属性又可以在子类内部自己处理。\n如果，我不仅有一个奥迪车，还有宝马、奔驰、布加迪，那么我只要创建出它们的类型，直接继承Car就行了，就不用反复声明run()和price了，这就节省了代码。\n有人说，不对啊，它们的速度都不一样，价格也不一样，你这直接继承了肯定有问题啊。\n这就涉及到多态了，其实继承就是为了多态。\n多态 多态指的是：一个类的子类可以有不同的表现。\n比如，还是上述例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Car { private int speed = 100; public int price = 100; public void run() { pritnln(\u0026#34;run\u0026#34;); } } class AudiCar extends Car { public void run() { println(\u0026#34;audi run\u0026#34;); } } class BenchiCar extends Car { public void run() { println(\u0026#34;Benchi run\u0026#34;); } } 我们让奥迪和宝马分别实现了自己的run()，但是它们价格和速度都一样，这就是多态，可以拥有相同的属性，也可以拥有不同的行为。\n上面我们说到，继承就是为了多态。\n谁跟你说的？你怎么证明？\n我跟我说的，这就来给你证明。\n假如继承不是为了多态，那么上述的AudiCar和BenchiCar的代码就一模一样，都跟Car一样，那么，你是吃饱了撑的写三个一模一样的类吗？所有地方直接使用Car不就行了吗。\n有人说，我复用啊，继承除了多态不就是复用吗？\n大哥，你这不是复用，你这是 CV，你这代码一模一样，复用率都 100% 了，就不叫复用了。\n所以，继承就是为了多态。\n那么，多态又是为了啥呢？\n多态是为了代码容易修改，容易拓展。换句话说，没有多态，就没有设计模式了。\n我们考察如下代码，我要一辆汽车，上班开：\n1 2 3 4 5 6 7 public User { public AudiCar car; public void goWork(){ car.run(); } } 简单明了的代码，直接给你一辆奥迪车。如果有一天，我发现奥迪车被偷了，那就只能换个奔驰了？\n嗯，那就修改下代码：\n1 2 3 4 5 6 7 public User { public BenchiCar car; public void goWork(){ car.run(); } } 如果后面再想换呢？那就再改？\n这样不太好啊，我本来只说要个能跑的车就行，没有说要啥车，只要能跑就行啊，那所有的车都能跑啊，直接这样行吗：\n1 2 3 4 5 6 7 public User { public Car car; public void goWork(){ car.run(); } } 并不指定啥牌子的车，只要是车就行，换句话说，不指定具体的子类，而是指定它们共同的能跑的父类——车！\n这样将来不管你啥车被偷都没事，只要不被偷光，我就不用改代码：\n1 2 3 Car car = new AudiCar(); car = new BenchiCar(); car = new 还没被偷的Car(); 都可以啊，这就是多态的好处，拓展性强，容易修改。\n继承和实现的关系 我们上述说到了继承关系只能有一个，也就是只能有一个父类。那么，如果我需要多继承呢？\n这时候你就可以用接口了。\n接口表示我具有某种功能，继承表示我就是某种东西。\n当然，你只能是一种东西，所以你只能单继承；但是你可以有多种功能，所以你可以实现多个接口。\n1 2 3 4 5 6 7 interface CanFly {} interface CanSwim {} interface Can72Change {} class NvWa {} class Sunwukong extends NvWa implenents CanFly, CanSwim, Can72Change { } 孙悟空这么牛叉的人，即使会飞、会游泳、能 72 变，也只能有女娲这一个父类。\n继承的坏处 上面我们通过实现接口解决了多继承的问题，那么继承有什么坏处呢？\n嗯，继承破坏了封装。上面我们说了，封装的次要功能是：将某些属性保护起来，不被别人知道。但是，一旦你被继承了，你那些保护起来的东西，也都被子类继承到了，那么子类会不会滥用呢？\n这就要看儿子的心情了。坑爹的儿子还是有的，所以，我们就发明了权限关键词这个东西。\npublic：所有人可见。 protected：只有自己和子类可见。 private：只有自己可见。 final：用来修饰方法，避免被重写。 父类只要把自己的属性声明为 private 类型的，那么子类也就不可见了（通过反射修改的行为是可耻的）。\n通过这个东西，就可以惩治劣子，让继承更加完美。\n总结 本章我们重点介绍了面向过程和面向对象，其中面向过程主要使用在一些不可变的，或者少变的工程项目，比如：操作系统、工程算法，这类项目以追求性能为主。而面向对象则用在一些软件开发、客户需求上面，这类项目是最多的。\n我们还讲了面向对象的三大特性：封装、继承和多态。\n封装：将事物抽象为一个类，然后针对不同的对象添加不同的访问权限。 继承：使得自己拥有父类的属性和方法，只能单继承。 多态：子类可以有跟父类不同的表现。 下一章，我们就在实际项目中来使用面向对象的这些特点。\n9.换位思考:程序该面向谁? 上一章我们说了，当我们要写一个系统软件或者要写一个算法的时候，可以选择面向过程；而当我们要做一个客户软件的时候，可以选择面向对象。\n其实我们可以简单直白点，如下。\n面向过程：适合计算机看的代码，执行效率高，可读性差，可维护性差。 面向对象：适合人看的代码，执行效率低，可读性好，可维护性好。 其中，开发系统的人和写工程算法的人，本来就不是正常人，应该算是“计算机的一种”吧。\n面向过程和面向对象都是解决问题的一种手段，没有最好的，只有最合适的。\n面向过程的使用 面向过程适合注重性能的，不注重拓展性的，看重当前的，不看重未来的场景。\n现在让我们写一个具体需求：我要开发一个直播间，直播间有很多消息，我需要将这些消息进行唯一标记，为了避免刷屏，对同一个人的消息，如果消息的内容相同，那就将它们视为同一个消息。\nOK，需求有了。消息要有唯一标记，这就要用到发消息人的 id，以及消息的内容了。需要将这两个属性进行合并，合并成一个属性，那我们可以尝试获取消息内容的长度，然后加上消息的 hashcode，最后再拼上发消息人的 id，以此作为唯一的 key，将整个消息放在一个哈希表里面去（哈希表自带去重功能）。\n我们开始写代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private Map msgMap = new HashMap\u0026lt;Long,String\u0026gt;(); public void save(int uid, String msg){ msgMap.put(genID(uid,msg),msg); } private long genID(int uid, String msg) { // 获取消息的长度 int size = msg.length; // 获取消息的hashcode int hash msg.hashCode(); // 将消息的长度和hashcode合并生成消息id int msgId = hash+size; // 将用户id作为高32位，消息的id作为低32位 long onlyID = uid \u0026lt;\u0026lt; 32 + msgId; } 代码仅做个演示。等等等等，先不说代码，你这好像没什么设计啊、拓展性啊、接口啊，咋不用呢？\n毕竟这是写功能性算法呢，不是搁这吹架构的。\n算法要求的是啥？是正确性，时间复杂度，空间复杂度，简单来说就是性能。而不是看你用了什么设计模式，好不好改。这你还纠结有几个类型、几个对象吗？\n而且，这个需求是你自己的内在需求，又不是那些产品经理提出的，难不成你今天用 uid 算，明天吃饱了撑得慌，就想改成用名字的 hashcode 来算吗？肯定不会啊，我又不傻。\n所以说，追求性能的、可变性低的需求，就用面向过程的思维即可。\n比如上述需求，第一是追求性能的，第二是我自己提出的，我也肯定不会瞎改，就满足了这两个特点，我就使用面向过程来写了，只追求当前的需要，只注重当前的结果。\n如果你在开发中遇到这类问题，代码直接梭哈到一个文件里也是没错的。比如：工具类、配置类、自定算法等。其实，很多人也都是这么做的，只不过不知道这是面向过程一样，这就是人的应激性，现在你知道了。\n面向对象的使用 面向对象适合注重拓展性的、看重未来的场景。\n假如现在我要写一个直播间功能，产品说：第一版只需要有观众，能发消息、连麦聊天就行。\n嗯，第一版只需要这些，那就是后面还有其他版本要加功能了。\n好，我们就先来写第一版的代码。核心功能就是两个：发消息和连麦。我们知道，发消息是需要展示在 UI 上的，而连麦则不需要展示在 UI 上，只需要听到就行了。\n那么，我们就写两个类来负责这两块功能，如下：\n1 2 3 4 5 6 7 8 // 负责消息管理的MsgManager class MsgManager { private String[] msgs = new String[1000](); // 用来存放消息，最多存放1000条。 private int curIndex = 0; public void addMsg(String msg) { msgs[curIndex++] = msg; } } 1 2 3 4 5 6 7 8 9 10 11 12 // 负责声音管理的AudioManager class AudioManager { public void openMic() { // 打开mic } public void closeMic() { // 关闭mic } ....其他代码 } 行了先别写了，我们为啥用面向对象的呢？为啥不用面向过程的呢？直接代码梭哈到一个文件里不行吗？\n当然可以！不过如果后面产品要改需求的时候，希望你别哭就行。\n过了一个月，产品来了，我们要添加一个小窗功能，小窗出去的时候，消息不用展示了，但是要能听到声音。\n哦，不要消息了，要声音。前面把代码都梭哈到一个文件里的那个哥们，你还好吗？你这打算怎么改呢？你这都在一个文件里，要么一起活，要么同归于尽，你现在准备把代码挑出来吗？\n其实这里我们应该反思下，我们的代码逻辑可以分为两大类：UI 相关的和 UI 无关的。\n我们需要把 UI 相关的写成一大部分，把 UI 无关的写成另一大部分。这样，当我们的 UI 销毁时（比如小窗时），只需要把 UI 相关的销毁即可，而 UI 无关的（比如声音）则继续执行，这就是 MVC 架构的雏形。\n那么现在，我们的代码就变成了如下这样：\n1 2 // 负责UI相关的逻辑 class UIManager {} 1 2 // 负责UI无关的逻辑 class DataManager {} 又因为，我们的 UI 需要使用数据来绘制，所以我们的UIManager需要持有DataManager，也就是：\n1 2 3 4 5 6 class UIManager { DataManager dataManager; void displayUI() { // 使用dataManager来渲染 } } 而且，我们前面章节说过，成员变量的生命周期和对象的生命周期同步，也就是说，当UIManager被销毁后，它持有的dataManager也不存在了，那么，这个dataManager就不应该在UIManager中创建，否则它也会随着UIManager的销毁而销毁。所以，我们应该在一个生命周期更长的地方创建出dataManager，然后在UIManager被创建的时候传给它让它使用。所以，我们的代码就变成了：\n1 2 3 4 // 这是生命周期更长的类 class GlobalManager { DataManager dataManager = new DataManager(); } 1 2 3 4 5 6 7 8 // 管理UI的类 class UIManager { DataManager dataManager; public void setData(DataManager dataManager) { this.dataManager = dataManager; } } 好，现在，我们的大概框架就搭建好了。当 UI 创建的时候，我们就给它传递dataManager让它渲染 UI；当 UI 销毁的时候，我们的数据在生命周期更长的GlobalManager中继续执行，保证逻辑不断，比如消息还在接收，声音还在传递。这样，下一次你从小窗口回来的时候，你看到的消息、听到的声音，都是最新的，就跟在直播间里面没区别，就像直播间根本就没断开过一样，这也正是我们需要的。\n其实，GlobalManger就相当于我们的进程，就像Android中的AppAplication，就像系统中的服务一样，生命周期跟整个应用的生命周期同步。\n有人说，这不对啊，你这把数据存放在应用进程一级的了，那不就意味着除非应用退出，否则你的直播间一直在运行吗？那我要退出直播间怎么办？\n还记得我们前面讲过的提前结束对象的生命周期吗？没错，就是将它设置为 null！\n我们可以改造我们的GlobalManager代码，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 这是生命周期更长的类 class GlobalManager { DataManager dataManager; // 创建直播间 public void createLiveRoom() { dataManager = new DataManager(); } // 销毁直播间 public void destroyLiveRoom() { dataManager = null; } } 这样，我们直播间的生命周期就比我们的应用短了，完全由我们自己来控制。\n又有人说了，那我要有两个直播间呢？比如说一个只听声音，一个只打字的，你要怎么实现呢？\n我们可以用类似的方法实现，我们修改我们的代码，如下：\n1 2 3 4 5 // 定义直播间类型 enum RoomType { SOUND_ROOM, // 声音直播 MSG_ROOM, // 消息直播 } 1 2 3 4 5 6 7 8 // 定义直播间顶层数据 interface RoomData {} // 声音直播间数据 class SoundRoomData implements RoomData {} // 消息直播间数据 class MsgRoomData implements RoomData{} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 这是生命周期更长的类 class GlobalManager { // 用来存放所有的直播间数据 private Map roomDatas = new HashMap\u0026lt;RoomType, RoomData\u0026gt;(); // 创建直播间 public void createRoom(RoomType type) { if(type == SOUND_ROOM) { roomDatas.put(type,new SoundRoomData()) }else if(type == MSG_ROOM) { roomDatas.put(type,new MsgRoomData()) } } // 销毁直播间 public void destroyRoom(RoomType type) { roomDatas.remove(type); } // 获取直播间数据 public RoomData getRoomData(RoomType type) { return roomDatas.get(type); } } 上述代码逻辑就用一个 map 保存了所有直播间的数据，并且可以多个直播间并存，生命周期也靠自己控制，当然，这只是简单的 demo，在后面我们的项目实战中，将会有个完整的代码示范。\n总之，面向对象远比面向过程要复杂，因为它要考虑未来的各种可能性，而未来又是不可预测的，所以我们要写出尽可能多变的、拓展性强的代码，说白了就是：面向拓展编程，或者说是面向未来编程。\n总结 本章我们从计算机和人类的角度出发，剖析了两个案例来说明面向过程和面向对象的选择。\n当我们只需要注重当前场景，只注重性能的时候，我们就选择面向过程来编码，而当我们更注重拓展性，需要考虑到未来的各种可能性的时候，我们就选择面向对象来编码。\n其实有个很简单的诀窍，如果你是偏向硬件开发的，偏向底层开发的，比如 C 或者 C++ 工程师，那你就选择面向过程，因为硬件是不变的，很多东西的底层也都是一样的，不会大变的。\n而如果你是一个偏向应用开发的，比如 Java 工程师，或者前端工程师，那你就选择面向对象开发，因为产品经理都是善变的，用户的口味也都是随着时间变化的。\n当我们在做面向对象开发的时候，一定要考虑好拓展性，考虑好对象的生命周期，不能太短也不能太长，太短则不满足需求，太长则容易发生内存泄漏，这点一定要特别注意。\n下一节，就让我们走进实际的项目中，了解下工程项目中的数据结构。\n10.数据结构之基:从根上儿了解数据结构的特性 学好数据结构，就等于成功了一半。\n程序是对现实的模拟，现实是由时间和空间组成的，高效的人都是用最少的时间、最少的空间来做最伟大的事，程序亦是如此。我们要选择最合理的算法和最合理的数据结构，来写最好的代码，这也正是时间复杂度和空间复杂度的要求。\n所以，学好数据结构，选择合理的数据结构，降低时空复杂度，就等于成功了一半。\n我们可以将数据结构分为两大部分：线性数据结构和非线性数据结构。\n线性数据结构：数据元素之间的关系是一对一的。 非线性数据结构：数据元素之间的关系不是一对一的。 线性数据结构 数据元素之间的关系是一对一的。可以简单地记忆为：一根绳子不分叉！\n这是嘛意思呢？\n可以这么理解：我有一根绳子，上面打了好多结，我随便找到一个结点，不管往哪一端捋，都只能找到一个点，除非到头了导致没结点了。说白了就是：这根绳子没有分叉。\n比如我们生活中的排队，就是这个模型。你前后最多都只有一个人，也就是：一对一的。\n这个模型有很多衍生物，我们来逐个看下。\n1. 顺序表 顺序表是紧密相邻的线性数据结构。便于查找元素，不便于插入和删除元素。\n也就是说：顺序表的所有元素都是一个挨一个的。\n比如军训时候的排队，所有人都在操场内；再比如核酸检测时的排队，所有人都在检测亭附近；前一个人挨着后一个人，紧密相邻。\n所以，顺序表的特点就是：相邻！\n这样就有一个明显的特点，因为我们彼此是挨着的，那么就等于排好了队。那么，我只要知道某个人的位置，就能找到他。\n那么，我们就可以根据这个特点给每个元素定个编号，然后根据编号直接找到对应的元素。如下图所示：\n我们要找第 𝑖个人，也就是 𝑎𝑖，直接去第 𝑖−1 位置即可，这样非常快，不用一个一个数。\n那有人就说了，既然这么方便，我们直接全部用顺序表不就行了吗？不行！\n这样找着是很快，但是，你发现了吗，如果少了一个元素，后面的所有元素都要往前挪一步；插入一个元素，后面所有元素都要往后挪一步。就像排队，有人插队和离队，后面所有人都要挪一步。\n那么，能不能不挪呢？如果不挪，就留了个空位，那么空位前后的人就没有相邻元素了，那么就从空位开始断开了，那么就不是顺序表了。所以不行，必须挪！\n综上所述，顺序表的特点就是：便于查找元素，不便于插入和删除元素！\n那么，有没有啥法子能插入和删除时候不挪呢？这样就可以专门用来针对低素质群体了。\n有，链表！\n2. 链表 链表是非直接相邻的顺序表。便于插入删除，不便于查找。\n链表跟顺序表是一对“杠精”，只要记住顺序表的特点，反过来就是链表的特点。顺序表的元素是一个挨一个的，链表就是不挨的。\n有人可能会问了：这不对啊，不挨着怎么找到前一个或者后一个元素，要是找不到，就不是线性表了。\n可以找到，就是要费点劲。\n比如：我在北京，我爸爸在上海，不相邻，我能找到他吗？能啊，我直接根据地址开车过去就行了，虽然费劲，但是也能找到啊，并且这个地址也只能找到他啊。这也满足：一对一的关系。\n这找得也太费劲了，确实费劲。有人要找我，但他只有我爷爷的地址，就先找到了我爷爷，问他要了我爸的地址，然后找到了我爸要了我的地址，最后根据地址找到了我。\n从这里可以看到，链表的查找步骤不是直接报个序号就行的，而是需要从头开始挨个往下找，所以查找费劲，也就不便于查找。\n那么，为什么要这么设计呢？因为这样便于插入和删除。比如有一天，我爸去了国外，那么他只要把我的地址给我爷爷就行了，我和我爷爷都不需要搬家，这样找我的人，还是按照之前的步骤就行；如果有一天我爸回来了，那么他把他自己的地址给我爷爷，然后我把我自己的地址给他，就行了，仍然不需要搬家。如果是顺序表就惨了，估计搬家都搬吐血了。\n从这里我们可以看到，链表的设计是不需要相邻的，它通过上一个元素持有下一个元素的地址来找到下一个元素，插入/删除时只需要改变地址即可，不需要挪动位置。这样非常便于插入和删除，但是不便于查找。\n这样通过地址连起来，就像一条“链”一样，如下图所示：\n如果我们删除了 $$\na*{i} $$，我们只需要将 $$ a*{i-1} $$ 指向的地址改成 $$ a_{i+1}\n$$ 即可。插入元素同理。\n所以，链表的特点是：便于插入删除， 不便于查找。\n3. 栈 栈是先进后出（FILO）的线性结构。\n栈是一种抽象的数据结构，它只要求元素满足先进后出，不要求你是怎么存放的。\n比如只有一个门的公交车，第一个进去的最后才能出来；比如冰柜里的雪糕，第一个放进去的最后才被取出来；再比如碗里的饺子，第一个放进去的最后才被吃掉。\n这些都有一个特点：只有一个口！因为只有一个口，所以导致最先进去的最后才出来，所以就叫先进后出，或者叫作 FILO（First In Last Out）。\n那么，这有啥用呢？难不成就是专门用来模拟吃饺子的？非也！\n因为栈是先进后出的，所以特别适合用来模拟历史的回溯，也就是说，逆流而上追溯历史，将历史“倒放”一遍。\n历史的回放？这是啥？比如我们打开浏览器，打开一个个页面，我们关闭的一定是最后打开的，换句话说：最先打开的反而最后关闭。也就是说，如果我们打开的顺序是：A-\u0026gt;B-\u0026gt;C-\u0026gt;D，那么我们关闭的顺序就是 D-\u0026gt;C-\u0026gt;B-\u0026gt;A。\n这给我们的感觉就是：将历史记录倒放了一遍。这正是栈的特点。\n历史明明是“前天-\u0026gt;昨天-\u0026gt;今天”这样过来的，但是我们回到过去的话，却是“今天-\u0026gt;昨天-\u0026gt;前天”这样经过的，这就是对历史的回溯。\n栈最常用的地方就是计算机的函数调用，不管何种语言，最先被调用的一定最后返回，比如：\n1 2 3 4 5 6 7 functionA() { functionB(); } functionB() { functionC(); } 调用顺序是: functionA() -\u0026gt; functionB()-\u0026gt; functionC()。 返回顺序是: functiuonC() -\u0026gt; functioB()-\u0026gt; functionA()。 functionC()最后被调用，却最先被执行完，然后把结果返回给functionB()，functionB()再执行完毕返回，把结果返回给functionA()。\n这就是栈最常用的地方，所以我们经常说函数栈，也就是这个道理。\n其实我们可以广义地概括一下栈的使用场景：具有对称性。凡是具有对称性要求的场景，都优先考虑使用栈。\n比如上面的页面返回例子，A-\u0026gt;B-\u0026gt;C-\u0026gt;D 和 D-\u0026gt;C-\u0026gt;B-A，这是以 D 为对称轴左右对称的。上面的函数调用，也是以functionC()为对称轴左右对称的。\n换句话说：FILO 就是以最后进来（最先出去）的那个为对称轴左右对称的，凡是有这种要求的，都以优先考虑栈。\n4. 队列 队列是先进先出（FIFO）的线性结构。\n队列是一种抽象的数据结构，它要求元素满足先进先出，不要求元素怎么存放。\n比如两个门的公交车，前面进、后面出，那么先进入的人就会先出来；再比如汽车排队隧道，先进入的先出来。\n它们也都有一个特点：两个口！因为两个口，一个进一个出，那么先进去的肯定先跑到出口，所以就叫先进先出，或者叫作 FIFO（First In First Out）。\n可以看到，队列跟栈相反，更适合人们的思维，因为它是公平的！\n它可以用于模拟日常的大部分操作，比如下载，先点击的就先下载，只有前面的下载完了才轮到后面的；再比如，12306 买票的候补，先点击候补的优先出票。\n因为队列是先进先出的，所以就特别适合对历史的回放。也就是说，按照历史顺序，将历史“重新演绎一遍”。\n比如：我们开发一个直播间，先进直播间的人肯定排在前面。这时候就可以使用队列。\n因为队列是先进先出的，也是符合人们正常思维的，所以，凡是不需要使用栈的地方，都可以使用队列。\n非线性数据结构 数据元素之间的关系是一对多，或者多对多的。\n非线性数据结构的关系可能是一对多，或者是多对多。一对多的我们称为树；多对多的我们称为图。\n1. 树 树是一对多的数据结构。适合有层级关系的场景。\n我们知道，树只有一个根，但是却有多个分支，每个分支又有多个分支。这特别适合用来模拟分层的场景，比如组织结构图、大纲图，还有脑图。\n最常见的场景就是分页了。\n比如：从一亿个人中，找到一个名字叫张三的人（假设名字都不重复），怎么找呢？一个一个去对比名字是否叫张三吗？这太费劲了。\n我们可以这样做：\n先按照名字个数分组，两个字名字的分到 A 组，三个字名字的分到 B 组，四个字名字的分到 C 组。 针对每一组，再按照姓氏分，姓王的分到王组，姓张的分到张组。 然后针对每个姓氏组，再按照名字的笔画分组，“三”有 3 笔，就被分到 3 组。 这样，我们就好找了。张三，两个字，去 A 组；姓张，去张组；名字是 3 笔，去 3 组。也就是，A 组的张组的 3 组。这里只有几千个人了，很好找了。\n这里的整个一亿人就是一棵树，A 组、B 组、C 组分别是主枝干，王组、张组是次一级枝干，1 组、2 组、3 组又是次一级枝干，每个人都是一片叶子。\n可以看到，有明显的层次关系，这样划分得更清晰，也更好找。\n再比如，书的目录、部门的组织关系，等等，都很适合用树来表示。\n到这里，我们总结下树的特点：一对多，有层级关系，适合分页。\n2. 图 图是多对多的数据结构。适合没有层级的网状关系。\n既然树适合有层级的场景，那么没有层级的呢，就可以用图了。\n比如：手机联系人，我有我家人的、我朋友的，家人又有家人的，家人又有他们的朋友的……如此，就形成了一张大网，这张网里的所有人都是平等关系，又都是多对多的，这就适合用图来表示了。\n假如我们要做一个城市的地图，或者要做一个朋友圈关系网，我们就可以采用图。\n有人说，图是平级关系，那么我们的城市地图有拥挤程度，朋友圈也有重要朋友和不重要朋友，怎么表示呢？这个就可以使用加权图了，这是更详细的划分了，本章我们不做过多介绍。\n这里说的“层级”，不是关系的重要程度，而是是否存在着主次关系，如果有了主次关系，那就不适合使用图了。\n图的使用除了日常的模型模拟之外，还有路径规划、拓扑排序等很多场景，我们后面会细讲。\n总结 本章从整体讲解了数据结构的划分，以及它们的特点和使用场景，有点流水账的味道。我们再来梳理和回顾一下。\n线性数据结构：元素之间是一对一的关系。 非线性数据结构：元素之间是一对多或多对多的关系。 顺序表：紧密相邻的线性数据结构，便于查找，不便于插入删除。 链表：不相邻的线性数据结构，便于插入删除，不便于查找。 栈：先入后出的线性数据结构，适合对历史的回溯。 队列：先入先出的线性数据结构，适合对历史的回放(重新演绎)。 树：一对多的非线性数据结构，适合有层级关系的场景。 图：多对多的非线性数据结构，适合无层级关系的场景。 我们这部分讲的内容都是抽象的，并不涉及具体的实现，因为我们只有先从顶层了解了它们的概念和特点后，再带着这些已有理解去看具体实现会有更深刻的印象，记得也更牢。后面我们就从具体的实现来看一下每一种数据结构的具体使用场景以及在代码中的精彩表现。\n11.数据结构进阶:实现原理和设计思路 在上一章，我们居高临下地俯瞰了数据结构的基本特性，不过都是一些概念性的东西，我们并没有涉及到具体的编码，那么，这一章我们就从根儿上来拆解下数据结构的设计原理。\n在上一章中，我们讲到：线性数据结构之间的元素是一对一的。并且我们知道它分为顺序表和链表，而顺序表要求元素之间要互相挨着，这好像是第 4 章中我们讲过的数组啊，数组不正是这个特性吗？\n那岂不是直接拿着数组就能当顺序表用吗？\n嗯，差不多了，那顺序表肯定就是用数组实现的，我们就来设计下。\n顺序表 数组是具体的数据类型，顺序表只是个抽象的概念，那我们就用数组这个具体的类型来实现顺序表这个抽象概念。\n我们知道，对于数组来说，访问、修改元素，都是通过下标实现的，比如：\n1 2 3 4 5 int[] arr; // 访问 int a = arr[i]; // 修改 arr[i] = 10; 这极其不方便，寡人不关心你的下标是多少，我只想往里放，从里取，然后传个下标就给我返回对应的元素，这样行吗？\n可以！那么，怎么实现呢？\n很简单，我们就用数组，然后根据下标index去操作元素，存放元素的时候就让index+1，取元素的时候就让index-1，访问指定下标元素的时候，直接返回index对应的元素就行。\n上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 名字就先这么委屈地叫着吧 class XianxingBiao { // 初始化一个大小为10的数组 private int[] arr = new int[10](); // 当前元素的下标，默认是没有的，所以就是-1 privage int curIndex = -1; // 存放元素 public void put(int num) { // 下标+1，然后再存放元素 arr[++curIndex] = a; } // 获取元素，可能会下标越界，直接返回，效率好高 public int get(int index) { return arr[index]; } // 在指定位置插入元素，效率好低啊 public int add(int num, int index) { // 我们前面讲过了，需要将index以及后面的元素全部往后挪一步 // 第一步，先把index以及后面的元素挪一步，我们要从后往前开始，因为前面的移动会覆盖后面的 for(int i = arr.length-1; i \u0026gt; index; i--) { arr[i] = arr[i-1]; } // 第二步，上面已经把arr[index]空出来了，那就直接放新值就行 arr[index] = num; } // 删除指定位置的元素，效率好低啊 public void remove(int index){ // 我们前面讲过了，需要将index后面的元素全部往前挪一步 // 这里的需要从index开始，因为后面的移动会覆盖前面的 for(int i = index; i \u0026lt;= arr.length-2;i++) { arr[i] = arr[i+1]; } } } 有人说，添加元素是两步，删除元素为啥是一步呢？不应该先把那个位置空出来，然后再把后面元素往前挪移吗？\n不用！你直接挪移元素，后面的就会把index位置的覆盖了，那不就等于删除了吗？何必多此一举呢。\n还有问题啊，上面的数组，创建的时候大小是 10，添加元素或者插入元素的时候，如果放不下，怎么办呢？\n扩容！我们在第 5 章也讲过，要尽量选择易变的数据结构，那么我们设计的也肯定要这样。第 4 章我们也说了，数组的扩容很费劲，究竟有多费劲呢？就是只能新建一个大的，把老的挨个复制进去，这性能确实酸爽。\n我们来看扩容的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class XianxingBiao { // 初始化一个大小为10的数组 private int[] arr = new int[10](); // 当前元素的下标，默认是没有的，所以就是-1 privage int curIndex = -1; // 扩容 private void resize() { // 还记得左移吗，就是乘以2，也就是新的数组大小是老的2倍，就是20 int newSize = arr.length \u0026lt;\u0026lt; 1; int[] newArray = new int[newSize]; // 把老数组元素挨个拷贝到新数组中 for(int i = 0; i \u0026lt; arr.length; i++) { newArray[i] = arr[i]; } // 还记得吗？数组是个对象，对象是个引用，改变引用的值就是改变指向的对象 arr = newArray(); } } 上述我们创建一个新数组，将老数组元素按顺序拷贝过去，然后将新数组赋值给老数组，这样，老数组就完成了扩容，简单粗暴。\n那么，我们在 put()和add()之前，就要先检查下是否能存放下，如果存放不下，那么就先扩容。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class XianxingBiao { // 存放元素 public void put(int num) { // 如果当前元素已经到头了，就是没位置了，就要扩容 if(curIndex == arr.length-1) { resize(); } ...其他代码 } // 在指定位置插入元素 public int add(int num, int index) { // 如果当前元素已经到头了，就是没位置了，就要扩容 if(curIndex == arr.length-1) { resize(); } ...其他代码 } } 好，这样我们就解决了“我们的顺序表不是易变的数据结构”这个问题。\n这实现是实现了，不过这拷贝一份儿，这效率也太低了。嗯，你可以将数组的初始容量变大一些，但是这样就可能浪费空间；所以，你要考虑你的需求场景，如果是数据量很大的，就不妨将数组初始容量改大一些，避免频繁扩容带来的开销；如果数据量不大，那么就小一些，达到节省内存的效果。如果你真的是插入/删除得频繁，那就可以考虑下下面的链式表。\n行，不过这名字也太难听了，这汉语拼音英语吗，受不了。\n那就改名字。\n我们是使用数组实现的顺序表，数组就是 Array，表就是 List，那就取爹的姓妈的名，就叫 ArrayList 吧。这正是 Java 中的顺序表的名字。\n好，名字也改了，我们就来看看链式表吧。\n链表 其实我们在第 5 章末尾就自定义过一个链表，只不过有点糙，这里我们就加以完善下。\n我们需要提供跟上述ArrayList一样的 API 来供程序员使用，公平起见，我们就起名为LinkedList。我们直接上代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 arduino复制代码// 定义元素Node class Node { // 存放数值 int value; // 存放下一个元素的值 Node next; // 构造函数 Node(int value, Node next) { this.value = value; this.next = next; } Node(int value) { this.value = value; } } java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class LinkedList { // 第一个元素 private Node first; // 添加元素 public void put(int num) { // 创建新节点，新节点是在后面的，所以next就是null Node node = new Node(num, null); // 如果链表为空，这就是第一个节点，否则就加到链表后边 if(first == null) { first = node; } else { first.next = node; } } // 访问第index个元素，效率好低啊 public int get(int index) { // 只能硬着头皮从前往后数index个元素 int i = index; Node curNode = first; while(i \u0026gt; 0) { // 这里可能有空指针，我们暂不考虑 curNode = curNode.next; i--; } return curNode.value; } // 插入元素，效率好高啊 public void add(int num, int index) { // 第一步，找到要插入的节点位置 Node node = first; // 这里要先做减法，比如要插在3号位，就要找到2号位置即可。 while(--index \u0026gt; 0) node = node.next; // 第二步，插入元素，现在假设我们找到了2号位置 Node newNode = new Node(num); newNode.next = node.next; node.next = newNode; } // 删除元素，效率好高啊 public void remove(int num, int index) { // 第一步，找到要删除的点 Node node = first; // 这里要先做减法，比如要插在3号位，就要找到2号位置即可。 while(--index \u0026gt; 0) node = node.next; // 第二步，删除元素，直接让前面的next指向要删除的next就行 node.next = node.next.next; } } 猛一看可能有点懵，我们来具体分析，假如链表如下（不懵的可以跳过哈）：\nA -\u0026gt; B -\u0026gt; D -\u0026gt; E\n我们要在 D 位置插入 C，也就是要变成：A -\u0026gt; B -\u0026gt; C -\u0026gt; D -\u0026gt; E。\n那我们首先就找到 B，然后创建出 C 节点。然后就让： C.next = D；但是我们没法直接拿到 D，我们就通过 B 来拿到 D，也就是：C.next = B.next，此时，C 的 next 就是 D 了。这一步之后，我们的链表就变成了：\n没错，那接下来，就需要让 B 指向 C 就行了，也就是： B.next = C。修改过后，我们的链表就变成了：\n可以看到，C 已经正确地插入了链表中。\n我们的执行步骤是：\n1 2 C.next = B.next; B.next = C; 其中，B 就是add()方法中的 node，C 就是add()方法中的 newNode。\n有人说，我先让 B 指向 C，再让 C 指向 D 不行吗，也就是：\n1 2 B.next = C; C.next = B.next; 不行，因为你一旦执行B.next = C；那么B.next就变了，后面的C.next = B.next就等于C.next = C了，明显不对。\n我们可以概括一点：你先把执行的步骤写下来，然后看有哪些是最后用到的，然后就将最后用到的放在后面即可。比如上面的B.next是最后用到的，就把用到它的语句放在最后。\n至于链表的删除，就简单了，直接让 B 指向 C 即可，因为 B 指向 C 的操作隐含了断开 B 和 D 的连接。\n有人说，你这效率高个毛啊，插入和删除还要遍历着找吗？这也好意思说效率高？\n大哥喝冰阔罗消消火，你看我们的效率是相对而言的不是。你看隔壁ArrayList，它是没遍历，但是它要让后面所有人都挪挪位置，你说是报个数快呢，还是挨个挪一步快呢？\n栈和队列 其实栈和队列的设计很相似，如果出入都是同一头，那么就是栈，比如吃了 yue 出来；如果是一头入一头出，那就是队列，比如吃了拉出来。\n那这个实现起来就丰富了，我们可以用一个数组，每次添加元素都放在后面，每次删除元素也删除后面，这样就是栈。\n我们每次push()（存放元素）的时候，就让curIndex+1，也就是往右移，每次pop()（删除元素）的时候，就让curIndex-1，也就是往左移，这样就等于封死了左边的口，也就达到了先入后出的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 int[] arr = new int[10](); int curIndex = -1; // 入栈，加在后面 fun push(int num) { arr[++curIndex] = num; } // 出栈，返回后面元素 fun pop() { return arr[curIndex--]; } 猛一看，没问题，仔细一看，有很多问题。比如：栈空了怎么办？栈满了怎么办？\n这个其实很简单，我们使用下标即可判断，如果curIndex == arr.length，那么就表示栈满了；如果curIndex \u0026lt; 0，那就表示栈空了。如果栈满了，我们就需要扩容，扩容的方式跟ArrayList中的方式一模一样；如果栈空了，我们就要抛出异常或者返回空，以此来告诉调用者。\n如果我们每次添加元素都放在后面，每次删除元素都删除前面，那么就是队列。\n如果，我们每次让元素入队之后，都让pushIndex+1，也就是右移，这样就指向下一个要入队的位置；每次让元素出队之后，都让popIndex+1，这样就指向下一个要出队的元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int[] arr; // 记录入队伍位置 int pushIndex; // 记录出队位置 int popIndex; // 入队 fun inQueue(int num) { arr[pushIndex++] = num; } // 出队 fun outQueue(int num) { return arr[popIndex++]; } 这个代码也有问题：这样出出入入来几次，马上就到头了，这样数组前面的元素空间不就浪费了吗？\n这可咋整，我们可以这样？每次操作之后，就将所有元素都挪到左边，这样就可以让右边空出来了。\n这也太费劲了，劳资不干！而且这种基操大大降低我代码的段位。有没有什么高级点的方法呢？\n有！环形数组！\n假如，我是说假如，我们把数组头尾相连，也就是 0 和 10 连起来，这样形成一个环，是不是永远都不会到头啊。这样就爽多了。\n但是这是不可能的啊，内存条，内存条，都说是条了，怎么会有环呢？嗯，我们物理上实现不了，我们就在逻辑上实现，我们怎么做呢？\n我们每次计算的时候，不用pushIndex和popIndex了，我们用它们的模，也就是使用pushIndex % arrayLength和popIndex % arrayLength，其中arrayLength是数组的长度。那就变成了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 假设数组长度是10 int length = 10; int[] arr = new int[length](); // 记录入队伍位置 int pushIndex; // 记录出队位置 int popIndex; // 入队 fun inQueue(int num) { arr[pushIndex%length] = num; pushIndex++; } // 出队 fun outQueue(int num) { return arr[popIndex%length]; popIndex++; } 我们假设数组长度为 10，来验证下。如上图，我们存放到下标 9 的时候，pushIndex++就变成了 10，对 10 求余就变成了 0，也就是回到了下标为 0 的地方开始存放数据，这是对的。同样，popIndex也是对的。\n那么又有问题了，这样怎么判断队列已满，又怎么判断队列为空呢？\n很简单，我们看图，当pushIndex不断地存放数据，直到下标 1，也就是popIndex的前面，那么队列就放满了，此时： pushIndex+1==popIndex。\n同理，如果popIndex不断取数据，直到下标为 6，也就是指向pushIndex，那么此时队列就空了，此时：pushIndex==popIndex。\n由于我们的数组是环形的，我们的数字需要对长度求余，也就是：\n队列满：(pushIndex+1)%length == popIndex%10。 队列空：pushIndex%length == popIndex%10。 当然，你也可以定义一个 count 值，来记录元素的个数，每次入队就加 1，每次出队就减 1，当count==length就是满了，当count==0就是空了。\n我们也可以使用链表来实现栈和队列，这里就不再废话，原理其实就是一个：栈就是对一端进行左右挪移，存放就往外挪，删除就往内挪；队列就是对两头进行挪移，出入都往存放那一头挪。\n大家可以对照示例图仔细体会下这句话。\n总结 本章我们讲了常见数据结构的实现原理，我们没有讲任何 API，就单纯从它们的特点来设计这些数据结构，我们不必拘泥于它们的源码是怎么写的，只要明白其中的道理，写出工程性源码不过是时间问题。我们再来回顾下。\n对于顺序表，因为是顺序的，我们就可以用数组来模拟实现，这样就可以通过下标快速定位元素。 对于链表，因为是分散的，我们就可以用一个一个的节点来实现，然后通过持有下一个节点的引用把它串联起来。 对于栈和队列，实现方案有多种，我们只要理解挪移的方向即可。单端存外删内，双端都向存。 那么下一章，我们就来了解下在开发中如何选择合适的数据结构，以及怎么由一级数据结构构造二级数据结构。\n12.数据结构实践:选择合适的数据结构 上一章，我们讲了常见数据结构的设计思路，那么本章，我们就来看下要怎么使用这些数据结构，以及面对不同场景要如何选择合适的数据结构。\n一级数据结构案例 所谓一级数据结构，就是我们上一章讲到的几种能直接拿来实现现有需求的数据结构。\n那么，我们到底要翻谁的牌子呢？看例子：\n假如现在我要做一个直播间的用户列表，我要选择哪种数据结构来存储呢？\n我们先来分析一下直播间的用户场景：\n直播间用户是个列表，点击就展示出来； 直播间用户可能频繁地进出； 点击列表中的一个用户，要显示出它的个人信息； 点击列表中的一个用户，要能踢出他。 其中，第一条等于废话，我们讲到的所有数据结构都是集合，都能展示出一个列表。\n第二条：意味着数据的添加删除可能很频繁，嗯，如果是在末尾添加/删除数据，那么顺序表和链表的效率都是一样的。如果是在中间插入/删除元素，那么链表的效率就高一些。所以链表加一分。\n第三条：意味着随机访问元素，这个明显是顺序表占优，顺序表加一分。\n第四条：点击踢出用户，首先要找到用户，然后踢出，这就等于“随机访问+删除元素”，也就是等于第二条和第三条的复合操作。\n那这就麻烦了，各有各的优势，我们要如何选择呢？\n嗯，明面上是 55 开，其实有很大的考量度，我们来分析下上述操作的权重问题，也就是哪些操作可能会比较多，哪些比较少。\n我们知道，对于一个直播间，踢出这个操作是用得最少的，毕竟是隐藏的金主，能忍就忍。其次就是查看个人信息，因为既然是直播间，我们的关注点大多都在主播身上，进直播间不看主播看别人的信息，这就是对主播的侮辱。最后就是用户的进入和退出，因为大多数场景下，每个人进入直播间都是被封面吸引的，进去之后看到实际跟预期并不符合，就会大失所望，就直接跑了，这是个很频繁的操作。而且，大多数直播间的用户列表都是有排序的，比如：金主排前面，非金主但充值的次之，排最后的才是我们这些三无人员。这就导致每次进入/退出的人不是直接从列表的最后面操作的，而可能插入到列表中间或者前面，或者从列表中间删除，这明显就是链表占优了。\n综上，对于很频繁地进入/退出操作，链表是占优势，所以我们应该选择链表来存储。\n当然你也可以根据你们的数据统计来给每个操作进行加权，比如：在 1 小时内，进入/退出发生了 80 次，点击个人信息发生了 20 次，那么就是进入退出占 0.8 分，点击个人信息占 0.2 分，而进入/退出是链表占优，所以就选链表。\n再比如，直播间的消息列表，我们很少对消息列表进行插入/删除，而往往是消息来了就加到最后一条，并且我们需要很频繁地点击消息去查看发送这条消息的人的信息，那这明显就是顺序表占优了。\n直播间还有啥列表呢？还有礼物。\n对于直播间来说，礼物是最重要的，也是肾上腺素飙升的主要来源。现在，假如直播间有 1w 个人在 5s 内都刷了一个礼物，那么，这 1w 个礼物会同时播放吗？\n不会！\n为啥呢？因为我们的手机都有内存限制啊，你这 1w 个礼物呢？假如一个礼物要 1 兆内存，1w 个礼物就是 10G 内存啊，这能同时播放吗？估计卡得你又要骂安卓垃圾、iOS 垃圾了。\n那怎么办呢？排队播放！\n一次我播不了 1w 个，那一次我播 100 个总是可以的，100 个也就是 100M 内存，还行。这样我就每次播 100 个，播放 100 次，就可以了。\n每次播放 100 个，就按照播放两秒算，总共也就 200 秒，也就是 3 分钟左右，还可以接受。这也就是为什么很多直播间礼物不断的原因了。\n好，既然说到了排队，那就明显是用我们上一章设计到的队列了。我们按照收到礼物的先后顺序进入队列，监测到当前播放个数是否大于 100，如果不大于，那么就让它播放，否则就添加到等待队列里面去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 等待队列 Queue waitingQueue; // 播放队列 Queue playingQueue; // 播放礼物 fun playGift(Gift gift) { // 如果播放队列没有满，那么就直接播放 if(playingQueue.size \u0026lt; 100) { playingQueue.inQueue(gift); playGiftAnim(gift); }else { // 如果播放队列满了，就加入到等待队列中 waitingQueue.inQueue(gift); } } // 播放礼物动画 fun playGiftAnim(Gift gift) { // .... 播放礼物动画 gift.play() // 播放完毕就移出播放队列 playingQueue.outQueue(gift); // 检测并播放下一个 playGift(waitingQueue.outQueue()); } 上述代码仅供参考，但我们可以依此知道使用队列进行排队的方法，这个说白了就是当轮不到的时候，就先用一个集合把暂时轮不到的存放进去，前提是要按照先后的顺序存放，所以我们就选择使用队列。\n有人说了，我要插队怎么办？你看银行还有 vip、svip，vip 中 p 呢。这就可以用到优先级队列了，这里限于篇幅问题，就暂时不做讲解了，我们就在后面的项目实战章节来看一下它是怎么使用的。\n我们先来看一个我们用得很频繁的数据结构：哈希表，或者叫字典。\n二级数据结构 二级数据结构是用一级数据结构组合而成的，最常见的就是哈希表。\n什么是哈希表呢？它就是个数组。只不过这个数组的元素又是链表。所以我们可以称它为：链表数组。当然，在有的语言中，它也会用二叉树来实现。它大概就是这样的：\n那它可以用来干啥呢？可以存放键值对，图中的每一个元素，都不是一个数值，而是一个个的键值对，也就是我们高中学过的映射，你可以理解为：f(x)=x，而图中存放的就是这个关系。\n关系？这玩意儿怎么存放呢？我们可以定义一个对象来存放：\n1 2 3 4 5 6 // 定义键值对，也就是图中的链表的元素 class Node { int key; // 这就等价于x int value; // 这就等价于f(x) Node next; } 那么，怎么用呢？用在哪些场景呢？我们考虑下：如果要保存你的名字、年龄、性别，你要怎么保存呢？\n用列表啊，直接按顺序放进去就行了。比如：\n1 2 3 list.put(\u0026#34;张三\u0026#34;); list.put(\u0026#34;20\u0026#34;); list.put(\u0026#34;男\u0026#34;); 这样当然可以，不过可读性太差，我还要记住下标，而且，如果有一天，你把 1 号位置删除了，那去 1 号位置拿年龄，就拿到了性别，这肯定不行。\n其实这个例子中 x 就是下标，f(x) 就是下标对应的元素，但是 x 太不稳定了，所以我们需要个稳定的 x 值，来维持这个稳定的关系，我们就设计如下 API：\n1 2 3 4 5 fun put(String key, String value) { } fun getValue(String key) { } 当你 put 的时候，就等于存放一个关系，也就是键值对，比如：\n1 2 3 put(\u0026#34;name\u0026#34;,\u0026#34;张三\u0026#34;); // 等价于f(name) = \u0026#34;张三\u0026#34; put(\u0026#34;age\u0026#34;,\u0026#34;20\u0026#34;); // 等价于f(age) = \u0026#34;20\u0026#34; put(\u0026#34;sex\u0026#34;,\u0026#34;男\u0026#34;;) // 等价于f(sex) = \u0026#34;男\u0026#34; 获取的时候呢就这样：\n1 String name = get(\u0026#34;name\u0026#34;); // 等价于 String name = f(name); 这样是不是更人性化了？完全就是在调用函数，put的时候保存函数变量和函数值，get的时候根据函数变量获取函数值。\n这就是在做数学题。\n所以，当我们遇到存取关系型数据时候，哈希表就是不二之选。\n比如，上述的直播间用户列表，我们最后是用链表存放的，访问速度很慢，那么用哈希表，就能解决这个问题。\n我们可以将用户的 id 作为哈希表的 key，也就是函数中的变量 x；将用户数据作为哈希表的 value，也就是函数中的 f(x)；这样，我们点击某个用户的时候，只要用 id 去get，就能立刻获取到用户的数据，这是不是快多了呢？并且，我们的插入/删除速度也很快。\n那么，它为什么这么快呢？\n因为它虽然是个数组，但是插入/删除元素的时候，数组并不进行位置移动。我们来看下元素的存放过程，假如我们要存放键值对：name=zhangsan。\n先计算 name 的哈希码（hashcode），结果是一个 int 值，这是个很快的操作。 用 name 的哈希码对数组的长度求余，得到 a 应该存放的位置，这里假设位置是 0。 如果这个位置没有其他元素，那么就直接放在这。如果有其他元素进行第 4 步。 这里我们就得到了 0 号位的链表。我们从前往后逐个对比它们的哈希码，如果都不同，则把 name 这个键值对插入到这个链表的头部。如果有相同的则进行第 5 步。 如果哈希码相同，就对比它们的 name 的值是否相同，如果不同则插入到链表头部，如果相同则用新的 value 替换掉老的 value。 有点懵，我们再来捋一下：先根据 name 计算 hashcode，然后用 hashcode 计算下标，然后找到下标对应的链表，没有则直接存放；有就继续对比 hashcode，都不同则插入到头部；有相同则继续对比 name 是否相等，如果不同则插入到链表头部，相同则直接替换掉原来的 value 值。\n有人说，你这也太绕了，你这先计算哈希值，再计算下标，最后又对比 name 是否相同，图啥呢？\n这其实就是伟大的分页功能。\n还记得找张三的例子吗？我们按照姓名首字母、名字笔画数等分了那么多组，就是为了找起来快一点。哈希表也是这个原理。\n不同的对象，它们的哈希码可能是相同的（这叫做哈希冲突），而不同的哈希码对数组长度求余得到的结果也可能是相同的。所以，我们就借此来给它们进行分组。\n把哈希码相同的分为一组，把对数组长度求余结果相同的分为一组，这样，我们的范围就逐渐缩小了。这不就是分页吗？\n哈希表也是基于这个原理设计的。\n在这个过程中，计算哈希码很快，计算下标也很快，就是最后对链表计算比较慢，但是，在常规情况下，链表一般都很短，所以这个速度也是很快的。\n总结 本章我们介绍了一些常见的数据集合的实践方法，以及哈希表的设计原理，我们再来回顾下。\n当用到非关系集合时，我们优先考虑线性数据结构，读多写少就用顺序表，读少写多就用链表，要排队就用队列，要做对称性操作就用栈。 当用到关系型集合时，我们优先考虑哈希表，哈希表存放的是一个个键值对，类似于数学中的函数。 对于哈希表，它本身就是一个数组，只不过数组的元素是链表，它用了分页的思想。 那么下一章，我们就来看下计算机本身是怎么设计的，它里面又是怎么灵活使用各种设计思想的。\n13.系统的基元:进程和线程 在前面第 6 章我们提到过计算机的组成元件，那都是些冷冰冰的硬件而已，就像人体的躯干一样，而软件才是计算机的灵魂。\n我们把软件分为系统软件和应用软件，操作系统就是系统软件的一种，只不过它是最基础的软件，其他所有软件都要运行在操作系统上。\n那软件是什么呢？简言之，软件就是程序的载体。我们写的hello world等代码，打包出来就是软件，就能安装在各种设备上，然后运行在操作系统上。\n那操作系统又是啥呢？凭什么让它管理我写的软件呢？我们就来了解下。\n进程和线程的概念 操作系统是啥？是软件，只不过它是专门管理软件的软件。\n操作系统有两个作用：\n负责跟系统硬件打交道，把用户的各种操作（比如鼠标点击、键盘输入等）翻译给计算机硬件，然后将结果告诉用户； 管理其他软件。 那操作系统是怎么管理软件呢？通过管理进程！\n我们知道，软件是程序的载体，而每一个程序都是一个进程。\n每一个程序都有一个进程。\n我们可以把一个软件理解为一个家庭，那么这个家庭就是一个进程。\n那么，我们家就是一个进程，在这个进程中，有三口人：我、我爸、我妈。\n那照这个意思来说，村长就是操作系统了？\n虽然不太合适，不过也可以这么理解。如果这样的话，那是不是意味着村长每次下命令，都只能指挥一个家庭？因为一个家庭是一个进程，村长又是管理家庭的。\n这听着不太对啊，难道村长不能让我单独去做一件事吗？必须让我们整个家庭一起去做一件事吗？一家人一起去做一件事，是不是有点浪费资源？\n确实浪费资源，实际上，村长是可以指挥单独一个人去做一件事的，那么这个人就叫做一个线程。\n那么，村长能单独调动的最小单位就不是一个家庭了，而是一个人。也就是说：线程是操作系统能调度的最小单元。\n到这里，我们就知道了：每个程序都有一个进程，线程是进程的一部分，线程是操作系统能调度的最小单元。\n那么，为啥要这么干呢？这么做村长不累吗？\n线程的优点 使用线程可以提高程序的运行速度，节省时间和成本。\n首先，村长肯定累，虽然比不过生产队的驴，不过也差不多了。\n但是，人家操作系统是计算机，是拥有光速的男人，你就不要操心人家了。\n举个例子，假如没有线程，村长让我家去挨家挨户发个开放三胎的通知，我们会怎么办呢？\n嗯，三个人一起挨家挨户地去烦他们，全村 1000 户，每家 2 分钟，一共 2000 分钟，大概 33.333 小时（其中 3 无限循环），这不吃不喝一天都干不完。\n那有人就纳闷了，你这就发个通知，也就嘴炮两句的事，用得着拖家带口一起上阵吗？如果你有爷爷奶奶是不是准备 5 个一起上？5 个人一起去通知一个只有两口人的家庭？发通知的比接通知的人都多，何苦呢？\n所以我们就要上线程啊。\n上了线程后，我们每个人都是一个线程，就可以三个人一起上，这样时间直接变为原来的 1/3，一天就搞定了，从而节省了时间。\n而且原来 33 小时搞定的事情，现在 11 小时搞定，等价于白白增加了 22 小时的寿命，等价于节省了成本。\n所以，引入线程，就等价于变串行为并行，能提高速度，节省时间。\n串行：一件事同一时刻只有一个人做。 并行：一件事同一时刻有多个人做。 有人说，这样的话，岂不是线程越多越好吗？越多就等于同时有更多的人去做，这样肯定更快啊。\n大谬！\n还是刚刚的例子，全村 1000 家，你能用 1001 个人去通知吗？显然不能。最重要的是：计算机无法让那么多线程同时工作。\n这是啥意思呢？\n比如说，一个 16 核的 CPU，最多只能让 16 个线程同时工作。即使开了 100 个线程，同一个时刻也是只有 16 个线程同时工作。\n有人说，不对啊，我开了 100 个线程打印数字，发现它们都同时打印了。\n那只是你以为而已。其实这里面是有个调度算法的，计算机通过一定的调度算法，让你这 100 个线程看起来像是每个都在执行，这个我们在后面第 15 章会细讲。\n再举个例子，大家都用迅雷下载过电影，其实每个下载流都是一个线程，是不是越多越好呢？\n不是！\n因为网速就 100k/s，你开一个线程下载，就是 100k/s，你开两个线程下载，那么网速就均分，就变成每个 50k /s，这有啥意义呢？原来 100k/s 的还能先下载个看着，然后等另一部下载呢。\n但是，如果你是在计算数学题，比如 100 道题目，你就可以开启 10 个线程，每个线程计算 10 道题目，然后把结果合并即可。\n其实，说白了：如果你的程序存在着资源竞争，开启多线程是无益的；如果你的程序不存在资源竞争，开启多线程是有益的。\n比如上面的下载，都在争着用网络，你即使开启 250 个线程，也 no egg use。你多开线程能增加网速吗？而上面的数学题，彼此都是独立的，就可以多开几个线程来同时完成。但是如果上面 100 道题目的下一题需要依赖上一题的结果，那就别开多线程了，没用！\n上述说到的资源竞争，就是多线程的缺点，那这个咋避免呢？\n多线程的问题 资源冲突：多个线程在同一时刻操作同一个资源。\n还是上面的例子，假如三个人都同时通知到同一家，这个算不算资源冲突呢？\n不算，因为这个只是访问资源，不是操作资源，操作资源指的是对资源进行了修改。比如：\n1 2 3 4 5 6 ini复制代码// 定义资源i int i = 10; // 访问资源，没有修改i println(i); // 操作资源，对i进行了修改 i = 1; 发生冲突的资源，就叫临界资源。比如，如果发生了冲突，上述的i就是临界资源。\n上述我们说了，线程是进程的一部分，是操作系统调度的最小单位。是调度的最小单位，不是持有资源的最小单位。也就是说，资源都是在进程中的，进程是持有资源的最小单位。\n还是我家，我们每个人都可以自由行动，但是我家的粮仓却只能放在我家，不可能每个人都持有一个粮仓，粮仓就是资源，所以进程是持有资源的最小单位。线程可以使用资源，却不能持有资源。\n其实，我们第 6 章讲过，控制器控制程序流按顺序执行，程序流指的就是线程，每个线程内部都有一个缓存，用来存放自己需要的数据，当每个线程被执行的时候，CPU 就会把这个线程需要的数据读入缓存中，等到执行完毕，就再把缓存的数据写回到内存中。\n每一个进程都有一块内存，这个内存是所有线程共享的。每一个线程都有一个缓存，这个缓存是自己独占的。\n假如我们有个进程 P，进程 P 有个线程 A。那么，A 的执行逻辑就是这样的：\nCPU 将 A 需要的数据从进程 P 的内存读入线程 A 的缓存，比如读入了 i。 A 对自己缓存的数据执行一顿猛如虎的操作，比如 i++。 A 执行完毕，CPU 将 A 缓存的数据 i 写回到进程 P 的内存中。 这就是 A 的执行流程。嗯，懂了。\n不，你不懂！\n假如，在线程 A 执行的同时，进程 P 的另一个线程 B 也在执行，并且也用到了 P 内存中的 i，那么，等线程 B 执行完毕之后，i 是多少呢？是以线程 A 执行的为准，还是以线程 B 执行的为准呢？\n此时就发生了资源冲突，i就叫做临界资源。线程 A 和线程 B 对i进行修改的代码就叫临界区。\n有人说，你这不是没事找事吗？你直接把线程 A 和线程 B 的缓存砍了，都直接对进程 P 的内存中的 i 进行操作不就行了？\n这样它们修改的就是同一个i，就不临界了，直接就避免了问题。\n不行！第 6 章我们说过，从内存中读数据是一个耗时操作，很慢很慢，效率很低，所以我们才在线程中开启了一个高速缓存，执行时，先把数据读入高速缓存，等到执行完毕再把数据从高速缓存写回内存。\n你这个馊主意肯定是不行的。那有别的办法吗？有！\n其实我们的问题核心就是：有多个人同时操作了同一个东西。充分必要条件就是：同一时刻、同一个目标。\n那么解决方案就是：不同时，或者不同目标即可。\n怎么不同时呢？排队！变并行为串行。我们可以在i被读入线程 A 的内存中时，加个标记，其他线程来看到这个标记就等着，等到线程 A 执行完把i写回到内存中时，再把标记清除，并通知其他线程，其他线程再开始执行，这就是最基本的解决方法。\n那这也太挫了，合着你多线程半天了最后还是排队，有啥用？\n当然，我们有更高级的解决方案，就是分离目标，不过这是有使用条件的，我们下一节会仔细讲解。\n总结 本章我们从操作系统角度讲解了进程和线程，我们再来回顾下。\n进程是持有资源的最小单位，线程是系统调度的最小单位。 引入线程可以提高执行速度，节省时间。 多线程会引发资源冲突，我们解决资源冲突就是破坏“同一时间”和“同一目标”这两个条件。 下一节，我们就用具体的代码、具体的例子，来看下怎么解决多线程引起的资源冲突问题。\n14.贪心的后果: 并发及解决方案 在上一章中，我们提到资源冲突的充要条件是同一时刻、同一目标。资源冲突是并发引起的问题，要破坏资源冲突，就要干掉同一时刻、同一目标这两个条件之一即可。那么我们就来看看到底怎么破坏这对儿活宝。\n解决并发的基本操作 要解决并发引起的资源冲突，核心就是破坏同一时刻或同一目标。\n破坏同一时间 破坏同一时间的核心就是排队。\n假设我们有如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class A { int a = 0; // 开启一个线程不断增加a的值 Thread t1 = new Thread() { void run(){ for(int i =0; i\u0026lt; 1000_000_000; i++) a++; } }; t1.start(); // 开启另一个线程不断增加a的值 Thread t2 = new Thread() { void run() { for(int i =0; i\u0026lt; 1000_000_000; i++) a++; } }; t2.start(); } 简单，执行完之后 a 等于 2000_000_000。\n错！你可以试试，大概率不是 2000_000_000。\n这是为啥呢？因为这是两条执行流在同时跑，假设我们只执行了a++，那么流程如下：\n我们看到，两个线程几乎同时把 a 读如自己的缓存中，然后去执行加法，如下：\nThread1 把 a 读入自己的缓存中，此时 a=0。 Thread2 把 a 读如自己的缓存中，此时 a=0。 Thread1 执行 a++，此时 a=1。 Thread2 执行 a++，此时 a=1。 Thread1 把 a 写回主内存，此时 a=1。 Thread2 把 a 写回主内存，此时 a=1。 于是就会导致两个线程都执行了一轮a++之后，a 从 0 变成了 1，而不是 2。\n这怎么办呢？\n我们可以给 a 加锁，也就是说：在 a 被一个线程读取后，就加个锁，如果被写回来，就释放锁，其他线程过来了之后发现有锁，就等着，这就会导致同时只能有一个线程使用 a。\n就像酒店的宾馆，有人住的话就得到钥匙，并且锁门，这样别人就进不来了；离开再交还钥匙，这样下一个人就能住了。这就是排队。\n我们也给线程安排上这个逻辑，排队后的流程如下：\n我们看到，排队之后，线程是按照顺序来操作 a 了。\nThread1 把 a 读入自己的内存中，并获取锁，此时 a=0。 Thread2 去读 a，发现被锁了，就等着。 Thread1 对 a 进行自增，此时 a=1。 Thread1 用完 a 了，把它写回主内存，并释放锁，然后通知其他线程你们可以用了，此时 a=1。 Thread2 知道自己可以用了，赶紧上号，就从内存中读入 a，并获取锁，此时 a=1。 后续的使用流程就跟 Thread1 一样了。 可以看到，加了锁之后，我们原来的并行（多个线程一起执行），变成了串行（线程排队执行）了。串行就破坏了同一时间这个条件。\n那么，怎么破坏同一目标的呢？\n破坏同一目标 破坏同一目标的核心就是分散目标，但前提是目标能被拆分。\n那么，上述的例子能破坏同一目标吗？不能，因为 a 已经是一个数字了，没法再拆分了。\n我们看个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 List list = new List(); Thread t1 = new Thread() { void run() { // 我读读读 list.forEach {it-\u0026gt; println(it); } } } Thread t2 = new Thread() { void run() { // 我写写写 for(int i = 0; i\u0026lt; 1000_000;i++) { println(list.add(\u0026#34;yyds\u0026#34;)); } } } 俩线程同时操作一个顺序表，t1 不断地读，t2 不断地写，这就会导致问题了，可能本来集合是空。\nt1：哦空的啊，哈哈哈，那我就做做样子，美滋滋。 t2：与此同时我要开始搞事情，我开始写。 t1：？？？咋一下这么多数据了。要加钱！ 这就出现问题了，因为 t1 看到的跟预期不符。\n那怎么办呢？嗯，集合啊，可以分离啊，那就分离目标，我们可以这样：t2 每次在写数据的时候，都不直接对 list 写，而是把 list 复制一份，写到复印件里去，写完了再把它同步到 list。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Thread t2 = new Thread() { void run() { // 我写写写 // 创建个复印件 List newList = new List(); newList.addAll(list); // 对复印件操作 for(int i = 0; i\u0026lt; 1000_000;i++) { println(newList.add(\u0026#34;yyds\u0026#34;)); } // 同步到list list.clear; list.addAll(newList); } } 都看懂了吧？看不懂的话仔细看注释。\n为啥要这么干呢？这样可以把目标分离，写的时候针对的是 newList，而不是原来的 list，这样别的线程在读的时候还是原来的 list，也就是读和写的不是同一个目标，这就是目标分离。这样读写操作即使同时执行，也不会互相影响。\n这种做法叫做：写时拷贝（copy on write）。\n有人说，为啥不读时拷贝呢？劳资就要读时拷贝。\n不行，你忘了我们上一章说的吗：竞争冲突发生的前提是对冲突资源发生了操作，操作就是：增删改。而读，它不是操作，它是访问。\n假如你对读操作加了，那么两个线程一起写呢？不是照样出问题吗？\n所以，我们要理解核心：同时操作！操作！操作！针对引起问题的动作进行处理，也就是针对操作这个动作进行处理。\n再比如：哈希表，经过第 12 章节，我们知道哈希表是链表数组。存储的元素要先找下标。\n如果两个线程同时 put 元素的时候，下标不同，是不是就能同时 put 呢？\n对！所以，我们可以给哈希表分段，每次 put 元素的时候，如果是同一段，就等待；如果是不同的段，就可以直接 put。\n比如，线程 1 来 put，计算到下标是 4，那就直接 put。同时线程 2 也来 put，计算到下标是 5，也直接 put。同时线程 3 也来 put，计算到下标是 4，就看线程 1 是否 put 完了，没完就等着，完了自己再 put，依此类推。\n其实，分段思想，也是分离目标，将一个大段分为不同的小段，就等于把一个大目标拆分，我们上面的写时复制是复制了一份，而分段则是把自己拆分为几份，不过，核心思想都是：目标分离。\n目标分离是一种思想，而写时拷贝和分段都是实现这个思想的手段，我们要掌握本质，也就是要理解目标分离这个思想。\n我们来看下，基于这个思想衍生出来的工具。\n处理并发冲突的工具 并发的处理免不了要等待操作，那么，就有两种情况：\n我等着，你好了叫我； 我等着，每隔一段时间再来看看你搞完了吗。 第一种情况：你好了叫我，明显就是可能你要很久，劳资不等了，所以就是假设你要等很长时间，这是带有悲观色彩的，我们就叫它 悲观处理；第二种情况：我等一会儿再来看看，明显就是可能你很快就完了，也就是只等很短时间，这就是带有乐观色彩的，我们就叫它 乐观处理。\n嗯，听口气也大概猜到是这个意思了。\n悲观处理 凡是可能要等很久的都是悲观处理，我们以此可以发明一个悲观锁。\n悲观锁的核心就是等待，被唤醒。\n也就是说，我可能要等很久，那就算了，我不等了，你完事了跟我说下吧。\n那么，我们以此发明的悲观锁就叫 synchronized，大部分语言都有这个关键字，前缀sync也表示同步的意思，相反的，async就表示异步。\n比如，上面的a++例子，第二种排队的图示我们都看懂了，那么对应的代码呢？\n就如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class A { int a = 0; // 开启一个线程不断增加a的值 Thread t1 = new Thread() { // 加了synchronized关键字 synchronized void run(){ for(int i =0; i\u0026lt; 1000_000_000; i++) a++; } }; t1.start(); // 开启另一个线程不断增加a的值 Thread t2 = new Thread() { // 加了synchronized关键字 synchronized void run() { for(int i =0; i\u0026lt; 1000_000_000; i++) a++; } }; t2.start(); } 很简单，直接在函数上加上synchronized关键字就行了，就默认等于对当前对象（this）进行加锁。线程每次调用方法都要获取 this 这个锁，获取到就执行，获取不到就等着；函数执行完了就会默认释放 this 这个锁。\n那么，集合呢？比如上面的list，是不是也这样就行了？\n对！不过，有的语言已经自己对集合做了特殊处理了，比如Java的SynchronizedList，自己在内部已经对add()、remove()等函数进行了加锁操作，大概如下：\n1 2 3 4 5 6 7 8 9 class SynchronizedList { // 我自己加了，外面就别费事了 synchronized void add(int num) { } // 我自己加了，外面别费事了 synchronized void remove() { } } 这就是简单粗暴的设计思路。\n有人说，我都懂了，这个是需要排队，然后等别人执行完，来叫我一声就行。\n对，正是这样！\n那么，它先叫我吗？还是说谁排在前面就叫谁？\n随机的！完全随机！不是排在前面的就先叫，所以也叫：非公平锁！\n啥！不公平？不干了！\n别激动别激动，这是有道理的。这样随机唤醒，就等价于后面的每个线程的机会都是均等的，不会出现那种黄牛线程，自己往死里排队，结果后面的都得不到执行。\n没问题的话，我们就接着来看下乐观处理的方式。\n乐观处理 凡是可能等很少时间的都是乐观处理，我们可以以此发明一个乐观锁。\n乐观锁的核心就是自旋。\n大家都知道大名顶顶的 CAS，这就是个乐观锁。\n乐观锁因为只要等很少时间，所以，与其我回家等着，倒不如我在这看着，过一段时间就来问问，反正也没多久。\n这种过一段时间就来看看的叫做轮询，过一段时间来问问中的“一段时间”我干啥呢？我原地转圈玩，反正不闲着，这就叫做自旋。\n所以，我们可以发明一种自旋锁，自旋锁就是乐观锁的一种。\n比如，还是上面的a++的例子，我们改成自旋的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class A { int a = 0; boolean lock = false; // 开启一个线程不断增加a的值 Thread t1 = new Thread() { // 加了synchronized关键字 void run() { // 发现被锁了，就死循环自己转圈玩 while(lock) { // 大风车吱呀吱哟哟地转 } // 哦，终于拿到锁了，搞起! lock = true; // 自己拿到锁了，标记一下 for(int i =0; i\u0026lt; 1000_000_000; i++) a++; lock = false; // 自己执行完了，释放锁 } }; t1.start(); // 开启另一个线程不断增加a的值 Thread t2 = new Thread() { // 加了synchronized关键字 void run() { // 发现被锁了，就死循环自己转圈玩 while(lock) { // 大风车吱呀吱哟哟地转 } // 哦，终于拿到锁了，搞起! lock = true; for(int i =0; i\u0026lt; 1000_000_000; i++) a++; lock = false; } }; t2.start(); } 很简单，就开个死循环，不断检测着玩，一旦死循环结束，说明拿到锁了，就干自己该干的。\n有人说，这好费劲啊，一直在while(true)，CPU 就得一直工作，费电啊。\n对！确实费电，所以它的使用条件是等的时间短，如果等的时间很长，那么就是悲观的，就不要用乐观锁了。\n还有，我们可以改造我们的锁，每次都间隔一段时间再去访问，换句话说就是：在while(true)里面让线程休眠一段时间，如果好几次都获取不到锁，那就增加时间，比如：\n1 2 3 4 int len = 0 while(true) { sleep((len++)*200); } 这样就会依次休眠 200ms、400ms、600ms……这就叫做自适应自旋。\n当然，很多语言中都给我们提供了现成的工具，比如很多语言中都有CAS这个关键字，代码中敲一下就提示出来了，我们可以选择性使用。\n总之，大家要根据具体的场合去选择合适的锁。凡是可能等很少时间的都是乐观处理，我们可以以此发明一个乐观锁。\n乐观锁的核心就是自旋。\n大家都知道大名顶顶的 CAS，这就是个乐观锁。\n乐观锁因为只要等很少时间，所以，与其我回家等着，倒不如我在这看着，过一段时间就来问问，反正也没多久。\n这种过一段时间就来看看的叫做轮询，过一段时间来问问中的“一段时间”我干啥呢？我原地转圈玩，反正不闲着，这就叫做自旋。\n所以，我们可以发明一种自旋锁，自旋锁就是乐观锁的一种。\n比如，还是上面的a++的例子，我们改成自旋的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class A { int a = 0; boolean lock = false; // 开启一个线程不断增加a的值 Thread t1 = new Thread() { // 加了synchronized关键字 void run() { // 发现被锁了，就死循环自己转圈玩 while(lock) { // 大风车吱呀吱哟哟地转 } // 哦，终于拿到锁了，搞起! lock = true; // 自己拿到锁了，标记一下 for(int i =0; i\u0026lt; 1000_000_000; i++) a++; lock = false; // 自己执行完了，释放锁 } }; t1.start(); // 开启另一个线程不断增加a的值 Thread t2 = new Thread() { // 加了synchronized关键字 void run() { // 发现被锁了，就死循环自己转圈玩 while(lock) { // 大风车吱呀吱哟哟地转 } // 哦，终于拿到锁了，搞起! lock = true; for(int i =0; i\u0026lt; 1000_000_000; i++) a++; lock = false; } }; t2.start(); } 很简单，就开个死循环，不断检测着玩，一旦死循环结束，说明拿到锁了，就干自己该干的。\n有人说，这好费劲啊，一直在while(true)，CPU 就得一直工作，费电啊。\n对！确实费电，所以它的使用条件是等的时间短，如果等的时间很长，那么就是悲观的，就不要用乐观锁了。\n还有，我们可以改造我们的锁，每次都间隔一段时间再去访问，换句话说就是：在while(true)里面让线程休眠一段时间，如果好几次都获取不到锁，那就增加时间，比如：\n1 2 3 4 int len = 0 while(true) { sleep((len++)*200); } 这样就会依次休眠 200ms、400ms、600ms……这就叫做自适应自旋。\n当然，很多语言中都给我们提供了现成的工具，比如很多语言中都有CAS这个关键字，代码中敲一下就提示出来了，我们可以选择性使用。\n总之，大家要根据具体的场合去选择合适的锁。\n总结 本章给大家讲解了并发中冲突的处理方式：破坏同时性或破坏同一目标。只需要破坏一个条件即可。我们可以概括为一个思想、两个策略。\n一个思想：在遇到问题时，列出问题发生的充分必要条件，只要破坏一个条件就能解决问题。比如，本章的并发。 策略 1：当我等待一个资源的时候，如果资源迟迟不到位，那么我就告诉资源持有者，等资源到位的时候，通知我一下，这样可以不浪费我的时间，但是可能不及时，我们可以称之为：被动型通知。 策略 2：当我等待一个资源的时候，如果资源迟迟不到位，那么我就在这等着，这样可能比较浪费时间，但是比较及时，我们称之为：主动型获取。 大思想是我们必须掌握的，小策略则各有优缺点，需要我们根据具体情况去选择。\n好，那么，下一章，我们就来看下：计算机是怎么使用这种策略来调度我们的线程的。\n通俗易懂，很受用。\n- 同一时刻：并行转成串行。 - 同一个目标：分离目标，分而治之，写时拷贝。 - 悲观锁：排队，等待时间长的场景，被动等待。 - 乐观锁：自旋，原地观察，消耗cpu，等待时间短的场景，主动获取。\n15.操作系统精粹:调度算法及使用 在上一章中，我们讲了并发的发生和解决方案：破坏同一时间或破坏同一目标。我们知道，并发是两个线程之间的问题，那么进程之间呢？到底是哪个进程先跑，哪个进程后跑呢？CPU 是怎么安排这些进程的执行呢？\n这就涉及到进程的调度了，我们本章就来看看 CPU 是怎么处理这些琐事的。\n调度算法 调度算法指的是：CPU 对进程进行资源分配所采取的策略。\n比如：全班有 40 个学生，每个学生都写了一篇作文，那么，老师先批改谁写的呢？\n老师说：我就按照交作业的顺序来批改，这是一种调度算法。或者说：按照历史成绩名次来批改，这也是一种调度算法。\n好，我们就把计算机处理的任务称作：作业（Job），那么，计算机的调度算法就是处理这些作业的策略。\n先来先服务 先处理先到达的。\n先来先服务的意思就是：先处理先到达的作业。\n这个很简单，就像我们第 10 章讲的队列一样，先入先出。谁先到达，就先处理谁，也就是谁先到达，CPU 就先执行谁。\n这无疑是非常公平的。但是却有很大缺点，比方说：我有个作业很长很长很长，CPU 不吃不喝大概要 10 个小时才能搞完，而这个作业正好是第一个到达的，那么，在这 10 个小时内，后面来了 10086 个小作业，每个小作业大概几秒就能搞完，于是乎，这 10086 个小作业就坐在那儿傻等着，等 CPU 都转冒烟了才轮到自己。10 小时后，后面的小作业看着那个 10 小时的长作业奸笑着走了。\n这明显是不合适的。我就运行几秒的速度你让我等 10 个小时？等价于我为了看 1 分钟的电视剧就要看 10 个小时的广告，你这是电视剧插广告呢，还是广告插电视剧呢？\n这明显是谁的执行时间长，谁沾光啊，所以，先来先服务算法对长作业有优势。\n不行，得改！\n你看这样可以吗？让小的先执行，反正也就几秒的功夫。\n可以试试。\n短作业优先 哪个作业小，先执行哪个。\n现在我聪明了，执行作业的时候先看看作业的大小，小的优先执行，大的就往后排。这样一来，短期内我可以执行完好多个小作业，不用再被一个长作业卡死了。\n这还是不行啊。那个 10 小时的长作业看着眼前的小作业一个一个执行完美滋滋地走了，心理很不服气，我先来的，凭什么不给我执行！如果前面有 100 个小作业，每个 1 小时，那我岂不是要等 100 个小时，你这跟 1 个 100 小时的长作业有啥区别？\n它说的有道理啊，况且这个 10 小时的长作业是老大指定的，不能让人家等太久了。\n那要怎么办呢？\n嗯，加权。我们可以给每个作业都加一个权重，权重大的作业就特别照顾下，让它优先执行。\n高优先权优先 给每个作业加权，权重大的优先执行。\n我们按照每个作业的重要程度来设置权重，权重大的作业就优先安排执行。\n还是上面的例子，那个长达 10 小时的大作业来了，刚想让它排队，一看权重是最高级的，那么就让它插个队，优先执行它，这不就跟银行的贵宾服务一样吗，随便插队。\n如果两个优先级一样的，我们可以再按照先来先服务执行，或者短作业优先执行。\n当然，对于作业的权重，我们还可以动态设置。\n比如：有 A、B 和 C 三个作业，A 作业需要 10 个小时，权重是 5；B 作业需要 20 个小时，权重是 10；C 作业需要 15 个小时，权重是 8。那么，按照优先级来说，肯定是先执行 B，再执行 C，最后执行 A。结果在 B 执行完后，A 忍不住了，直接修改自己的权重为 10，此时，本来轮到 C 执行的，就变成了轮到 A 执行，那么 A 的这种权重就叫做动态优先权，而 B 和 C 的都叫做静态优先权。\n静态优先权是事先设定好的，不会变的；动态优先权是可以随着时间改变的。\n所以，我们在设计任务的时候，也可以借鉴这种方法，来动态地设置我们的优先权。比方说，我们在上一章谈到的自适应自旋，就是按照等待的时间自己调整自己的休眠时间，这跟动态优先权有异曲同工之妙。\n那么，两个优先权一样，一个等了很久的长作业 A，一个刚到的短作业 B，我们应该先执行哪一个呢？\n如果先执行 A，那么 B 可能等很久。如果先执行 B，那么 A 又要等很久。都不合适。\n那么，有没有什么办法能把它们的等待时间和执行时间结合起来，从而得出一个数字来衡量下呢？\n有！\n高响应比优先 根据每个作业的等待时间和执行时间计算出响应比，响应比大的先执行。\n宇宙的尽头都是量化，没有量化的推测就是耍流氓。\n同理，我们上述说的全是些屁话，这里就把我们上述的废话量化成一个公式：\n响应比 = (等待时间+执行时间) / 执行时间\n我们可以看到两点：\n等待的时间越长，响应比就越大，这就避免了短作业优先算法中长作业等得太久。长作业：谢谢你。 执行时间越短，响应比越大，这就避免了先来先服务算法中短作业等得太久。短作业：谢谢你。 这就完美把短作业优先和先来先服务结合起来了。\n看个例子：A（10 小时），已经等了 10 个小时；B（5 小时），已经等了 6 个小时；C（1 小时），刚到。\n我们来计算下它们的响应比：\nA = (10+10)/10 = 2 B = (6+5)/5 = 2.2 C = (0+1)/1 = 1 所以，我们应该先执行 B，此时 B 不是最先到的（A 先到），也不是最短的（C 最短），但是 B 却是响应比最高的，所以下一个就轮到 B 执行了。\n其实，我们可以看到，高响应比优先就是把短作业优先和先来先服务结合了起来，进行了个折中处理，用具体的数字量化出来。只要有个确切数字，我们很容易就能决定谁先执行。\n我们在日常的开发中，也要掌握这样一种思想：把抽象的事物用具体的数字量化出来，根据数字来决定事情的优先级。这样是最客观的，可以避免主观意识大于客观形态，从而减少感性决定。\n时间片轮转 我们知道，电脑速度是很快的，那么，速度快有什么好处呢？很多！\n我们可以这么理解：你说一句话的期间，我说了 1000 句话，不是跟一个人说了 1000 句话，而是跟 1000 个人每人说了 1 句话。\n等等等等，那这不就意味着：1000 个人来找我搭讪，我可以同时搭讪这 1000 个人吗？\n换句话说，1000 个作业来找我处理，我可以同时处理这 1000 个作业吗？\n对！这就是时间片轮转调度算法。\n给每个作业分配一小段时间执行，执行完了就让下一个作业执行。\n我们可以按照作业的到达顺序排成一个队列，让前面的作业执行几毫秒，然后排到末尾，第二个作业再执行几毫秒，再排到末尾，直到作业执行完毕。\n这样给人的感觉就是：每个作业都在执行，好像所有作业都在同步执行似的，这其实就是并发。\n不是并行，是并发。\n并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。\n比如：7 点整我在一边吃饭一边听音乐，这是一个时间点我在做两件事，那么这两件事就是并行的； 7 点到 8 点我写了作业洗了衣服，这是在一个时间段内我做了两件事，这就是并发。\n并行是真正的并行，而并发是宏观上并行、微观上串行。\n就像我写作业洗衣服，给人的感觉是：我在 7 点到 8 点之间，写作业的同时洗了洗衣服。实际上我不是同时干的，而是一件一件干的。\n那么计算机呢，也不是同时干的，而是一件一件干的。但是因为执行得快，给人的感觉就像是：同时干的。\n比如：人的反应时间是 500ms，计算机有 100 件任务，按照时间片轮转，一个执行 4ms 就执行下一个，那么，当你在时间 T 去问计算机你的任务执行到哪了，它说 10% 了。而下一次你去问的时候，已经过了 500ms 了（因为你的反应时间是 500ms），这个时候，计算机已经又执行一轮了，你的任务已经 20% 了。所以，给你的感觉就像是：它一直在执行你的任务。\n这就是速度碾压！比金色闪光还金色闪光！\n那么，我们要怎么使用这些调度算法呢？\n调度算法实践 调度算法无处不在，只不过我们平常不注意罢了。\n比方说，大家都写过下载逻辑，就像一个歌单：点击就下载。相信大部分人都是创建一个队列，点击的时候就将歌曲添加到队列中，然后按照顺序下载。这其实就是：先来先服务。\n还有一种下载器，用户可以手动拖放下载位置，也就是可以把后面的拖到前面，或者采用“置顶”来让后面的跑到前面去，这就是高优先权优先。\n其实，如果是后台下载的时候，我们可以采用短作业优先，因为放在后台的话，指不定啥时候就被系统杀死了，如果是长作业，可能下载到一半，就没了；但是如果是短作业，那么还能下载完几首歌曲，这肯定是更好的。\n当然，如果是专门做下载器的同学，比如迅雷，当任务比较多的时候，采用高响应比优先是更好的策略，这样不至于让用户等太久，也不至于半天一个都没下载完。\n其实，京东、淘宝的客服，它们采用的就是加权的高响应比优先算法，也就是说：在高响应比优先的公式里，加上用户的权重，权重指的就是你的会员等级等重要程度指标。只不过这个不是计算机用来调度进程，而是用来调度人力罢了，所以，这些调度算法不仅仅适用于撸码，还适用于生活。\n总结 本节我们讲解了计算机的调度算法，其实就是一个思想：将所有可行的方案列出来，将影响它们的条件量化成一个数字，然后按照这个数字去决定。\n先来先服务：先到达的先执行。 短作业优先：耗时少的先执行。 高优先权优先：优先级高的先执行。 高响应比优先：结合等待时间和执行时间计算响应比，响应比高的先执行。 时间片轮转：每个都执行一小段时间，直到所有作业都执行完。 操作系统的基础到这里就结束了，下一章，我们就进入计算机网络的世界，来了解下计算机网络是怎么搭建起来的。\n16.森严的等级制度:层级与协议 什么是计算机网络呢？有人说：计算机网络就是百度！还有人说：计算机网络就是 HTTP！如果你也是这么想的，那么希望本篇你能仔细看下去。\n那么，计算机网络到底是什么呢？\n客观地说，计算机网络就是：一些相互连接的、自治的计算机的集合。\n说人话就是：全世界所有通过互联网互相连接的计算机所组成的一个大网。\n如果你的电脑联网了，那就是计算机网络的一部分，如果你的电脑没联网，那就不是计算机网络的一部分。\n计算机网络简介 计算机网络可以分为：广域网、城域网、局域网和个人区域网。\n广域网：覆盖几十到几千公里，比如我们日常说的上网，用百度、谷歌等，用的就是广域网。 城域网：一般覆盖一个城市，大约 5 到 50 公里，比如有的城市的宽带。 局域网：一般覆盖一公里左右，比如一个公司的内网。 个人区域网：覆盖范围只有几米，比如自己给自己开热点。 有人说，这些我都不在乎，我就在乎它快不快、猛不猛、看视频卡不卡，这就要提到网络的质量参数了。\n判断一个网络的质量有 7 个性能指标。\n速率：这个很好理解，就是传输速度。直接受到材料的影响，比如，相同条件下有线网肯定比无线网快；而同是有线网络，光纤就比电缆快。 带宽：可以简单理解为传输的横切面大小。我们把计算机网络的传输看作是一个水管，速率就是传输的速度，带宽就是水管横切面大小，越大传输得肯定越快。 吞吐量：单位时间内通过网络的数据量。这才是真正的传输速度，如果水管生锈了，那么速率是 100，也达不到 100，因为水锈会阻碍一部分传输，而吞吐量就是把所有因素都考虑进去之后，得出的最终的传输速度。 时延：把数据从 A 端发送到 B 端所需要的时间。 时延带宽积：发送数据时的延迟 x 带宽得出的结果。 往返时间：从 A 发数据到 B，到 A 收到 B 的响应所需要的时间。 利用率：网络在传输时信道的利用百分比。 我们把传输信号的介质统一称为：信道。\n我们知道，网络传输的其实就是信号，或者说是电磁波，电磁波可以直接在空气中传播，可以在电缆中传播，也可以在光纤中传播。所以，空气、电缆、光纤等，都是信道。\n我们传输的数据，也就是电磁波，从微观看就是一个一个的电子，电子在金属中的传输速度大于在空气中的传输速度，并且空气中有其他信号干扰，所以有线网就比 Wi-Fi 快。\n那么，这些电子就这样传送，我咋知道它传送的什么玩意儿呢？\n只要我们制定一个规则，然后大家都按照这个规则来传递，不就都明白了吗？\n这个规则就叫做：计算机网络协议。\n计算机网络协议 计算机网络协议是指：为计算机网络中进行数据交换而建立的规则、标准或约定的集合。\n比如，我们前面说过的 HTTP，也是计算机网络协议中的一部分，属于应用层协议。\n应用层？还分层吗？\n分，就像我们的代码也分内核层、Native 层、Framework 层、应用层一样，网络协议也是分层的。\n分层就是为了简便，各司其职，分工明确，容易维护。\n我们一般把网络协议分为 5 层：物理层、数据链路层、网络层、传输层、应用层。当然，也有其他分法，我们这里就不叨叨了。\n这里要理清一个流程，比如 A 向 B 发数据，数据是从 A 的应用层开始，沿着传输层、网络层、链路层、物理层向下，再依次到达 B 的物理层、链路层、网络层、传输层，最后到达 B 的应用层。\n就像 A 给 B 送信，A 住在 5 楼，B 住在对面的 5 楼，A 先要下到 1 楼，然后再从 B 住的楼上去，才能送达。\n物理层 物理层规定传输媒介的一些特性。\n比如说，我们上面说到的电缆和光纤都是传输媒介，当然还有其他的，比如无线信道、同轴电缆等。物理层指的不是这些实实在在的物理上的传输媒介，而是规定它们的协议。那么，这些传输媒介有什么共同点呢？可以分为四个点。\n机械特性：指明接线器的形状和尺寸、引脚数目、排列方式等。 电气特性：指明每条线上的电压范围。 功能特性：指明每条线上每一个电平表示的意义。 过程特性：指明各种事件的出现顺序。比如，哪根信号线先动，哪根信号线先出现什么电平等。 换句话说，物理层协议将具体的实实在在的传输媒介进行了高度总结，抽象成了四个特点，只要满足这四个特点，就可以作为传输媒介。这样一来，我们不必去死记硬背到底哪些属于传输媒介，而只需要理解这四个特性，只要满足这四个特性的，就可以作为传输媒介。这就是化记忆为理解的手段之一：找共性并总结抽象。\n这跟面向对象中的将具体事物提炼成抽象类有异曲同工之妙。\n一般来说，我们的信道有三种。\n单向通信：也叫单工通信，只能从一端到另一端通信，而不能反过来。比如我们收听的收音机广播。 双向交替通信：也叫半双工通信，双端都可以收发，但不能同时进行。 双向同时通信：也叫全双工通信，双方可以同时发送和接收。 现在，我们有了物理层，可以传输电子信号了，那么电子信号是怎么被识别成数据呢？又怎么保证可靠地到达另一端呢？\n数据链路层 数据链路层负责将数据透明地、无差错地进行传输。\n我们知道，传输媒介传输的是信号，或者说就是电子，那这怎么可能看得懂呢？很简单，我们传输的电子都会通过电路展示为高低电平，我们用高电平表示 1，低电平表示 0，这样就被翻译成了一串串二进制，而数据链路层就负责把这些二进制封装成帧，你可以将帧理解为一串二进制。\n那么，在数据链路层我们的传输单位就从电子信号变成了帧。那么，要怎么保证这些帧正常地到达呢？这就是数据链路层的核心作用了。\n首先，链路层会把我们的数据封装成一个一个的数据帧，说白了就是在数据前后添加标记，我们称之为首部和尾部，这样，当接收端收到数据后，就能首部和尾部的标记，来识别数据的开头和结束。\n当然，我们传输数据的时候，不会感知到首部和尾部的存在，这是链路层自己添加的，在发送的时候自己添加，在接受的时候自己删除，这对我们来说是透明的。\n其次，链路层会对发送的数据进行差错检测，比如最常见的循环冗余检测，如果遇到错误的数据帧，就会丢掉并重传，以此来提供可靠的、无差错的数据传输。\n所以，链路层的功能就是：将数据封装成帧，进行透明地、无差错地传递。\n那么，我们怎么知道要传输到哪里呢？数据怎么知道对方的地址呢？\n网络层 网络层负责编址、寻址和转发。\n网络层的核心功能就是寻址，也就是寻找地址。\n我们知道，我们发送数据都需要一个 IP 地址。IP 就是一个协议，全称叫做 Internet Protoco，叫做国际互联协议，它可以表示一个地址，比如常见的 192.168.xxx.xx，叫做 IP 地址。\n那么，这样的地址怎么能找到对方的主机呢？\n我们可以通过地址映射协议，也叫做 ARP（Address Resolution Protocol） 来根据 IP 地址找到对应的主机地址，从而将数据塞给这个主机，或者从这个主机上拿数据。\n主机地址是不变的，IP 地址是随着网络变化的。\n比如：我的主机叫大灰狼，我连了我家的 wifi123，那么，我连了网，就会自动给我的主机分配一个 IP 地址，假如地址是 192.168.1.1，那么，隔壁喜羊羊就可以顺着这个地址来找到我的主机大灰狼，从而给我发消息；如果我换了另一个网络，我的主机又被重新分配一个新 IP 地址，那么，喜羊羊用老的 IP 地址就找不到我了。\n这也就是我们连接不同的网络时，执行ipconfig查看到的 IP 地址不同的原因。\nIP 地址有了，我们可以买个域名，比如 https://www.yyds.nb，然后将这个域名绑定到自己的 IP 地址，那么别人访问这个域名的时，就会访问到你的 IP 地址，这个过程叫做域名映射，跟上面的地址映射是异曲同工的。\n所以，网络层的两个核心协议就是 IP 和 ARP，IP 协议负责给不同的主机分配 IP 地址，ARP 协议负责根据 IP 地址找到实际的主机地址。\n那么，地址知道了，我们怎么传输数据呢？直接硬塞吗？非也！\n传输层 传输层的核心作用就是进行数据的传输。\n上面说到，我们通过网络层拿到了具体的主机地址，那么，数据传给谁呢？直接塞到系统的 C 盘吗？\n肯定不会，应该是传给这个主机中的一个进程，这个进程收到数据后就进行数据的解析处理。那么，数据是怎么被进程获取到呢？\n通过端口号！\n每个主机上都有不同的端口号，我们可以开启一个进程去监听这个端口，只要监听到这个端口有数据，我们就立刻处理，这样就拿到了数据。\n也就是说，数据传输不仅仅需要 IP 地址，还需要有端口号，比如常见的192.168.0.1:8080，其中 8080 就是端口号。最常见的就是 Socket 了。\n数据传输有两种传输方式，一种是面向连接的，可靠的 TCP 协议；另一种就是无连接的，不可靠的 UDP 协议。\nTCP（Transmission Control Protocol）：面向连接的，可靠的。 UDP（User Datagram Protocol）：无连接的，不可靠的。 照这么说，UDP 不就没啥用了吗，不可靠要你干啥？\n存在就是道理！\nTCP 虽然可靠，但是每次通信都要先建立连接，完事之后还要断开连接，就像打电话一样。\nA：喂，能听到么？\nB：嗯，可以，And you?\nA：me too，好，现在我们开始吹。\n1 个小时之后要结束了。\nA：今天就到这里吧。\nB：好的，就到这里吧。\nA：好的，挂了。\nB：好的，我也挂了。\n累不累？这个美其名曰三次握手四次挥手。因为提前都互相问了对方能听到吗，所以是可靠的。但是我们也看到了，太费劲！\n如果是 UDP 呢？就是如下这样。\nA：大风车啊咿呀咿呀转，xxxxxxxx，收到回复！\nB：嗯！\n就这么简单，就跟发短信似的，但是可能 B 没收到，所以不可靠。\n所以，我们可以总结一下：TCP 需要连接，费事，但是可靠；UDP 不需要连接，省事，但是不可靠。\n关于 TCP 和 UDP 的更多知识我们下一章具体讲解。\n应用层 应用层直接给用户提供傻瓜式的服务。\n这一层最常见的就是 HTTP 了，也叫做超文本传输协议（Hyper Text Transfer Protocol），大部分都是用来传递 JSON，也可以传递 HTML 页面，所以叫做超文本。\nHTTP 是基于 TCP 的，所以也是需要连接的。\n一次完整的 HTTP 请求如下，比如我们请求https://juejin.cn。\n通过域名映射找到https://juejin.cn对应的 IP 地址。 通过这个 IP 地址加上默认端口 80 进行 TCP 连接。 发送数据请求。 等待对方主机返回响应结果，也就是一个 HTML 页面。 得到结果，放在浏览器里面进行渲染，我们就看到了具体的页面。 关闭 TCP 连接。 关于 HTTP 就不做过多讲解，应用层还有很多其他协议，比如文件传输协议 FTP、电子邮件协议 SMTP。\n凡是 P 结尾的，大部分都是协议或原则。\n比如，单一职责原则 SRP、开放闭合原则 OCP 等。\n总结 本章知识比较杂，且记忆性东西比较多，我们再来回顾一下。\n物理层：概括并抽象出传输信道的特点。 链路层：将数据封装成帧，并进行校验，保证数据可靠传输。 网络层：进行地址分配和地址访问。 传输层：连接并进行数据传输。 应用层：提供给用户使用。 我们不必死记硬背，只要知道这些都是规则即可，规则就是用来遵守和理解的，不是用来死记硬背的。下一章，我们就来看计算机网络中设计的最出彩的、最需要理解的地方：TCP 的可靠传输的实现。\n17.苦累的搬运工:TCP和UDP的传输过程 上一章我们讲了计算机网络的层级，并且知道了每一层的作用，其实对于我们来说，我们真正需要了解的就两层，一个是应用层，一个是传输层。\n应用层的 HTTP、传输层的 TCP，这俩协议是用得最多的，基本上霸占了“皇后”和“贵妃”的位置，而 HTTP 又是基于 TCP 实现的，那我们就追其根溯其源，剥其衣脱其裳，来彻底了解下这位面试官最喜欢打听的协议吧。\nTCP 可靠传输的实现原理 上一章我们说过：TCP 的传输是可靠的。那么，这个“可靠”是啥意思呢？其实它包含两个点：\n传输的数据没有差错； 传输的数据不会丢失。 有人说，你这不废话吗？没有差错肯定就不会丢失啊，第 1 点包含了第 2 点啊。\n非也！\n我们举个例子，我一秒给你发 100 条信息，并且全发到了，这是没有差错；但是你来不及看完，也就是有漏看，这就是丢失了。\n所以，我们可以定义得更精简一点：传输的数据没有差错并且全部被处理。\n这怎么可能呢？网络信号肯定有不好的时候，比如隔壁有人下载东西下载得太猛把网下欠费了又不去缴费，那这不就丢失了？你怎么保证可靠？\n可以的，我们只需要保证两点：\n传输出错的数据进行重传； 控制传输速度，让接收方来得及处理。 这样，即使原来不可靠，也会变得可靠了。\n要实现这两点，我们要了解以下几个协议。\n超时重传协议 发送方在发送数据之后的规定时间内，如果没有收到接收方的确认，则重新传送数据。\n现在假设 A 向 B 发消息，如果网络正常，就是 A 向 B 发送消息，B 正常收到。\n但是如果网络异常呢？A 向 B 发送之后，A 怎么知道 B 是否收到了呢？\n这就需要 B 在收到 A 的消息后，向 A 发送一个确认信号，A 收到了 B 的确认信号，才认为 B 正确地收到了 A 发送的消息。\n所以，如果网络正常，那么流程就变为：\nA 向 B 发消息，并等待 B 的确认； B 收到 A 的消息，发送确认消息给 A； A 收到 B 的确认消息，认为 B 正常收到了，继续发送下一个消息。 那么，如果 A 迟迟没有收到 B 的确认消息呢？比如，双方约定了一个时间 T，A 在发送消息后，经过时间 T 还没有收到 B 的确认消息，那么 A 还继续等吗？\n不等了！此时 A 就认为 B 没有收到自己发送的消息，于是就重新发送一次，直到收到 B 的确认消息为止。\n这就叫做超时重传。那么这个时间又是多少呢？\n我们假设，A 发送消息到 B 需要的时间为 t1，B 处理消息需要时间为 t2，B 发送确认消息到 A 需要的时间为 t3，那么这个超时时间 T 肯定要大于 t1+t2+t3。而且考虑到通用性，我们应该计算多次 t1+t2+t3，并且取它们的平均值，而 T 就要大于这个平均值。\n当然，有人说了，你这也不准啊，网络可能有时候很差，有时候很好，你这怎么决定呢？\n旨哉斯言！\n所以，我们要动态计算这个超时时间，我们在第 14 章讲过自旋锁，自旋锁可以根据具体情形进化为自适应自旋锁。这里也是一样的道理，我们可以根据当前情形动态计算超时时间 T，比如：根据最近的 20 次传输时间取平均值。\n其实，核心就是动态计算，而不是固定死的一个值。\n当然，超时重传这个操作 TCP 已经帮我们做好了，我们在 API 层是无感知的，无脑调用 API 就行。所以也叫做自动重传递协议，术语就是 ARQ（Automatic Repeat reQuest）。\nARQ 保证我们的数据是无差错地传输到另一端，那么，怎么保证另一端能来得及处理呢？\n这就要说到停止等待协议。\n停止等待协议 发送方会调整发送速度，来等待接收方处理完之后，再进行发送。\n其实，我们上文已经说过了，A 发送一条消息之后，直到收到 B 的确认消息，才会继续发送下一条消息，就好像是 A 等着 B 似的，这就叫停止等待协议。这样一来，B 总是在自己处理完一条消息之后才发送确认信号给 A，A 总是在 B 处理完一条消息之后才发送下一条消息给 B，说白了就像一条隧道，A 开过去，B 再开过来，A 再开过去，如此循环。\n等等，这不对劲啊！我们的 TCP 是全双工啊，你这样活脱脱地把它完成了单工通信了，这岂不是白白浪费资源吗？\n比如 B 在发送确认消息到 A 的过程中，A 就干等着？A 在发送消息给 B 的过程中，B 也干等着？如果网络不好，A 发送消息发了 10 分钟还没到，B 就等 10 分钟？这工作严重不饱和，连传输信道都等得空虚寂寞冷了。那么，何以解之呢？\n我么可以这么干：我们直接在发送端 A 和接收端 B 都开一个缓冲区，A 每次发送的消息都放在自己的缓冲区中，B 每次收到的消息也先放在自己的缓冲区中，A 只要缓冲区不满就继续发消息，直到缓冲区满为止；B 就循环从缓冲区取出消息处理，处理完就发送确认信息给 A，同时继续处理下一条消息；A 收到 B 的确认信号就从缓冲区移除对应的消息，移除之后缓冲区就不满了，就继续发送下一条消息。如此循环，直到消息全部发送完毕为止。\n有人立刻就懂了，这不正是生产者消费者模式吗，没错，正是！\n如此一来，我们的信道可能一直处于忙碌状态，大大提高了信道的利用率。假如，此刻，A 正在给 B 发送第 10 条消息，而 B 正好给 A 回复第 3 条消息的确认信息，此时信道中就同时出现 A 给 B 发、B 也给 A 发的情景，这正是全双工的表现。\n那么，这样的话，就不是停止等待了，那这怎么保证对方来得及处理呢？\n不不不，这仍然是停止等待，只不过等待的不是一条消息了，而是一堆消息了。换句话说，没有缓冲区的停止等待，就像有缓冲区但是缓冲区的大小是 1 的情况。有缓冲区的停止等待，等待的是什么呢？等待的是缓冲区不满，所以，当缓冲区满了，照样等待。\n有人说，这也不对啊，没有缓冲区的停止等待，如果消息错了，我就重新发送，对方再重新处理就行了，而有了缓冲区后，如果中间一条消息出错了怎么办呢？后面的是不是全乱了？\n对！后面的肯定都乱了，所以，后面的全部重新传送一遍即可！\n比如，缓冲区大小是 5，A 发送了 12345，B 收到了 1245，没收到 3，那么，A 迟迟收不到 B 对 3 的确认信号，A 就会将 345 全部重新发送一遍，直到收到 3 的确认为止。\n那如果 B 没收到 3，直接对 4 进行了处理，然后给 A 发送了 4 的确认呢？A 会认为这个确认无效，因为没跟上一个确认连上，所以不做处理。\n有人又说了，你这如果中间丢了一个消息，就要把后面全部传送一遍，这效率肯定低了啊。\n对，效率肯定低了，但是你想啊，我们的网络大部分都是好的，只有很少一部分时间是异常的，所以，这个选择肯定是利大于弊的。如果真的网络差，那也没办法，效率低是低了，但是消息还是正确的。总而言之，我们权衡利弊之后，还是选择带有缓冲区的停止等待协议。\n其实，这个就叫做连续 ARQ 协议，大大提高了信道利用率，提高了传输效率。\n连续 ARQ 协议 我们上面说了，使用加缓冲区的停止等待协议，就是连续 ARQ 协议，这其实就是采用流水线方式进行连续发送，提高信道利用率，而不用依次等待上一条消息的确认，毕竟异常的情况是少数，我们就默认是正常的，如果发现错误，再从错误的地方重新发送即可。\n其实，连续 ARQ 协议是采用滑动窗口实现的，我们的缓冲区就等于一个窗口，如下所示：\n我们假设缓冲区的大小是 5，那么这个窗口的宽度也就是 5，我们把沿着滑动方向的两条边分别称为前沿和后沿，前沿后沿的差值就是缓冲区的大小；刚开始时，TCP 会将窗口内的消息全部发送，当收到一个确认信号时，窗口会整体向前移动，新进入窗口的消息就会被发送。\n比如，图中所示，如果收到了消息 1 的确认，那么后沿就向前移动一个单位，如下：\n此时，6 进入了窗口，6 就会被发送。如果此时收到了 2 的确认信号，窗口就继续向右边移动，直到全部确认为止。\n窗口内的数据都是有缓存的，如果收不到确认，就会把窗口内的数据重新发送一遍。比如，如果超时没有收到 2 的确认，那么就会把窗口内的 23456 全部发送一遍（反正有缓存）；如果收到了 2 的确认，那么窗口整体右移，2 就被移出窗口，因为 2 不需要发送了。\n这个过程就像窗口，所以也叫做滑动窗口。换句话说，连续 ARQ 协议是基于滑动窗口的思想实现的。\n好，到这里，TCP 的数据传输我们都了解了。那么，TCP 是怎么建立连接的呢？\n三次握手与四次挥手 TCP 是怎么建立连接的呢？\nTCP 的连接采用 CS 模式，也叫做客户端-服务器模式，主动发起连接的叫客户端（C 端），被动等待连接的叫做服务端（S 端）。\n刚开始客户端和服务端都处于关闭状态，当需要建立连接时，客户端会主动打开连接，然后请求服务器建立连接，这中间有三次握手的操作，如下。\n客户端：服务器吗，我需要建立连接（第一次握手）。 服务器：朕知道了（第二次握手）。 客户端：那还不赶紧打开（第三次握手）？ 服务器打开连接（建立连接）。 那么，为什么要三次握手呢？首先，不握手肯定是不行的，一次握手也是不行的，因为都不能保证对方收到了自己的请求，要保证对方收到了自己的请求，至少要两次握手，一次是请求，一次是对请求的确认。\n我们知道，TCP 是全双工的，如果只有两次握手，那么结果就是客户端发送、服务器确认，这只能保证服务器能接收到客户端的消息，而不能保证客户端能接收到服务器的消息，这是不可靠的。所以我们需要三次握手，直到第三次客户端的应答过来了，才能保证客户端确确实实收到了服务器的确认信号，也就是保证了双方都能互相接收到对方的消息，也就保证了可靠性。\n还有一点，就是可以避免浪费资源。比如：第一次握手时由于网络问题，发出的信号迟迟没有到达服务器，于是，由于超时重传，客户端再次发送一个连接信号，此时，网络中有两个连接信号了；如果这时候网络突然好了，那么服务器就会一下收到两个连接信号，如果是两次握手，服务器此时就直接打开了两个连接。这两个连接中必定有一个是无用的，白白浪费资源。\n如果是三次握手呢？服务器就不会打开连接，而是发送两个确认信号给客户端，客户端收到第一个确认信号时，就告诉服务器打开连接（第三次握手），收到第二个确认信号时，由于已经收到过相同的信号了，就认为是重复的，就直接丢掉。这样服务器就只会收到一个第三次握手的信号，只会建立一个连接，从而避免浪费资源。\n有人说，你这不就是让客户端判断是否有重复信号呗？你放在服务器不是也可以吗？\n不可以！你要知道，服务器是面向多个客户端的，如果要判断是否有重复信号，那就要保存每一个客户端的请求信息，如果有 10 亿个客户端，这要保存多少信息呢？这个代价太高了，不如分摊到客户端，让客户端自己记录，这样代价低一些。所以，服务器适合做广播，而不太适合做单播。\n所以，我们可以归纳三次握手的两个点：保证可靠，避免浪费资源。\n那么，TCP 是怎么断开连接呢？\n流程大致如下：\n客户端：我要断开了。 服务器：好的。 服务器：我也要断开了。 客户端：好的。 这看着都费劲啊，就断个关系，吧啦吧啦还要四次，能不能干净利落点直接断了，就跟断开网线一样？\n这肯定不行啊，如果直接断了，这到底是正常断开呢，还是网络异常了呢？所以我们需要通知对方，这就需要两次握手。而我们又知道，TCP 是全双工的，客户端到服务器断了就表示客户端不再向服务器发送消息了，但是，服务器依然可以向客户端发消息啊，因为你是全双工啊。所以，如果要彻底断开，还需要服务器发起一次握手，客户端进行一次应答，这样才能让这个全双工连接彻底断开。这就一共需要四次挥手。\n有人说，那你连接的时候为啥三次就行？因为握手的时候，第二次握手的过程同时包含了服务器的应答和服务器的发送，等价于做了两件事，比如：\nA：你能听到吗？\nB：我能听到。（这句话说明 B 不但收到了 A 的消息，还表明了 B 能发送消息。）\nA：好的。（这句话证明了 B 发消息成功，还证明了 A 能收到 B 的消息。）\n多余的话就不扯了，到这里，相信你已经了解了其中的道理，那么，下次面试的时候，遇到这样的问题，希望你能把面试官吊起来挂在墙上打。\nUDP 协议 UDP 是无连接的、不可靠的，所以没什么可以扯的太多的东西，这里就不废话了。\n总结 本章重点讲解了 TCP 可靠传输的实现原理，以及 TCP 连接和断开的原理，我们再来回顾下。\nTCP 要保证可靠，就要保证消息正确送达、接收方来得及处理。 通过超时重传来保证消息正确到达。 通过 ARQ 协议来保证接收方来得及处理，通过连续 ARQ 协议来提高信道利用率。 TCP 的连接需要三次握手，三次握手可以保证可靠性并且避免浪费资源。 TCP 的断开需要四次挥手，四次挥手可以保证全双工通信彻底断开。 这里面我们要学会两个思想：第一就是 动态策略思想，比如自适应自旋锁、超时等待协议的超时时间的计算，都是根据当前时机的情况动态调整策略；第二就是 滑动窗口思想，其实也等于缓冲区思想，当我们发现有等待的场景从而导致某种资源被白白浪费的时候，就可以开辟缓冲区，让等待者忙起来，先把产出结果放进缓冲区里面，从而避免浪费等待者这个资源。\n好，下一节，我们就从实际开发的场景来看一下怎么优化我们的网络，以达到秒开、省流的目的。\n18.网络的实践:优化我们的网络请求 在上一章中，我们讲了 TCP 的可靠传输原理，以及连接和释放过程，这些都是理论知识，除了可以让自己豁然开朗、心情舒畅外，还可以应对面试官的刁难。\n那么，本章就来从实践方面搞定网络部分的优化，这可以让爱找茬的测试闭嘴，也可以让爱挑刺的用户禁言。\n我们先提纲挈领，总结出来网络优化的几句总纲：尽量不请求，尽量少请求，尽量提前请求。\n好，下面就让我们来详细剖析下这几句秘籍的具体含义吧。\n不请求 我们的数据从哪来的？——从服务器啊。\n那你不请求还会有数据吗？——会啊。\n抬杠是吧？你把网络关了，看看数据从哪来？\n好，现在我去把网络关了，打开微信，我照样能看到聊天记录，照样能看到发送和接收到的图片，照样能看到好友信息。\n这是为啥？缓存！\n要想不请求只有一个办法：缓存！\n缓存是啥呢？\n缓存就是将从网络获取到的数据保存到客户端本地。\n这样一来，下次使用的时候，即使网络没有数据，也能用本地的数据显示给用户。\n那么，是不是有了缓存之后，就不用再请求服务器数据了呢？\n肯定不是，因为缓存的数据是固定不变的，而服务器的数据是不断变化的，我们不能一直看老数据吧，所以，缓存也要实时更新，我们可以每次从服务器请求到数据后，都更新到本地，这样来提高缓存数据的实时性。页面显示的时候，我们优先显示缓存的数据，同时去拉取服务器的数据，服务器数据过来后，再更新的页面上，同时更新到缓存中，就行了。\n1 2 3 4 5 6 7 8 9 10 11 12 fun showUI { // 先用本地数据渲染页面 val localData = getLoalData(); refreshUI(localData); // 请求网络数据，这是个异步操作 val newData = requestData(); // 用网络新数据渲染页面 refreshUI(newData); // 将网络新数据保存到本地，这也是个异步操作 saveDataToLocal(newData); } 如上所示，简单明了。\n我们可以这么理解：我们的缓存其实也是服务器。\n啥叫服务器呢？——提供服务的机器。\n啥服务呢？——提供数据！\n所以，从广义的角度来讲，请求数据的叫客户端，提供数据的叫服务器。\n所以，一旦没有了网络，提供数据的就是缓存，也就是本地文件，那么，此时的服务器就是缓存。\n换句话来讲，客户端不管面对谁，只要你是给我提供数据的，你就是服务器。\n那从这个角度来讲，内存也是服务器啊。我可以把请求过来的数据缓存到内存中，下次直接从内存中拿不就完事了？\n当然可以！\n好，现在让我们站在客户端的角度来看问题。\n首先，我有个页面叫PageA，是用来展示 UI 的；我有个对象叫DataStoreA，是用来存放数据的。那么此时，PageA就是客户端，DataStoreA就是服务器，我们来实现如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class PageA { // 从服务器获取数据 private DataStoreA dataStoreA; // 展示UI void showUI(){ String data = dataStoreA.getData(); uiTitle.setData(data); } } calss DataStoreA { String Data = \u0026#34;太阳当空照，花儿对我笑\u0026#34;; // 提供数据 public String getData() { return data; } } 代码也很简单，我们直接从DataStoreA中获取数据，显示在 UI 上就完事了。\n有人说了，你这不对啊，你这数据在内存中，一旦应用被杀死了，数据就没了，还显示个毛啊。\n别急别急，我代码还没写完呢。\n那我们就上完整版代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class PageA { // 从服务器获取数据 private DataStoreA dataStoreA; // 展示UI void showUI(){ String data = dataStoreA.getData(); uiTitle.setData(data); } } calss DataStoreA { String Data = \u0026#34;太阳当空照，花儿对我笑\u0026#34;; // 提供数据 public String getData() { // 从内存中获取数据 if(data != null) return data; // 如果数据为空，就从本地缓存中获取数据 data = getLocalData(); if(data != null) return data; // 如果数据为空，就从网络获取数据 String newData = requestData(); // 数据获取到了，更新到缓存 saveDataToLocal(newData); // 同时更新到内存 data = newData; return data; } } 这就是大体的代码逻辑，可以看到，我们一个页面有三个服务器，分别是：内存服务器、缓存服务器、网络服务器。其实这就是三级缓存，按照优先级来排名的。读取速度越快，优先级越高。\n这个代码有个好处就是：无论DataStoreA的数据从哪里来，PageA都不知道，它只知道有个getData()方法可以获取数据，这就是最少知识原则。\n其实，这里面有几个优化点。\n在DataStore的初始化方法内，可以提前调用getLocatData()方法，给data赋值，这样在获取数据的时候，就不用再读取了，就会快一点。 在saveDataToLocal()时候，如果数据比较大，我们就可以将其拆开保存，每次只保存变化的部分，毕竟保存文件也是一个耗时操作。 拆开保存数据属于粒度细化，这跟我们第 21 章要讲的单一职责原则和接口隔离原则有异曲同工之妙，核心都是粒度细化。\n有人说，那我第一次上来就断着网，你从哪缓存？\n这就没办法了，就算是巧妇，也难为无米之炊，所以必须要做一次网络请求。\n既然必须请求了，那么能省就省，我们就少请求一些吧。\n少请求 少请求有两层含义：服务器少返回数据，客户端少发请求。\n首先，根据上面我们说的，我们对数据要做个细化操作，也就是说：我需要啥你就返啥，别的别瞎返回。\n比如：我要这个人的基础资料，也就几个 kb 的数据吧。结果呢，服务器接口定义得不好，直接给我返回了他家一户口本的信息，他有 3 个妹妹、4 个姐姐、5 个哥哥、6 个弟弟，加上父母俩人，一共 21 个人的信息，好家伙！直接返回了 21 倍的数据，你说这能不慢吗？TCP 原来传输 1 秒就行了，你这一下传输 21 秒，数据到我这之后，我还要从里面挑选出来那个人的数据，能改就改、不能改就会议室见！\n所以，数据要细化，细化之后，返回的数据就少了，那么肯定就快了啊。\n我们还可以改下我们的数据格式，比如，使用 proto 而不是 json，图片采用 webp 而不是 png，对数据进行压缩，等等，总之，想尽一切办法减少数据量。\n再者，客户端要控制自己的请求次数，不能页面显示一次就请求一次，如果真的对实时性的要求比较高，可以采取 TCP 等长连接的方式，而不是客户端不断地发 HTTP 请求。所以，如果：\n对实时性要求高，就采用长连接的方式； 对实时性要求不高，就只请求一次，然后添加下拉刷新等方式让用户手动刷新。 我们也可以用数据共享的方式来减少请求次数，比如，我的 App 有个首页，会推荐几个陌生人给我；还有个二级页面，这里就显示完整的推荐列表，下拉可以显示更多陌生人。\n那么，我们就应该让首页的这部分和二级页面的这部分共用一份数据，首页加载前 20 条数据，并且显示出来，进入二级页面就直接显示首页的那 20 条数据，并且同时去加载下 20 条数据。这样以来，二级页面不但避免了一次加载，还会显示得更快，这就是数据共享。\n但是我的数据都写在页面里了啊，这让我怎么共享？\n谁让你写在页面里的？先把你的代码 MVC 一下再说吧。\n任何优化，都逃不过 MVC 模式，一定要做好数据和 UI 的拆分。\n其实，客户端请求的数据量就等于：请求次数 x 单次请求量，我们上面说的也正是针对这两点做的，但是这些都是针对开发人员的，如果我作为用户，我最在意的肯定是：快不快！然后才是省不省！\n那么，怎么让客户觉得快呢？\n提前请求！\n提前请求 提前请求我知道，就是页面还没点我就先把可能点击的页面的数据先请求过来准备着对吧？\n没错！但是不完全对。\n假如，有个列表页，每一条数据都有可能被点击，你难不成把显示列表的所有数据都加载出来吗？这肯定不可能的。\n再比如，一个页面上有 10 个按钮，每个按钮都可能进入一个新页面，你难道把这 10 个页面数据提前加载出来吗？也不可能。\n那么怎么办呢？\n我们先来做个分类，有 10 个按钮的那个页面，就是固定的 10 个页面，不会变化，我们叫做可枚举；而那个列表页呢，每次滑动的时候，都会变化，我们叫做不可枚举。\n对于可枚举的，我们就做埋点分析。我相信大部分公司的产品运营应该都有要求埋点的；我们可以默认拉取埋点占比最高的那个页面的数据，或者占比最高的前几个页面的数据。比如：这个页面总共显示了 100 次，其中按钮 A 被点击了 70 次，按钮 B 被点击了 10 次，按钮 C 被点击了 3 次。那么，按钮 A 的点击率是最高的。我们就可以认为每个用户进来都会点击它，所以我们就提前把按钮 A 对应的页面数据拉过来以备使用。\n这属于概率学问题了，肯定不能完美解决问题，比如用户不点就白拉数据了，但是这是已知的最优解了。\n那么，对于列表类的那种，埋点你都埋不了，你怎么办呢？\n对于不可枚举的，我们就做用户分析。因为列表都不可枚举了，埋个毛的点啊，所以，我们就找可枚举的，比如这个用户。首先，我们要针对这个用户做出行为分析，比如这个用户喜欢看什么类型的，然后，我就在当前列表中，挑选出最贴近这个用户喜欢的类型的，提前加载出来，然后就洗白白等着他点。\n什么，他没点？\n看来他喜欢的类型不包含这个，那就再记录下，下次就不提前加载这个了。\n这就是行为分析，也可以叫大数据杀熟，说白了就是根据你的操作，分析并记录你的行为习惯，然后做出推断，从而给你推送相关内容。\n有人说了，你这也太费劲了吧，如果我们没有埋点，也没有分析算法，这要怎么做呢？\n也是可以的！\n大部分人的代码大概是这样：点击启动页面，在页面的生命周期方法中去请求数据，数据过来后就渲染 UI。\n这一点都没错，只能说太矬了。\n我们假设，从点击启动页面开始，到页面的生命周期方法过来为止的时间为 t1，从请求数据开始，到数据过来为止的时间是 t2，那么，对于人眼来说，就是一共等待了t1+t2的时间。\n可不可以快点呢？可以！\n我们可以这样，点击启动页面的一瞬间，同时异步去请求数据，等到页面的生命周期过来后，判断数据是否已经请求到了，如果请求到了，就直接渲染 UI，如果还没请求到，就等待数据过来后再渲染 UI，这样花费的时间一共是max(t1,t2)。\n因为启动 UI 是在 UI 线程的，而请求数据是在工作线程的，并且它俩是没有资源竞争的，这样就可以利用多线程的优势来缩短时间，我们在第 14 章讲过这样的例子，这里就不废话了。\n这样需要一个前提：数据和 UI 分离。不然，如果数据先过来了，就会没地方存放，所以你看：MVC 是多么重要啊！\n有人说，你这有问题啊，如果我点击了页面，然后赶紧退出页面，这样你数据过来了页面已经没了，那数据怎么销毁呢？\n我们可以在数据仓库中添加标记，当页面销毁的时候，就设置这个标记，数据请求过来后就判断这个标记，然后清除数据即可。\n我们把可枚举和不可枚举的策略叫做预判加载，把点击时立刻去加载的策略叫做提前加载，我们可以同时使用预判加载和提前加载，比如：点击的时候就先判断，发现数据已经被预判加载过了，就不再执行提前加载了；如果没有被预判中，那就执行提前加载。这个策略是不是跟缓存策略有类似的地方呢？对比一下你就知道了，这里不再废话。\n总结 本章从实践角度讲解了网络请求的优化，核心就三点：尽量不请求，尽量少请求，尽量提前请求。\n尽量不请求：使用缓存避免无用请求。 尽量少请求：使用数据细化、数据压缩、数据共享等方式减少请求次数。 尽量提前请求：使用预判加载和提前加载减少用户等待时间。 好，本章到此结束，下一章，我们就要站在计算机角度，来彻底了解下我们朝夕相处的好朋友的工作方式了。\n19.知己知彼:计算机的工作流程 在第 6 章我们讲过代码的执行流程，我们知道代码是被编译成机器指令，然后在 CPU 中一条一条被执行的。\n那么，在这个过程中，计算机是怎么执行的呢？或者说，从代码被编写开始，到代码被运行出结果为止，这中间经历了什么呢？\n接下来我们就来了解下。\n另类的计算机定义 我们都知道，计算机是由控制器、运算器、存储器、输入设备、输出设备这五部分组成的。\n这太难记了，我们可以再宏观一些：计算机是由输入系统、输出系统、运算系统这三部分组成的。\n站在程序员的角度来说，我把我的代码输入给计算机，计算机自己计算后，把结果输出给我，这就完事了。也就是说，我并不知道计算机内部发生了什么，我只知道我给它数据，它计算，算完把结果给我，所以，对于我来说，计算机就是个黑盒子，它就有三个功能：接受输入、进行运算、输出结果，如此而已。\n这就不能叫冯·诺伊曼结构了，你可以叫它入算出结构，如果给点面子的话，你可以叫它奔波儿灞取经结构。\nOK，到这里，我们就知道计算机的三个核心功能了：输入、运算、输出。\n计算机的工作流程 那么，计算机的工作流程是什么样的呢？比如，我给它一段代码，它是怎么干的呢？\n从大方面看，就是三个步骤：\n读入你写的代码，也就是输入，至于怎么读，读到哪，先别管； 执行读入的代码，也就是运算，至于怎么运算的，也先别管； 将运算的结果展示出来，也就是输出，至于怎么展示的，也先别管。 好，大步骤我们知道了，我们就来看下每个小步骤是怎么执行的。\n输入 现在我打开编辑器写了如下代码：\n1 2 3 4 5 public class Hello { public void sayHello() { System.out.println(\u0026#34;hello, world\u0026#34;); } } 然后点击运行，结果就出来了。\n那么，这块代码是怎么被读入计算机的呢？\n首先，我们知道，我们写的这块代码是个后缀名为.java的文件，存放在我们电脑上的磁盘中。而代码要执行的时候，就会把它读入内存中，怎么读入呢？你可以理解为就跟普通的文件读写一样，通过 IO 操作读入内存中。好，现在我们的代码已经从磁盘中到内存中了，也就是已经完成了输入阶段了。\nTips：Java 代码具有跨平台性，.java 文件先被编译成.class文件，然后读入到 JVM 中，而 JVM 就是运行在内存中的。\n接下来，我们来看运算的过程。\n运算 现在，我们的代码已经在内存中了，接下来，我们就要开始运算了。\n第 6 章我们说过，计算机执行的是机器码，而我们读入的并不是机器码啊，这怎么可能执行呢？\n所以，我们运算的第一步，就是将非机器码转换为机器码，也就是我们写的代码，转换为 0110 这种二进制。其实，代码是先经过编译器转换为汇编语言，然后再经过汇编处理，才能变换为机器码。\n好，现在，我们的代码已经从自己写的语言变换为二进制了，那么接下来就是运算了。\n还记得我们第 6 章讲的机器指令吗，没错，这里的运算就要用到那些指令了。\n我们得到的机器码，里面就包含这些指令，以及这些指令要操作的数，那么，计算机就用这些指令来操作对应的数字，就得到了最后的结果，那么接下来，就只需要把这些结果输出就行了。\n等等等等，你这不对啊，你说的是单纯的数字计算和打印，比如我要是写个页面呢？页面最后得显示出来吧，那页面也是输出啊，这页面是怎么计算的？\n好，我们就来看页面（以下统称为 UI）的计算过程。\n首先，不管你是 UI 还是非 UI，你的输入过程都是一样的，都是将自己写的文件读入内存，然后转换为机器码，这个就不废话了。\n对于 UI 来说，我们把 UI 当成一块块的 UI 单元，也就是一个个的矩形块，这些矩形块有的显示文字，有的显示图像，有的只是单纯地用来排版其他矩形块，这个应该都能理解。\n不管是什么样的 UI 单元，其核心属性就是这么几点：\n尺寸，也就是宽高； 位置，也就是自己在屏幕上的坐标； 内容，也就是自己要显示的内容。 那么，UI 单元的内容是啥子呢？\n其实就是像素点！我们的 UI 单元是一个个的像素点组成的，可以理解为一个个的彩色小点，这些点都存储着自己的颜色值，是一个 32 位数字，高 8 位存储透明度值，接下来 8 位存放红色值，再接下来 8 位存放绿色植，最后 8 位存放蓝色值，所以也叫 ARGB。\n所以，我们的 UI 就像一张大纸，从上到下密密麻麻地铺满了很多小点，我们 UI 的绘制其实就是遍历一个个的小点，然后将对应的颜色取出来画到屏幕上而已。\n没错，正是这样！\n那这是谁画的呢？屏幕！\n那你运算器运算了啥啊？\n我们写的 UI 肯定不是写死的坐标，而是使用各种不同的布局，然后加上各种各样的内边距（padding）、外边距（margin）等来排版，这就是运算器要运算的了。\n再比如，我们写的宽高等不是固定值，而是包括内容、百分比等，这些也是 UI 要计算的。\n它会将我们写的这些边距、尺寸等，计算成复合当前屏幕的固定值，然后保存起来，交给屏幕去渲染。\nTips：其实图形的计算，不是 CPU 干的，而是 GPU 干的，因为 CPU 不适合做图像计算。\n所以，你 CPU 很屌但是玩游戏卡，就是 GPU 不行，因为游戏需要大量的图像计算，所以需要很屌的 GPU，也就是需要个好显卡。\n不管是谁算的，总之都是计算机算的，计算机将 UI 数据计算好后，会保存起来，保存到一个 Bitmap 上，或者说保存到一个矩阵中，然后交给屏幕去绘制。\n接下来就是输出了。\n输出 输出也分为两种：UI 类型的和非 UI 类型的。\n非 UI 类型的比较简单，我们直接从内存读出数据后，打印出来即可。或者直接将结果写到电脑文件上即可，这就意味着数据又从内存中回到磁盘中了。\n那么，UI 类型的呢？就比较费劲了，我们的屏幕需要定时从内存中读出数据，然后将其绘制出来，那为啥不是一次绘制呢？因为一次干不完啊。\n你这么理解，我们的 UI 数据在运算之后，保存到了矩阵中，我们的屏幕就定期从这个矩阵中从上到下，一行一行地读出数据，也就是像素点，然后将其绘制在屏幕上，这样的一屏幕数据，叫做一帧。\n那么，这个定期时间是多长呢？\n就看你的屏幕刷新率了，比如，如果你的屏幕刷新率是 60HZ，那就等于 1 秒内（1000ms）要绘制 60 次，也就是每 16ms 就要绘制一次（1000/60=16），所以这个定时时间就是 16ms；如果你的屏幕刷新率是 120HZ，那就等于 1 秒内绘制 120 次，所以每 8ms 就要绘制一次。\n所以，这个时间取决于屏幕刷新率。\n有人说，这 1 秒要绘制 60 次，那就意味着 CPU 在 1 秒内要计算 60 次啊，那它后面的数据不会把前面的覆盖了吗？\n比如，CPU 计算了第一帧，屏幕去绘制了，还没绘制完，CPU 就计算出了第二帧，然后把第一帧覆盖了，这不就乱了吗？\n没错，这样会乱，这个就叫做屏幕的撕裂。\n所以，我们就开辟了缓存，CPU 计算完一帧数据后，直接放在缓存中即可，屏幕画完就从缓存中取出下一条接着画。\n那你这缓存多大呢？比如你设置为 10，CPU 可能都计算了 11 条了，你这第 1 条还没画完，这不就还是覆盖吗？\n对啊，所以问题的核心是啥呢？是 CPU 和屏幕自己干自己的，速度不同步。\n你看，这是不是跟我们第 17 章中讲的 TCP 的停止等待协议很像呢？此时 CPU 是发送方，屏幕是接收方，屏幕来不及处理，CPU 就发送下一条数据了。\n所以怎么解决呢？\n停止等待协议！\nTips: 学会类比，举一反三，融会贯通，就能迅速扩大知识面，并且记得更牢。\nOK，我们也来让 CPU 和屏幕停止等待一下！首先 CPU 绘制完后，就将数据放进缓冲区，然后停下来等着；我们再让屏幕每次绘制完后，给 CPU 发个信号，告诉 CPU：劳资画完了，你可以开始了。这个时候，CPU 就继续绘制，并将新数据放入缓存中。\n那么，这个缓存的大小是多少呢？\n因为我们有两个同时干活的，所以缓冲区大小给 2 就行了，这样可以保证他俩同时工作。这两个缓冲区一个叫后缓冲，供 CPU 计算；一个叫前缓冲，供屏幕绘制。\nCPU 不断向后缓冲写入数据，屏幕不断从前缓冲取出数据绘制，绘制完就发送信号给 CPU 计算下一帧，CPU 接到信号后就交换前后缓冲数据，并接着计算下一帧数据。就这样循环往复，我们眼前就出现了不断变化的画面。\n这个信号就叫做 VSYNC，也就是垂直同步信号。\n总结 本章从宏观角度讲了计算机的工作流程：输入-\u0026gt;运算-\u0026gt;输出。\n输入：将磁盘上的文件读入到内存中。 运算：将读入的数据转换为机器码并执行。 输出：将执行的结果输出到磁盘或屏幕上。 并且，我们重点讲了 UI 类型的运算和输出过程，这里面有个很重要的点：发送方和接收方速率不同的情况下就采用停止等待协议，这其实可以高度抽离一下，也就是生产者消费者模型，这是一个很重要的模型，比方说本章的 CPU 和屏幕的关系，第 17 章的 TCP 协议中发送方和接收方的关系，还有第 14 章讲到的多个线程之间的资源竞争，都是需要等待和唤醒的。\n这就是类比思想，知识其实不多，就那么点，就看你是否能联想到一起，这一点我们会在后面的第 34 章专门讲解。那么下一章，我们就来看下计算机的内存设计和缓存设计是怎么实现的。\n20.缓存策略:让程序更快一步 在上一章中，我们讲了计算机的工作流程，我们知道计算机是通过：读入-\u0026gt;运算-\u0026gt;输出，这样的步骤来执行的。那么，这三个步骤都需要一个空间来存放数据，这些数据存在哪里呢？\n答案就是 内存！\n那么，本节我们就来彻底了解下计算机的内存是怎么设计的。\n计算机的内存 啥是内存呢？\n有人说，是这个：\n还有人说，是这个：\n其实都对，第一个是内存条，或者叫做物理内存；第二个是内存的地址空间，或者叫做虚拟内存。当然，对于程序员来说，直接面对的肯定是虚拟内存，而数据，却是实实在在地存储在物理内存上的，那就意味着，我们是通过虚拟内存来操作物理内存的。\n嗯，这个我们都知道，我们通过代码来操作虚拟内存地址，每个地址都对应物理内存上的一块空间，从而就间接操作了物理内存。\n没错。其实，我们的物理内存是一小块一小块的，就像一个小区的楼房一样，一间一间的，一层一层的，一栋一栋的；为了查找快一点，我们的内存不但进行了编址，还进行了分页，比如：这几块连起来的是第一页，那几块连起来的是第二页，就像小区的楼房一样，有单元、楼层以及门牌号。这个保存页面的信息就叫做页表，它也是要占用内存空间的，就像书籍的目录一样，也需要占用几张纸，这里就不废话了。\n那么，我们的物理内存是怎么存放数据呢？\n其实，我们的内存内部是由一个个的晶体管和电容组成的，为了简便起见，我们可以理解成是多个开关，开关打开就表示存储 1，开关关闭就表示存储 0，这样通过多个开关，就存储了一串串的 0 和 1，也就是二进制，比如要存放 a，a 的ASCII码是 97，二进制就是 01100001，所以关开开关关关关开就可以了。实际上操作的是晶体管，这里为了方便理解，所以用开关举例，但是道理都是一样的，都是通过电信号来表示二进制。\n好，道理都懂了，那么就有问题了：每次内存读写都要操作电路，这岂不是很费劲？因为按照我的理解，电路的操作不是很方便啊，开开关关的，听起来都不容易。\n没错！完全正确，电路的操作确实很费劲，我们在第 6 章讲过寄存器，寄存器的出现就是因为内存的读写速度太慢了。\n有多慢呢？是数量级的慢。这么说吧，假如 CPU 的运算速度是 S，内存的读写速度是 B，那么，B 就是 S 的高阶无穷小。也就是说：\nB÷S≈0\n伤害性大，侮辱性也高。\n那怎么办呢？我们让 CPU 慢点？等等内存？\n啥？那你的意思就是让考 100 分的下次考 60 分呗，从而去等等 60 分的同学？\n这肯定不行，那我们就来在 60 分和 100 分之间插入一个 80 分来起个过渡作用，让它看起来不是那么突兀，这个 80 分是谁呢？\n缓存！\n计算机的缓存 我们第 6 章已经讲过高速缓存了，我们知道，计算机内部的高速缓存位于内存和 CPU 之间，CPU 在执行时，先把数据读入高速缓存中，然后去执行，执行完后，再把数据写回到内存中。\n在第 13 章我们也讲过，内存是进程占有的，是线程共享的，而每个线程内部都有自己独立的缓存，线程在执行时，会先把内存中的数据读入自己的缓存中，然后在自己的后宫中进行一顿猛如虎的操作，最后再把数据写回到内存中晒给其他线程看。\n而从内存中读，线程自己操作，然后再写回内存中，这个流程，可能出现并发导致数据不同，这个可以通过加锁等待来处理，这就叫缓存一致性。\nOK，现在我们知道了，因为 CPU 速度比内存快，为了解决这个问题，我们引入了速度更快的缓存，但是引入缓存会导致数据不一致，所以我们通过缓存一致性协议来保证数据一致。\n那为啥不直接用缓存呢？不要内存了，数据全部写到缓存中不就行了？\n不行！\n因为缓存很小，比内存小很多。\n举个例子，你每次上厕所都要用纸，你大概似乎差不多会在厕所放一卷供自己用，没了就再去超市买。你肯定不会每次上厕所都去商店买几张，也不会直接把商店搬到厕所。这里的厕所就是缓存，商店就是内存。\n内存条我想你也见到过，比 CPU 还大，CPU 屁大点地方，你还想在里面塞一个内存条那么大的东西？而且缓存也不是越大越好，因为大部分场景下我们不需要那么大的缓存，比如你平时只玩扫雷，你却买了个 4090 的显卡，何弃疗呢？\n所以，不直接全部用缓存的根本原因有两个：\n缓存的成本很高，够用就行，没必要用那么大； 技术有限，无法在有限的空间内集成这么大的内存。 那么，缓存既然空间有限，如果我不小心用满了，该怎么办呢？\n删！只能删。\n删谁呢？看不顺眼的吗？\n这就要提到缓存清除策略了，我们来看看以下三种缓存清除策略。\n过期清除 在缓存数据时，设置一个过期时间，到了这个时间后，就清除这个数据。\n道理很简单，等于给每个数据一个寿命，寿命到了直接咔嚓，不问是非，不问原因，非常公平。\n那有人就不爽了，比如我这个数据很重要啊，我下了一部片子，看到一半就黑屏了，为啥？过期了！\n你这不是耍人玩吗，肯定不合适，公平是公平了，但是不合理，有没有那种我正在用的就留着的？\n有，就是大名鼎鼎的 LRU 缓存。\nLRU LRU（Least Recently Used）最近最少使用：优先清除最近没有用过的数据。\n也就是说，当缓存满的时候，优先去删除很久没有用过的最老的数据。\n假如有如下代码，我们要来设计 LRU 缓存：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 定义一个大小为3的集合 val list = ArrayList(3); list.put(1); list.put(2); list.put(3); // 获取第一个元素，也就是1 list.get(0); // 获取第二个元素，也就是2 list.get(1); // 存放元素4 list.put(4); // 存放后，集合内的元素是多少呢？ 当我们在存放第 4 个元素的时候，发现放不下了，那么就要删除一个元素。由于元素 1 和元素 2 是刚刚访问过的，那么元素 3 就是最近没有被使用的，那么就会删除元素 3，然后存放元素 4，所以最后集合中的元素就是：1、2 和 4。\n当然，如果我们没有获取过元素，而是直接存放元素 4，比如：\n1 2 3 4 5 6 7 8 9 // 定义一个大小为3的集合 val list = ArrayList(3); list.put(1); list.put(2); list.put(3); // 直接存放元素4 list.put(4); // 存放后，集合内的元素是多少呢？ 这样的话，元素 1 就是最近没有被使用过的（因为存放元素也算是使用），所以，根据 LRU，就会删除元素 1，存放元素 4，那么最后结果就是：2、3 和 4。\n可以看到，LRU 是非公平的，只管你最近一次的使用时间，我们可以这么理解：LRU 内部维护了一个队列，每次元素被使用都会进行排队，也就是将被使用的元素放在队列尾部，那么，最近没被使用的自然就跑到了队列头部，当缓存满时，就直接删除掉队列头部的元素。\n这个策略的核心是：最近被使用了，那么我就认为将来一段时间还会被使用，这确实满足了我们上面的要求。\n但是！如果我最近使用的那个是偶尔兴起呢？比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 定义一个大小为3的集合 val list = ArrayList(3); list.put(1); list.put(2); list.put(3); // 访问4次1，说明1很重要 list.get(1); list.get(1); list.get(1); list.get(1); list.get(2); list.get(3); // 直接存放元素4 list.put(4); 我们看到，1 在代码中被访问了 4 次，说明受众很高，将来大概率还会被访问，但是按照 LRU，却被删除了，这明显不对啊，那怎么解决呢？\n用 LFU！\nLFU LFU（Least Frequently Used）最不经常使用：它会将使用频率最低的数据删除掉。\n也就是说，LFU 会给每个缓存的数据设置一个计数器，每次数据被使用一次就将计数器加 1，当缓存满的时候，就删除掉计数器最小的那个数据。当然，如果有两个最小的呢？那就删除最老的那个。\n还是上面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 定义一个大小为3的集合 val list = ArrayList(3); list.put(1); list.put(2); list.put(3); // 访问4次1，说明1很重要 list.get(1); list.get(1); list.get(1); list.get(1); list.get(2); list.get(3); // 直接存放元素4 list.put(4); 此时，1 虽然是最老的数据，但是 1 是使用次数最多的数据，所以 1 不会被删除；而 2 和 3 都是使用次数最少的，但是 3 使用的时间要比 2 更新，所以就删除 2。这样以来，最后的数据就是 1、3 和 4。\n这明显是符合我们的预期的。\n我们的逻辑是这样: 如果一个数据被访问一次，我们就给它加 1 分，如果这个数据是最新的，我们就给它加 1 分，如果是老的，那就不加分，然后综合分数去做删除，这样，上面删的就是 2 了。\n这是什么策略呢？\n就是加权。我们给数据的访问次数和访问时间都定义一个权重，然后计算综合得分，得分低的就被删除。\n当我们遇到有多个因素对问题造成影响以至于无法抉择时，我们就可以使用加权策略，根据每个因素对问题的影响设置权重，最后给出一个综合得分，以此来决定取舍。\n其实，加权这个策略，我们在第 15 章的高优先权算法里也提及过，核心就是一个词：量化。\n总结 本章我们讲了计算机内存的设计和缓存策略，我们再来回顾下。\n计算机内存是采用电容和晶体管实现的，我们通过虚拟内存来操作物理内存。 内存速度很慢，所以我们要采用缓存来存放数据。 缓存很珍贵，容量有限，所以我们要选择合适的清除算法。 过期清除：给数据设置过期时间，到期就清除，很公平，但是不符合常理。 LRU：优先删除最老的没有使用过的，有利于保存新数据，但是不利于保存使用率高的数据。 LFU：优先删除使用最少的数据，有利于保存使用率高的数据，但是不利于保存新数据。 加权删除算法：根据自己的场景，赋予使用次数和时间不同的权重，灵活删除。 其实本章有两个核心思想：分页和量化。\n比如，数据要分页，为啥呢？能提高查找速度。计算机要加缓存，为啥呢？能提高访问速度。所以你看，缓存其实也是一种分页思想。数据在寄存器找不到，那么就到缓存找，缓存就是二级页。缓存找不到，就到内存中找，内存就是三级页面。内存找不到，就到硬盘找，硬盘就是最后的页面。所以，核心就是分页。这跟我们第 12 章讲到的哈希表元素的访问是一个道理。\n其次就是量化，一个问题被多个元素影响，那么就没办法采用满足每一个元素的策略，此时，就可以根据每个元素的影响力，赋予不同的权重，最后根据每个元素的权重得出综合得分，以此来判断取舍。这就是量化。用准确的数字来得出理性的结果，让你不再陷入感性的纠纷中，也是一种很重要的思想。\n那么，计算机的基础课到这里就完结了，下一章开始，我们将开始讲解编程的核心：设计思想。\n21.架构之基:从根上了解设计原则 设计模式不是必须的，但是如果你的代码是“非一次性的”，那么它就是必须的。\n对于大多数开发者来说，代码都是需要维护的，而不是写一遍就放起来不管了。既然需要维护，就要不断地读读改改，那就不是一次性的，那么怎么让他“读读改改”起来方便些呢？嗯，设计模式！\n设计模式切记不要死记硬背，不要生搬硬套，否则不如不学。而且不要一上来就说：要用 xxx 模式！需求还没出，你猴急个锤子，难不成是你刚学会这个模式，想拿来练练手，就想把它硬塞到需求里去吗？\n那么，如果需求已经出了呢？也别急，先想想，想好了怎么写，选择哪种设计模式；如果没有合适的，套不进去，那就别套了，只要方便维护，就是好的设计，不一定非要去套现有的设计模式。\n当然，要想正确地使用设计模式，还是先得透彻地了解了它们。因此，接下来我们就先来了解下设计模式的“祖宗”：六大设计原则。\n单一职责原则（SRP） 单一职责原则（Single Responsibility Principle，简称 SRP）： 一个类只干一件事。\n可以看到，单一职责的核心就是：只做一件事。不过，关键点就是这个“事”的范围不好定义。\n比如，写一个音乐播放器，一个类负责播放，一个类负责停止，这也满足单一职责。但是，这个职责太小了。那么，如果把播放、停止、甚至下载歌曲，都塞进一个类里面呢，那就太大了。所以，职责的范围很重要，只要确定好了这个范围，那这个原则就已经实现了 90%。\n那么，这个范围怎么确定呢？我们可以这么理解：一些相关的、关联性比较强的，就把它们当作同一种职责，放到一个单独的类（文件）里。\n那么，怎么确定是否相关呢？看需求！这个只能看需求，没有别的方法。如果需求没有明确，那么我们就要联系现实来决定，毕竟程序的本质就是模拟现实。\n比如，我在 2015 年实习的时候，IBM 公司有个考勤系统，需要添加一个指纹打卡功能。需求是这样的：部门主管以下的员工可以用指纹来打卡。\n那么，这个“打卡功能”是属于员工的，是属于打卡器的？换句话说，这个打卡的函数，是写在员工类里面呢，还是写在打卡器类里面呢？需求没说啊。\n那么，我们就联系现实来决定。\n在现实生活中，应该是一个打卡器放在门口，员工向打卡器录入指纹，来进行打卡，说白了就是：“员工使用打卡器来打卡”，也就是：“员工使用打卡器”“打卡器打卡”，所以，打卡功能是打卡器的，员工只是使用它的这个功能。所以，这个函数应该定义在打卡器里面，员工调用打卡器的这个函数来进行打卡。\n如果有人不爽，非要定义在员工类里面呢？你可以这么干。不过，后来需求改变成：非员工，比如保洁人员，也需要每天打卡签到。这时候，那位非常有个性有特色的人，估计脑瓜子嗡嗡的了吧。\n单一职责不仅可以用在类（文件）里面，也可以用在函数里面。\n比如，现在需要写一个校验函数，校验用户的性别和年龄，必须是 18 岁及以上的男性才有资格，很简单的我们可以这么写：\n1 2 3 public static boolean checkSexAndAge(boolean isMan, int age){ return isMan \u0026amp;\u0026amp; age \u0026gt;= 18; } 使用：\n1 2 3 4 5 6 private void login(){ if(checkSexAndAge(false, 17)) { tips(\u0026#34;不是18岁以上的男性\u0026#34;) return; } } 这里有人有意见了，说这样写不太好，因为每个校验的地方都要自己弹出提示，这样就是很多重复的代码，所以提示这个逻辑应该放在checkSexAndAge()这个函数里面去，也就是下面这样：\n1 2 3 4 5 public static boolean checkSexAndAge(boolean isMan, int age){ if(isMan \u0026amp;\u0026amp; age \u0026gt;= 18) return true; tips(\u0026#34;不是18岁以上的男性\u0026#34;); return false; } 这样简直美滋滋，任何时候只要直接调checkSexAndAge()就行，判断了还自带提示。这在目前当然是完美的，虽然方法名不太合适。\n如果有一天，我们的需求变成了：年龄不满足就开启未成年人保护模式，不需要弹出提示。我们直接删除tips()这个调用吗？这样不太好，如果别的地方也调用了这个方法，并且需要提示，就完了。所以我们应该有两个方法：方法 A 只检测，方法 B 使用 A 的检测结果并弹出提示。代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 判断加提示 public static boolean checkAndTips(boolean isMan, int age) { if(!checkSexAndAge(isMan, age)) { tips(\u0026#34;不是18岁以上的男性\u0026#34;); return false; } return true; } // 新方法，只做逻辑判断 public static boolean checkSexAndAge(boolean isMan, int age){ return isMan \u0026amp;\u0026amp; age \u0026gt;= 18; } 这里我们只抽离了一个方法，但是却反映出了单一职责的好处：职责越单一，因为修改而引起的问题就越少。换句话说就是：需求的粒度跟单一职责的优势成正比，需求越详细，越能看出单一职责的好处。所以我们要尽量避免大方法、大类、大模块，因为一个类越大，涉及的东西就越多，用到它的地方就越多，那么这个类就不能轻易修改，因为一旦修改，涉及的地方就越多，就越危险，所以我们一定要尽量避免。其实 MVC 就是一个宏观的、大的单一职责思想。\n单一职责不仅适用于类和文件，还适用于函数、模块等，这是一种思想，一定要掌握。\n里氏置换原则（LSP） 里氏置换原则（Liskov Substitution Principle，简称 LSP）：凡是使用基类的地方都必须能透明地使用子类。\n用人话说就是：用子类替换父类不会改变原有逻辑。众所周知，面向对象有三大基本原则：封装、继承和多态。子类本来就继承了父类，用到父类的地方替换成子类肯定没问题啊，这个原则不是废话吗，不一定！因为子类有自己的特色，也就是多态，如果这个特色太特色的话，就不适合了。\n比如，“我用电脑工作和游戏”，改成“我用苹果电脑工作，用联想电脑打游戏”，没问题！\n但是如果“我开车上班，坐车下班”，改成“我开玩具车上班，坐遥控车下班”，这个可能吗？\n但是，玩具车和遥控车也是“车”的子类啊，它俩也是车啊。\n那么这个问题出在哪里呢？明明所有的定义都是 OK 的。这是因为子类太特色了。\n我们定义的车，其出发点是“能跑”，也就是说，只要能跑的都是“车”，都是它的子类，所以，玩具车和遥控车都能跑，也都是车的子类。但是，车都能载人吗？猛一看，都能！仔细一想，玩具车不能！所以，我们上述 Demo 中用到的是车的“载人”功能，而不是车的“能跑”功能，所以，玩具车就不合适了。\n那么，怎么改呢？有如下两种方法：\n提取一个可载人的接口 interface IManned，明确表示哪些车可以载人； 提取一个二级父类 class MannedCar，表示该类车可以载人。 公共点就是：把“可载人”这个点明确出来。\n所以，里氏置换更简洁的说法就是：子类可以有自己的特色，但是不能太反常，如果子类的特色跟父类差太多，那么就应该细化父类或者剥离接口。\n可以看到，里氏置换原则就是对继承的校验，不恰当的继承关系就不满足里氏置换原则，所以，如果我们无法确定某两个类之间是否应该用继承关系时，就可以套用里氏置换原则来校验下。\n依赖倒置原则（DIP） 依赖倒置原则（Dipendence Inversion Principle，简称 DIP）：面向接口编程或面向抽象编程。\n依赖倒置的官方定义：高层不应该依赖底层，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。其实狭义的说就是：面向接口编程，广义的说就是：面向抽象编程。也就是说，我们在使用类的时候，优先考虑使用抽象类或接口。具体一点就是：成员变量、函数参数和返回值都尽量定义成接口。\n为什么要这么干呢？这么干有什么好处呢？\n我们知道，接口都是抽象的，抽象的就是不确定的，不确定的就是可变的。而我们的大部分代码都是“非一次性的”，也都是需要改变的，所以，接口正合适。\n换句话说，接口就是具有某种功能的某种东西，是什么我不管，只要具有这种功能就行，而我们需要的，也就是具有这种功能的东西。\n比如，我需要给手机充个电，我需要的是一个“能充电的东西”，而你却对外说：“我需要个充电宝！”如果有人没有充电宝，只有电源呢，他就不认你了。在这里，你把我需要的东西具象化了，也就是把范围缩小了，范围越小越精确，就越不容易改变，这明显是不对的。\n再比如，现在我要提供一个音乐播放器，我直接使用移动端的 MediaPlayer，很容易就写出了如下代码：\n1 2 3 4 5 6 class MediaPlayer { public void play(String path) {} public void stop(){} public void pause(){} public void resume(){} } 三分钟就写完了，使用方直接调用：\n1 2 3 4 5 6 7 class User { private MediaPlayer mediaPlayer; public void play(){ mediaplayer.play(\u0026#34;xxx\u0026#34;); } } 完事之后某一天，主管又问：“咱们的播放器不好用，能用那个开源的吗？”\n当然可以，于是就去改，但是发现，要改的地方太多了，我不但要改MedidPlayer这个类，甚至调用我播放器的人也需要改他的User类，我在别人眼里的段位又低了！\n这时候就应该反思了，其实User这个类，不在乎你的播放器是怎么写的，它只关心能不能播放、停止、暂停、恢复，说白了，它要的是一个具有这种功能的某种东西，而不是具有这种功能的这种东西。\n好，上接口！\n1 2 3 4 5 6 interface IPlayer { void play(String path); void stop(); void pause(); void resume(); } User使用：\n1 2 3 4 5 6 7 class User { private IPlayer player; public void play(){ player.play(\u0026#34;xxx\u0026#34;); } } 此时User只依赖于IPlayer，而不依赖具体的实现。不管你是啥，只要具有播放器的功能就行，后面不管你怎么改变IPlayer的实现，User都不需要改变。\n所以，我们可以看到面向接口的好处：低耦合，易拓展。因为接口是抽象的，依赖接口就是依赖抽象，不依赖细节，所以实现的细节怎么改都对我无影响，所以耦合就低；又因为接口是顶层的，就更容易拓展下层的细节实现。\n接口隔离原则（ISP） 接口隔离原则（Interface Segregation Principle，简称 ISP）：接口尽量小，尽量单一，说白了就是接口粒度要细。\n接口隔离要求接口的功能要单一，这听起来怎么就是单一职责原则呢，它们有区别吗？\n有！\n单一职责原则针对的是“职责”，说白了就是功能块，一个职责可能有多个功能；接口隔离原则针对的是“功能”，也就是一个接口只负责一个“功能”，比如，老师的职责是讲课和改作业，如果用单一职责原则就是一个接口里面包含了讲课和改作业这两个方法；如果用接口隔离原则就是两个接口，一个讲课的接口和一个改作业的接口。换句话说就是：接口隔离原则是单一职责的单一职责原则。\n举个例子，还是音乐播放器，我们定义了一个接口：\n1 2 3 4 5 6 7 8 9 10 11 12 interface IPlayer { //开始 void play(String url); //停止 void stop(); //暂停 void pause(); //复原 void resume(); //获取歌曲时长 String getSongTime(); } 这正是单一职责原则，因为这个接口只定义了音乐播放相关的东西，但是却不满足接口隔离原则，因为一个接口干了多件事，假如我们现在有个歌曲展示器SongDisplayer，只需要展示歌曲的时长，也就是只需要getSongTime()这个函数，我们让它直接实现IPlayer接口吗？肯定不行！因为里面的其他函数是不需要的，也不应该有的。这就要用到接口隔离原则了，我们直接将IPlayer接口再进行拆分，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //音乐播放器就仅限于对播放的控制 interface IPlayer { //开始 void play(String path); //停止 void stop(); //暂停 void pause(); //复原 void resume(); ... } //歌曲展示器就仅限于对歌曲信息的展示 interface ISongDisplayer { //获取歌曲时长 String getSongTime(); //获取歌曲名字 String getSongName(); //其他 ... } 这样拆分后，我们的播放器就同时实现上面两个接口，而歌曲展示器只需要实现ISongDisplayer即可。\n但是，我们根本不知道将来会出什么样的需求，怎么能提前预测并做好接口隔离呢？\n不需要提前做！因为接口隔离更多时候是个后置操作，说白了，更多时候是在问题发生的时候再去拆接口，所以是个后置操作，就像我们上面的修改，也没费多大劲，顶多就是多写一个接口，复制一部分代码，修改几个实现关系而已，根本没动业务上的代码，所以不必纠结，大多时候我们保证单一职责即可。\n总之一句话：接口要尽量小，尽量单一。\n最少知识原则（LKP） 最少知识原则（Least Knowledge Principle，简称 LKP），也叫迪米特法则（LOD）：一个对象应该对其他对象有最少的了解，说白了就是，只关联自己需要的。\n就像语文老师，只关心语文成绩即可，非要关心数学，怪不得头发都掉光了。\n废话不说，我们来看个 Demo，又是那个音乐播放器，原本应该是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 interface IPlayer { void play(String path) .... } class User { .... void play(){ player.play(song.path); } .... } class Song { public String path; public String name; .... } 可以看到，播放时，只需要一个path即可。但是有人聪明，我直接把Song给他传过去不行吗？这样后面万一需要Song里面的其他变量，比如name啥的，我也不用改函数了，好有道理啊！\n突然有一天，要求可以播放用户通过聊天发送过来的歌曲，这个歌曲没有名字，点击就下载到本地，只有一个路径了，这个时候你怎么办呢？你当然可以用这个路径去创建一个Song然后丢进去，但是这样绕了一圈不就增加了复杂度吗？再万一将来某天要修改Song这个类呢，你的播放器也跟着修改了。\n其实，播放器需要的只是一个播放的路径，至于其他的，它根本不关心。如果真的需要，你再提供，但也只需要提供它需要的，不要有任何附加内容。否则，一旦那些附加内容变化了，也间接导致播放器自身的变化，这是不应该的。\n我们应该只关联自己直接用到的，而不关联那些不需要的，如此一来，那些发生在我们关联范围外的事，就不会引起我们的任何改变，这样就大大提升了代码的健壮性。\n开放闭合原则（OCP） 开放闭合原则（Open Close Principle，简称 OCP）：一个类应该对扩展开放，对修改关闭。换句话说就是：应该多扩展代码，少修改代码。\n开闭原则是最理想的原则，是所有设计模式的最终目标，基本不可能实现。它要求我们的任何改动都不修改老代码，而只添加新代码，这样就不会对老逻辑有任何影响，从而使得代码更加安全。\n有人说，我们的代码不是一次性的，肯定是要修改的，怎么可能不修改呢？没错，肯定是需要修改的，但是合理运用开闭原则可以做到少修改，改得越少风险越小。\n举个例子，比如我在面试百度的时候，要手写一个计算器，只需要支持简单的加减法就行，如下：\n1 2 3 4 5 6 7 8 9 public class Calculator { public static int calculate(int left, int right, String option) { //加法 if(\u0026#34;+\u0026#34;.equals(option)) return left + right; //减法 if(\u0026#34;-\u0026#34;.equals(option)) return left - right; throw new IllegalArgumentException(\u0026#34;不支持的运算\u0026#34;); } } 代码简单粗暴，直接使用if判断就完事。但是，如果将来要支持其他运算呢？嗯，继续添加if分支？可以，但是不太好，谁能保证你下次添加别的运算符的时候，不会手残改了别的运算呢？那么，我们能不能将新的运算不放在这个类里面呢？可以！\n我们可以将每个运算定义成一个单独的类型，后面新增其他运算，只需要新加一个类就可以了。我们知道，基本的数学运算都是需要两个操作数和一个运算符的，我们可以定义一个公有的父类，来保存操作数和运算符。\n定义公共父类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public abstract Calculator { // 左操作数 protected String leftOpt; // 右操作数 protected String rightOpt; // 操作符 protected String operator; // 设置左操作数 public void setLeftOpt(String leftOpt) { this.leftOpt = leftOpt; } // 设置右操作数 public void setRightOpt(String rightOpt) { this.rightOpt = rightOpt; } // 计算，提供一个模板函数，供子类实现 protected abstract int calculate(); // 对外公开的获取结果的Api public String getResult(){ // 计算结果 String result = calculate(); // 清空操作数 clear(); // 返回结果 retrun result; } //清空操作数 public void clear(){ leftOpt = null; rightOpt = null; } } 加法器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class PlusCalculator extends Calculator { public static String OPERATOR = \u0026#34;+\u0026#34;; public PlusCalculator() { super(); this.operator = OPERATOR; } // 加法 @Override public String calculate() { return String.valueOf(Integer.parseInt(leftOpt) + Integer.parseInt(rightOpt)); } } 减法器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class SubCalculator extends Calculator { public static String OPERATOR = \u0026#34;-\u0026#34;; public SubCalculator() { super(); this.operator = OPERATOR; } // 减法 @Override public String calculate() { return String.valueOf(Integer.parseInt(leftOpt) - Integer.parseInt(rightOpt)); } } 这里我们为不同的运算符提供了不同的实现类，每个类只负责自己的计算逻辑，如果将来有其他新运算加入，我们直接再添加一个新的类即可，完全不需要修改其他类的代码。\n而且我们可以看到，开闭原则中用到了单一职责（每个类只做自己的运算），还用到了最少知识（每个类只关心自己的操作数和运算符），其实就是一句话：越单纯，越干净，越好！ 因为这样自己的责任就越少，就越不容易被牵连，也就越稳定，越安全。\n总结 本节我们从宏观层面讲解了六大设计原则，这是 23 种设计模式的祖宗，或者说：设计模式就是这六大设计原则的具体实现，六大设计原则就是设计模式的抽象。\n对于设计模式，我认为正确的学习顺序是：\n学习设计原则，这是对设计思想的宏观认识。 学习设计模式，这是对设计思想的具体认识。 再学习设计原则，这是对设计思想的自我抽象。 这就像我们看书的时候，先看目录，对整本书有个宏观的认识；然后仔细看每一章节，对每个模块进行具体了解；最后，也是最难的一点，就是：用自己的语言对整本书进行整体概括，然后尝试列出目录，这是对整本书的自我升华，或者叫自我抽象，这样，我们才能读到书的精髓。学习设计模式亦是如此，我们切记不要死记硬背，不要生搬硬套，不刻意设计的设计才是最好的设计。\n下一节，就让我们抽丝剥茧地一层一层剥开隐藏在常见设计模式的设计原则，从而对设计思想有个具体的认识。\n22.架构进阶:灵活运用设计模式 上一章中，我们从宏观层面了解了六大设计原则，设计原则是总纲，设计模式就是具体的实现。\n那么，本章我们就来深入了解下常见的设计模式，来看一看设计原则是怎么具像化的。\n单例模式 只有一个对象。\n在 LOL 中，你可以不会其他英雄，但是不能不会盖伦；在算法界，你可以不会其他算法，但是不能不会冒泡排序；在设计模式界，你可以不会其他的设计模式，但是不能不会单例模式。\n这说明它重要吗？\n不！这说明它段位低。\n所以我们要先把它干掉来摆脱低段位，从而进入高分局。\n单例单例，单一的实例，所以单例模式的目的只有一个：只有一个对象。\n那这个简单啊，我就创建一个对象保存起来，下次来取的时候，如果对象已经创建了，直接返回这个对象就行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public SingleInstance { // 定义一个对象 private static SingleInstance instance; // 获取对象 public static SingleInstance() { // 如果对象为null就创建，否则直接返回 if(instance == null) { instance = new SingleInstance(); } // 返回 return instance; } // 构造函数私有化 private SingleInstance(){} } 首先我们要把构造函数私有化，不然其他地方能随便new出来了，就不是单例了。那么既然私有化了，别的地方没法new出来，也就没法访问成员函数，所以只能访问静态函数，所以我们要提供一个静态函数来返回单例对象，所以，单例也要声明为静态的，因为静态函数只能使用静态变量。\n完事了吗？\n当然没有。\n上述代码在单线程中完全 OK。但是，免不了有多线程的情况啊，比如，两个线程 A、B 同时跑到：\n1 2 3 if(istance == null) { instance = new SingleInstance(); } 按照我们第 14 章讲的，A 和 B 分别把instance读入自己的缓存，然后判断都为 null，然后各自执行instance = new SingleInstance();，此时，已经不是单例了，已经创建两个了。\n所以说，上述代码不够完美，那我们要修改一下，我们的问题不再是单例怎么写了，而是怎么避免多线程了。\n很简答，排队啊，加锁啊，加锁就是synchronized呗。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public SingleInstance { // 定义一个对象 private static SingleInstance instance; // 获取对象，加锁 public static syncnronized SingleInstance() { // 如果对象为null就创建，否则直接返回 if(instance == null) { instance = new SingleInstance(); } // 返回 return instance; } // 构造函数私有化 private SingleInstance(){} } 这下就线程安全了。\n但是，我们前面说过，synchronized是悲观锁，效率偏低。其实我们仔细想想，加锁是为了避免多个线程同时创建对象，那就是说：如果不创建对象，就不需要加锁；而创建对象的前提是对象为 null 了。那不就意味着：如果对象不为 null，就不需要创建对象，也就不需要加锁吗？\n没错，那我们就来改下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public SingleInstance { // 定义一个对象 private static SingleInstance instance; // 获取对象 public static SingleInstance() { // 如果对象为null就创建，否则直接返回 if(instance == null) { // 锁放这里了 synchronized(SingleInstance.class) { instance = new SingleInstance(); } } // 返回 return instance; } // 构造函数私有化 private SingleInstance(){} } 现在我们的锁放在if内了，也就是意味着如果instance为 null 才会加锁，这样就不会出现白加锁的情况了，从而提高效率。\n唉，又出问题了。\n假如还是 A 和 B 俩线程，同时走到了if(instance == null)，发现为 null，于是都进入if块内，A 先执行，把对象创建出来，执行完后 B 再执行，B 执行的时候并没有再次去判断instance是否为 null，而是直接去创建。于是，又创建了俩对象，干！\n愁死了，那何以解忧呢？\n其实我们也分析到了，轮到 B 执行的时候，B 没有再次去判断instance是否为 null，那就再判断一次就行了。\n所以，我们的最终代码变成了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public SingleInstance { // 定义一个对象，加volatile，保证内存可见性。 private static volatile SingleInstance instance; // 获取对象 public static SingleInstance() { // 如果对象为null就创建，否则直接返回 if(instance == null) { // 锁放这里了 synchronized(SingleInstance.class) { if(instance == null) { instance = new SingleInstance(); } } } // 返回 return instance; } // 构造函数私有化 private SingleInstance(){} } 我们发现，我们一共做了两次判空处理，也就是做了两次检测（Double Check），并且加了一次锁（Lock），所以，我们就叫它：DCL 单例（Double Check Lock）。\n我们上面的代码中，instance变量需要用volatile修饰下，从而来保证内存可见性，这个属于语言层面的东西，这里不再废话。\n当然，单例还有很多其他方法的写法，据我所知就有 7 种（别卷了！），其实，万变不离其宗，只要你满足单一的对象，就足矣。\n那么，单例有啥用呢？为啥要写单例？\n比方说，我做了一个 App，我登录 App 后，我的信息全局是不是只能有一份儿？\n再比如说，我做了个直播间 App，我是不是同时只能进入一个直播间？\n那么我们找共性：只能有一个！\n所以就叫单例。\n或者你可以后发制人，你先不写单例，等到测试提 Bug 了：你这同时出俩数据，你这同时进俩直播间，等等。\n此时就可以考虑单例了。\n观察者模式 给我联系方式，我完事了通知你。\n观察者模式是用得最多的了，很多响应式编程，都是用观察者模式实现的。\n观察者模式的核心就是：A 发生了什么事，就告诉 B。这样 B 就能实时得知 A 的变化，就像 B 一直在观察着 A 似的，其中A就叫做被观察者，B就叫做观察者。\n我们来看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 定义一个观察者 interface Observer { // 定义一个通知方法 void notify(String msg) { } } // 定义一个被观察者 class BeObserver { // 定义观察者集合 private List\u0026lt;Observer\u0026gt; observers = new ArrayList(); // 添加观察者 public void addObserver(Observer observer) { if(observers.contains(observer)) return; observers.add(observer); } // 移除观察者 public void removeObserver(Observer observer) { observers.remove(observer); } // 自己发生变动 private void selfChange() { // 通知观察者 observers.forEach { it.notify(\u0026#34;寡人改变了，通知你一下\u0026#34;); } } } 我们的代码很简单，说白了就是：\n定义观察者和被观察者； 观察者需要提供联系方式给被观察者，用于被观察者变动时通知自己； 联系方式就是添加观察者addObserver()； 当被观察者发生变动时，就用观察者的联系方式通知它，也就是observer.noitfy()方法。 其实说白了就是：你把你给我，我发生了改变就调你的方法。\n因为，“你把你给我”就意味着我要持有你，这明显就是耦合了，可能发生内存泄漏，所以我们要提供一个你把你移除的方法，也就是移除观察者removeObserver()方法，用来在不需要的时候移除掉观察者。\n在写观察者模式的时候，我们一定要注意最少知识原则和依赖倒置原则，我们的观察者模式尽量定义成接口，并且一定要缩小范围，这样方便拓展。比如，我只需要一个通知功能，你却为了省事把对象整个传递进去了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 观察者定义成了对象，而且有很多没用的方法 class Teacher { public void notify(String msg){ } public void teach() { } public void write() { } } class Student { // 添加观察者，直接传递了具体的对象：Teacher public void addObserver(Teacher observer) { if(observers.contains(observer)) return; observers.add(observer); } // 自己发生变动 private void selfChange() { // 通知观察者，只需要用到notify()方法 observers.forEach { it.notify(\u0026#34;寡人改变了，通知你一下\u0026#34;); } } } 示例代码中，首先把观察者定义成了具体对象，而且里面有三个方法，但是我们的被观察者只需要调用notify()就足够了，不需要知道其他的方法，这违背了最少知识原则；其次，被观察者的addObserver()中，依赖了具体对象，而不是接口，这就意味着不好拓展，万一将来需要让校长、班长也可以观察呢？这违背了依赖倒置原则，所以我们需要改一下代码，改成如下的即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 定义观察者 interface Observer { public void notify(String msg){ } } // 老师实现观察者接口就行了 class Teacher implements Observer{ public void notify(String msg){ } public void teach() { } public void write() { } } class Student { // 添加观察者，传递接口 public void addObserver(Observer observer) { if(observers.contains(observer)) return; observers.add(observer); } // 自己发生变动 private void selfChange() { // 通知观察者，只需要用到notify()方法 observers.forEach { it.notify(\u0026#34;寡人改变了，通知你一下\u0026#34;); } } } 仅仅需要抽离出一个接口，把需要用到什么函数定义到接口里面即可，将来校长、班长也想观察，直接实现接口即可，是不是更 OCP 了？\n你看，这一点改动，差距立刻出来了。\n那观察者模式有啥用呢？\n比如说：A 页面需要知道 B 页面上的一个按钮是否被点击，点击了之后自己就要刷新；再比如：A 页面上弹出了编辑框，编辑的时候 A 页面要跟着编辑的内容更新。\n有人就说了：那这不就等于被观察者需要持有观察者吗？听着怎么有点别扭啊。\n非也非也，不是被观察者持有观察者，而是被观察者持有观察者的函数，以此来通知观察者。\n所以，观察者模式也叫做订阅-发布模式，观察者就是订阅者，被观察者就是发布者，发布者一旦发生变动，就通知订阅者，所以需要订阅者的联系方式，也就等价于持有订阅者的函数，所以就是：被观察者持有观察者的函数。\n凡是需要实时了解其他地方的变动的，都可以用观察者模式。\n责任链模式 沿着链路不断传递，直到有一个节点处理为止。\n这个很好理解：老板派发了一个任务，先发给部门主管，部门主管觉得自己不想处理，就向下派发给小组长，小组长想处理就处理了，不想处理就派发给员工处理，最后把事情处理掉。\n核心就是一个：在一个链上把问题解决掉。\n定义抽象事件处理者：\n1 2 3 4 interface EventHandler { // 处理事件，返回值表示是否处理成功 boolean handleEvent(); } 定义具体的事件处理者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 老板 class Boss implements EventHandler { } // 主管 class Manager implements EventHandler { } // 小组长 class Leader implements EventHandler { } // 员工 class Staff implements EventHandler { } 使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 定义责任链 List\u0026lt;EventHandler\u0026gt; handlers = new ArrayList(); // 添加事件处理者 handlers.add(new Boss()); handlers.add(new Manager()); handlers.add(new Leader()); handlers.add(new Staff()); // 处理事件 for(EventHandler handler : handlers) { if(handler.handleEvent()) return; } 可以看到，我们遍历handlers来处理事件，如果前面的人已经把事情处理了，就会直接返回，那么后面的就不用处理了；如果前面的没处理，那么就沿着这个链继续向下分发，最终把事情处理掉。\n有人说，如果都不处理呢？\n都不处理就出 Bug 了。所以，最后一个处理者一定是兜底的，一定要保证能把问题解决掉，所以，我们的事件处理者是有优先级的，效率高的排在前面，效率低的排在后面，但是最后面的一定是能把问题解决的。\n道理我都懂了，这有啥用呢？\n记忆这么差啊，我们第 18 章刚讲过的缓存，不就是责任链模式吗？当初我们是这么写的：\n1 2 3 4 5 6 7 // 从内存中获取数据 if(data != null) return data; // 如果数据为空，就从本地缓存中获取数据 data = getLocalData(); if(data != null) return data; // 如果数据为空，就从网络获取数据 String newData = requestData(); 也就是说，我们获取数据的顺序是：内存 -\u0026gt; 本地 -\u0026gt; 网络。\n这不就是责任链吗？\n我们就来改一下这个代码，让它更有段位：\n1 2 3 4 5 6 // 定义一个缓存处理器 interface ICache { String getData(); void cacheData(String data); } 然后来实现不同的缓存：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 内存缓存 class MemoryCache implements ICache { // 保存的数据 private String data; public String getData() { return data; } public void cacheData(String data) { this.data = data; } } // 本地缓存 class LocalCache implements ICache { // 这里就是读取本地文件，细节忽略 public String getData() { return getLocalData(); } // 保存到本地文件 public void cacheData(String data) { this.data = data; } } // 网络缓存 class NetCache implements ICache { // 这里可以用异步函数或者挂起操作 public String getData() { return getNetWorkData(); } public void cacheData(String data) { // 空实现即可 } } 然后就可以使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 List\u0026lt;ICache\u0026gt; caches = new ArrayList(); caches.add(new MemoryCache()); caches.add(new LocalCache()); caches.add(new NetCache()); // 获取数据 String getData() { String data; for(ICache cache in caches) { data = cache.getData(); if(!data == null) return data; } } // 保存数据 void saveData(String data) { for(ICache cache in caches) { cache.cacheData(data); } } 是不是很方便了？我们按照“内存缓存\u0026gt;本地缓存\u0026gt;网络缓存”这个优先级组成一个责任链，获取数据的时候，按照优先级来获取，如果前面的返回了数据，后面的就不需要执行了，并且保存数据也很简单，而且代码容易拓展了，如果将来有一天，我们有个新的缓存，就可以直接加在适当的位置，而不用改其他任何地方的代码。\n有人说，你这个网络缓存不需要保存数据啊，那就不应该实现ICache接口，或者应该将ICache接口拆分成两个，一个获取数据，一个保存数据，这样才满足接口隔离原则。\n完全正确！给你点赞。\n只不过我偷懒了而已，这个任务就交给你去实现了。\n总结 本章就到此结束了，我们本章重点讲了 3 个设计模式。\n单例模式：保证只有一个对象，要注意多线程环境下的单例问题。 观察者模式：被观察者的变动可以实时通知给观察者，要注意观察者要满足最少知识原则。 责任链模式：将事件沿着责任链分发，直到事件被处理为止。 其实，设计模式有很多，10 篇文章都讲不完。但是我们可以看到，设计模式都是由设计原则衍生出来的，也就是说，本来是没有设计模式的，写得多了，就觉得这样的场景太多，于是就把这个场景抽离出来，就成了设计模式，于是就有各种不同的设计模式，最后又发现，这些设计模式都要满足几条规则，也就是设计原则。我们要学，肯定是要学“根”，而不是学“枝叶”，有没有比设计原则更\u0026quot;根\u0026quot;的知识呢？\n有，设计思想，那么，下一章，我们就脱离设计模式，上升到设计思想的角度来看问题。\n23.架构升华:脱离设计模式 在上一章中，我们讲了三种常见的设计模式，这远远不够，设计模式有 20 多种呢，怎么学得过来呢？有没有别的法子能不学设计模式但是却能掌握设计思路呢？\n醒醒，别做梦了！\n虽然没有好办法，但是却有捷径，那就是设计思想。\n在我们的高中时代，要求等差数列、等比数列的前 n 项和，有裂项相消法、错位相减法等；而立体几何中，就可以作辅助线，其实设计模式就跟这些方法一样，都是技巧，是通过经验得出来的。\n那么，思想是什么呢？\n思想就是技巧的高度总结和归纳。\n比如：分类讨论思想、数形结合思想、类比思想等，思想是你遇到问题时可以挨个去尝试的。\n分层思想 将逻辑分层处理，不同层次之间有不同的职责，不存在跨层访问，从而降低耦合，职责清晰，容易拓展，容易复用。\n分层思想就是宏观的单一职责原则。\n每一层有自己的职责，也只负责自己的职责，每一层只使用上层的服务并向下层提供服务。\n最简单的例子就是我们第 16 章讲到的五层协议，每一层协议只对下层负责，不会出现跨层访问的情况。\n那么，分层有啥好处呢？我们上代码。\n假如我们要做一个语音直播间，在不分层的情况下，我们就把所有代码都梭哈到页面里面：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 calss PageVoiceLiveRoom { // 存储消息 private List\u0026lt;String\u0026gt; msgs = new ArrayList(); // 负责控制声音 private AudioEngine audioEngine; // 负责控制消息 private SocketEngine socketEngine; // 绘制UI void drawUI() { } // 打开麦克风 void openMic() { audioEngine.openMic(); } // 打开扬声器 void openSpeaker() { audioEngine.openSpeaker(); } // 发消息 void sendMsg(String msg) { socketEngine.sendMsg(msg); } // 收到消息 void onReceiveMsg(String msg) { msgs.add(msg); } } 写完感觉美滋滋，我直接把代码全部梭哈到页面上，代码良好运行，一点问题都没有。\n突然有一天，产品说要加个小窗功能，小窗的情况下页面不存在，但是声音和逻辑都在。\n\u0026hellip;\u0026hellip;\n我代码都写在页面上了，你这页面都没了，声音肯定也没了，还运行个毛。\n那这得改啊，不能全干在 UI 上，得拆开，UI 只处理 UI，其他的放在非 UI 上才行，这样的话，一旦页面销毁，也只是 UI 相关的销毁，声音和逻辑也都在，改吧。\n于是，就有了下面的代码。\n首先定义非 UI 逻辑，用来保存数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class VoiceLiveRoomData { // 存储消息 private List\u0026lt;String\u0026gt; msgs = new ArrayList(); // 负责控制声音 private AudioEngine audioEngine; // 负责控制消息 private SocketEngine socketEngine; // 打开麦克风 void openMic() { audioEngine.openMic(); } // 打开扬声器 void openSpeaker() { audioEngine.openSpeaker(); } // 发消息 void sendMsg(String msg) { socketEngine.sendMsg(msg); } // 收到消息 void onReceiveMsg(String msg) { msgs.add(msg); showMsg(msg); } } 然后定义 UI 逻辑，不再存储数据，只是负责展示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 calss PageVoiceLiveRoom { private VoiceLiveRoomData roomData; // 绘制UI void drawUI() { } // 打开麦克风 void openMic() { roomData.openMic(); } // 打开扬声器 void openSpeaker() { roomData.openSpeaker(); } // 发消息 void sendMsg(String msg) { roomData.sendMsg(msg); } // 收到消息 void onReceiveMsg(String msg) { showMsg(msg); } } 这样以来，UI 部分只负责展示数据和处理 UI 事件，不再存储数据。当 UI 销毁后，VoiceLiveRoomData会继续存在，并继续处理非 UI 部分的逻辑，比如存储消息。当 UI 再建立后，直接再次获取一次VoiceLiveRoomData即可，数据并没有缺失，声音也没有中断。此时PageVoiceLiveRoom就叫做 UI 层，VoiceLiveRoomData就叫做数据层，这也是 MVC 思想的核心。\n我们可以给它起名叫做：数形分离思想，数是数据，形是图形，也就是 UI。\n那么，代码这样就行了吗？\n不行！这并不能完美体现分层思想的优点。\n比如：现在我要做一个视频直播间，视频直播间包含了语音直播间的功能，怎么包含呢？\n很简单啊，直接新建一个VideoLiveRoomData，让它继承VoiceLiveRoomData就行了，子类通过继承可以复用父类功能。\n继承也是分层的一种体现。\n但是，如果我想做一个没有声音没有视频、只能打字的聊天室，要怎么办呢？\n这就不能继承了，因为它的功能太少了，它的功能是语音直播间的子集，所以，只能让语音直播间继承它。\n所以，我们要改代码，我们的层级应该是下述这样的。\nA：普通直播间，没有语音功能。 B：语音直播间，有语音功能，有 A 的所有功能，是 A 的下级，并且继承 A。 C：视频直播间，有视频功能，有 B 的所有功能，是 B 的下级，并且继承 B。 好，逻辑理清了，我们就上代码。\n普通直播间定义：\n1 2 3 4 5 6 7 8 9 10 11 // 普通直播间，只有打字功能 interface IBaseLiveRoomContext { void sendMsg(String msg); } class BaseLiveRoomContextImpl implements IBaseLiveRoomContext { private SocketEngine socketEngine; void sendMsg(String msg) { socketEngine.sendMsg(msg); } } 语音直播间定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 语音直播间，有普通直播间的所有功能，并且拓展了语音相关逻辑 interface IVoiceLiveRoomContext extends IBaseLiveRoomContext { void openMic(); void closeMic(); void openSpeaker(); void closeSpeaker(); } class VoiceLiveRoomContextImpl extends BaseLiveRoomContextImpl implements IVoiceLiveRoomContext { private AudioEngine audioEngine; void openMic() { audioEngine.openMic(); } void closeMic() { audioEngine.closeMic(); } //..... } 视频直播间定义：\n1 2 3 4 5 6 7 8 9 10 11 12 // 视频直播间，有语音直播间所有功能，并且拓展了视频相关逻辑 interface IVideoLiveRoomContext extends IVoiceLiveRoomContext { void startPreview(); void stopPreview(); } class VideoLiveRoomContext extends VoiceLiveRoomContextImpl implements IVideoLiveRoomContext { private VideoEngine videoEngine; // ....... } 我们看代码就知道，我们的层级关系为：\n其中，下级可以使用上级的所有功能，这就是分层的另一个好处：复用。\n这类似于树形结构，如果将来出了个新直播间 D，如果 D 具有视频直播间的所有功能，那么直接让 D 继承VideoLiveRoomContext即可，也就是放在VideoLiveRoomContext的下面；如果 D 没有视频直播间的所有功能呢，但是有语音直播间的所有功能，那么直接让它继承VoiceLiveRoomContextImpl即可。\n其实，我们的分层架构，就像是一棵树，新增的功能就是树上的一个节点，总有插入这个节点的地方。这里我们就不废话了，完整的业务代码，我们会在后面第 27 章实现。\n分层就是为了每一层能各司其职，互不影响，从而降低耦合，容易拓展。\n粒度细化思想 将大功能拆成一个个的小功能，越小越好。\n一个城市可以拆分成一个个的县，一个县又能拆成一个个的乡，一个乡又能拆成一个个的村，一个村又能拆成一个个的家庭，一个家庭又能拆成一个个的人，如果把城市比喻成沙漠，那么一个个的人就像一粒粒的沙子，这就是粒度细化。\n这样有啥好处呢？\n比如，我有个模块 A，包含了功能 B1 和 B2，假如，我只想使用 B1 功能，如果模块 A 没有拆分的话，我必须依赖模块 A，这样就可以使用 A 里面的 B1 了，但是这样导致我也依赖了 B2 了，如果将来 B2 有改动，我就不得不跟着变化，这明显是不好的，违背了最少知识原则，也不满足开放闭合原则。\n所以，我们要对模块 A 进行拆分，拆分成 B1 和 B2 两个部分，这样，我只需要依赖 B1 即可，B2 的任何改动都不会对我造成任何影响。\n所以，你看，粒度细化是不是宏观的接口隔离原则？接口隔离原则要求接口尽量小，而粒度细化要求模块尽量小。\n那么，粒度是不是越细越好呢？\n不是！\n比如，一个人的基本功能是吃喝拉撒，你把这四个功能定义给一个人就行，而不需要把每一个功能都单独定义，因为这样就不符合现实了。\n所以，粒度的大小要符合常规逻辑。\n而且我们会发现，粒度细化思想也是宏观的最少知识原则，因为功能拆得细，所以跟自身无关的业务就不再包含到自身，比如上述的 B1 就跟 B2 没关系，那么其他模块使用 B1 的时候，也不会跟 B2 有关联，这不正是最少知识原则的体现吗！\n易变性思想 把我们的代码写成容易修改的。\n还记得我们第 5 章讲过的吗：优先选择容易变化的数据类型。其实这就是易变性思想的体现。\n我们在写代码的时候，一定要优先设计成容易变化的，优先使用接口而非对象，优先使用集合而非单一数据。\n比如，现在我有个送礼接口，那么我就定义成：\n1 2 3 public void sendGift(long uid,Gift gift) { } 其实没毛病，但是，将来有一天，产品要求可以多人送礼，也就是一个礼物可以送给多个人。有人说：这简单啊，遍历用户集合调用这个接口就行了啊。\n……来啊，叉出去！\n如果有 10000 个人呢？你遍历调用 10000 次吗？你家流量不要钱吗？\n所以，我们应该是将上述的uid定义成一个集合，也就是：\n1 2 3 public void sendGift(List\u0026lt;Long\u0026gt; uids,Gift gift) { } 这样一来，送一个人还是多个人，都没有问题。\n所以你看，采用可变的数据类型，是不是减少了工作量。\n再看个例子：\n1 2 3 4 5 6 7 8 9 public void handleInput(String input) { if(\u0026#34;Java\u0026#34;.equals(input)) { doJava(); } else if(\u0026#34;javascript\u0026#34;.equals(input)) { doJS(); } else if(\u0026#34;python\u0026#34;.equals(input)) { doPython(); } } 相信大家都写过这种if-else语句，如果条件非常多的话，那简直不要太酸爽；如果条件非常多并且还要加条件的时候，那简直不要太\u0026quot;好欢螺螺蛳粉\u0026quot;。\n这肯定不行啊，不满足开放闭合原则，那就改。\n我们使用map来优化下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 定义一个map Map\u0026lt;String, Runnable\u0026gt; actions = new HashMap(); // 将key和value存放在map中 actions.put(\u0026#34;Java\u0026#34;, {doJava()}) actions.put(\u0026#34;javascript\u0026#34;, {doJS()}) actions.put(\u0026#34;python\u0026#34;, {doPython()}) public void handleInput(String input) { if(actions.containsKey(input)) { actions.get(input).run(); } } 我们的函数处理是不是非常简单了，而且也很容易修改，如果将来有添加或者删除，我们只需要在map中添加或者删除就行了，不需要改其他地方，这不正是开发闭合原则吗。\n再比如，我们第 21 章讲到的依赖倒置原则，要求我们尽量依赖接口、依赖抽象，而不是具体的对象。\n综合上面所有的例子，List、Map以及接口，它们的共同点都是可变。\n所以，我们要面向可变编程，这就是易变性思想。\n有人说，这跟依赖倒置原则有啥区别呢？\n依赖倒置原则只描述了对象之间的关系，而我们的代码中，除了对象还有函数，还有变量，还有模块等，而这些都可以用易变性思想来描述，或者说：易变性思想是宏观层面的依赖倒置原则。\n其实，易变性思想也可以叫做面向拓展编程，或者叫面向未来编程。\n代码越容易改变，将来发生改变的时候就越容易修改甚至不需要修改，这就是易变性带来的好处。\n总结 本章我们讲了 3 个设计思想，我们再来回顾下。\n分层思想：将逻辑分层处理，不同层各司其职，从而降低代码耦合性，提高拓展性。分层思想就是宏观的单一职责原则。 粒度细化思想：将功能拆分成一个个更小的小功能，从而提高利用率，降低耦合性。粒度细化思想就是宏观的接口隔离和最少知识原则。 易变性思想：采用易变的数据类型和接口，来将代码写成容易修改的，从而提高拓展性。易变性思想就是宏观的依赖倒置原则。 我们发现，每一种思想都是多种设计原则的体现，我们写代码的时候就不需要纠结：到底用哪个设计模式啊？这完全没必要，符合自己的设计才是最好的设计，就像我们上述讲到的直播间架构，它是什么设计模式呢？都不是！但是它却完全符合我们的项目，这就是无招胜有招。\n设计模式只是提供了个模板，属于一种模型，是有限的，有限的模型不可能满足无限的情景，所以我们不必执着于固定的模板，只需要满足：拓展性强，影响范围小。就足够！\n真正的设计师都是先捋清逻辑，想好方案才下手写代码的，那么下一章，我们就来学习设计师必备的基本功：UML 图的绘制。\n24.硬基本功:对象的关系与UML图 在面向对象思想中，对象的基本关系可以分为：泛化、实现、依赖、关联、组合、聚合。\n泛化 泛化的标志为实线三角形，如下：\n表现在代码层面就是继承（extends），三角形指向的是父类，简单记忆就是：实线三角指向父类，上图就表示 B 继承 A。\n实现 实现的标志为虚线三角形，如下：\n表示在代码层面就是实现（implements），三角形指向的是接口，简单记忆就是：虚线三角指向父接口，上图就表示 B 实现 A。\n泛化和实现的区别 泛化表示的是一种本能，表示是什么，是与生俱来的，比如A extends B，那么 A 就是 B，也就是 is 关系。 实现表示的是一种扩展关系，表示可以干什么，是后天的，比如A implements B，表示 A 拥有 B 的功能，也就是 A 可以做 B 能做的事，也就是 has 关系，但是 A 却不是 B，它只是拥有 B 的本领而已，这是一种扩展关系。 泛化和实现都表示类之间的一种纵向关系，这是一种 单向的上下级关系，A extends/implements B，B就不可能extends/implements A。正是这种严格的上下级关系，保证了进行面向对象设计时边界是正确的、清晰的。\n关联 关联的标志为实线箭头，如下：\n表示在代码层面就是成员变量，箭头指向的是被关联类，简单记忆就是：实线箭头指向被关联，上图表示 B 关联 A，也就是 A 是 B 的成员变量。\n依赖 依赖的标志为虚线箭头，如下：\n表示在代码层面就是局部变量（包括局部变量、函数参数以及返回值），箭头指向的是被依赖类，简单记忆就是：虚线箭头指向被依赖，上图表示 B 依赖 A，也就是 A 是 B 的局部变量。\n关联和依赖的区别 关联表示的是一种强依赖关系，这种关系是长期的，表示在代码层面就是成员变量，我们知道：成员变量的生命周期一般和持有它的对象是相同的。 而依赖表示的是一种临时的关系，表示在代码层面就是局部变量，我们知道：局部变量的生命周期都是跟随方法的，从方法入栈开始到方法出栈为止。 所以，关联的生命周期要大于依赖的生命周期，换句话说，关联是一种“强”依赖，或者说是一种“长”依赖。\n关联和依赖的相同点就是：“它们都表示类之间的一种 横向的平等关系”，依赖和被依赖、关联和被关联的两个类之间不存在上下级关系，可以是 A 依赖 B，也可以是 B 依赖 A，这是一种平等的关系。\n组合 组合的标志为实心菱形，如下：\n表示在代码层面跟关联是一样的，也是成员变量，但是关联表示的是平等关系，而组合表示的是一种整体-局部关系，菱形指向的是整体，简单记忆就是：实心菱形指向整体，上图表示 A 持有 B，也就是 B 是 A 的一部分，这是一种强关联，B 不能脱离 A 而存在。\n聚合 聚合的标志为空心菱形，如下：\n表示在代码层面和组合是一样的，只能从语义层级来区分，聚合跟组合的唯一区别就是：聚合对象可以独立存在，组合对象不能独立存在，比如上图，B 是 A 的一部分，并且 B 可以脱离 A 而存在。简单记忆就是：空心菱形指向整体。\n组合/聚合、关联/依赖的区别 组合跟聚合都是一种“强关联”，表示一种“整体-局部”的关系，被组合的类不能独立存在，比如数据库和数据表，没有数据库肯定没有数据表；而被聚合的类则可以独立存在，比如汽车和轮子，轮子可以脱离汽车而存在。它们两个的区别只能从语义方面划分，换句话说：组合是一种强聚合。\n再来看聚合和关联，聚合一定是关联关系，而关联是一种强依赖，所以聚合也是依赖；而组合是一种强聚合，所以组合也是依赖。所以：组合是聚合，聚合是关联，关联是依赖。只不过它们的耦合强度不同，整体来说就是：组合\u0026gt;聚合\u0026gt;关联\u0026gt;依赖。从设计层面来说，依赖和关联表示的是两个类之间的一种“横向平等”的关系，而组合和聚合表示的是两个类之间的一种“整体-局部”的关系，它们描述的维度不同，这个需要在设计的时候从语义层面来区分进而决策。\n总结：泛化/实现表示的是一种纵向的上下级关系；依赖/关联表示的是一种横向的平等关系；组合/聚合表示的是一种“整体-局部”的关系。\nUML 图实践：观察者模式 观察者模式的定义很简单：A 观察了 B，B 改变了就会通知 A，A 就可以收到 B 的通知。因为 B 要通知 A，所以 B 肯定持有 A，也就是说：被观察者持有观察者，这听起来有点儿不太对劲。那我们可以理解为：订阅/发布模式，A 是订阅者，订阅了 B，B 肯定要有 A 的联系方式，等到 B 改变了，就通过 A 的联系方式通知 A，这里 A 的联系方式就是 A 对象的引用，B 持有 A 的引用，等到自己发生改变了，就通过 A 的引用来调用 A 的方法从而通知 A，我们称订阅者 A 为 Observer，被订阅者 B 为 Subject。\n理解了类的基本关系之后，我们来看观察者模式的类图，说实话，设计模式的精髓就在于类图，而不是代码。直接上图：\n图很简单，我们一点一点来看。\n看 Subject，有 abstract 标记，说明是个抽象类，里面有 3 个 \u0026ldquo;+\u0026rdquo; 修饰的方法，说明有 3 个 public 的方法，我们可以直接写出代码： 1 2 3 4 5 public abstract class Subject { public void attach(Observer o); public void detach(Observer o); public void notify(); } 同样看 Observer，它是个 interface，可以写出如下代码： 1 2 3 public interface Observer { public void update(); } 再来看两个具体类，我们看到了“泛化”和“实现”的标记，分别表示继承和实现，于是可以写出： 1 2 3 4 5 6 7 public class ConcreteSubject extends Subject { } public class ConcreteObserver implements Observer { } 最后，我们看到了那个“聚合”的标记，它表示 Observer 是 Subject 的一部分，也就是说，Observer 是 Subject 的成员变量，并且是 1:n(n\u0026gt;=0) 的，既然是 n 个，说明是个集合，那么 Subject 内部持有一个 Observer 集合，于是我们修改 Subject 的代码： 1 2 3 4 5 6 public abstract class Subject { private List\u0026lt;Observer\u0026gt; observers; public void attach(Observer o); public void detach(Observer o); public void notify(); } 再进一步，我们根据观察者模式的定义，知道核心功能为：注册、移除、通知，于是我们可以写出最终代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public abstract class Subject { // 观察者集合，根据类图的“聚合”推出 private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;\u0026gt;(); // 添加观察者，根据观察者模式的定义推出 public void attach(Observer o) { if(o == null) return; observers.add(o); } // 移除观察者，根据观察者模式的定义推出 public void detach(Observer o) { observers.remove(o); } // 通知更新，根据观察者模式的定义推出 public void notify() { for(Observer o: observers) o.update(); } } 于是我们就得到了最终的顶层代码的实现，至于具体的逻辑，就要视具体的业务逻辑来实现了。\n到这里，估计有小伙伴就会有如下疑问了。\n为什么是聚合而不是组合？\n因为 Observer 可以脱离 Subject 而存在，组合的前提是：B 不能脱离 A 而存在，换句话说：要想有 B，必须先有 A。而我们要创建 Observer，显然不需要有 Subject，所以不需要组合。\n那么为什么是聚合而不是关联？\n可以是关联！因为聚合本来就是强关联，但是不准确，我们知道，关联表示的是一种平等关系，如果 A 关联 B，B 也能关联 A，而在观察者模式中，显然是被观察者通知观察者，而不是观察者通知被观察者，所以显然应该是：被观察者持有观察者，反之则不行（因为没法 notify 了）。所以，用聚合更准确！\n为什么 Subject 定义为抽象类，而 Observer 定义为接口？\n我们知道，抽象类使用的是泛化，而泛化表示一种本能，是天性，我们的 Subject 本来就是用来被观察的，而不是“可以被观察的”，因为如果“可以被观察的”，那么也就“可以不被观察”，这样的话，如果某个地方真的“不被观察”了，也就是不实现 notify() 方法了，那么它就失去了最基本的功能，失去了本能，那么它就没有存在的意义（不能更新要它何用），这是不对的。所以我们用更加“强硬”的泛化来明确表示出“它的本能”，必须实现！\n而 Observer 定义为接口，表示“拥有”这个能力，也就是说：可以观察，也可以不观察，当需要的时候，就实现这个接口来表示拥有观察的能力，否则就不实现这个接口，这不是强制的，而是可选择的，所以我们定义为比较“弱势”的接口来表示它的这种后天的扩展的能力！\n观察者模式有什么缺点呢?\n很明显，被观察者采用了聚合的方式持有了观察者，notify 的时候通过遍历的方式向下分发结果，那么如果遍历过程中一个 observer 出现了异常，就会导致后续 observer 接收不到通知！怎么解决呢？我们可以将每一个 notify 的调用添加保护，比如：\n1 2 3 4 5 6 7 8 9 public void notify() { for(Observer o: observers){ try { o.update(); }catch {Exception e} { // 处理异常 } } } 这样可以解决，但是还有问题，比如后续的 observer2 依赖于前面的 observer1 的结果，而 observer1 没处理完就抛出了异常，那么 observer2 得到的结果就是错的，这样可能导致连缀问题！所以，需要在设计的时候充分考虑，采取合理的方案。 总结 本节我们着重讲了对象之间的六种关系以及它们的 UML 图的绘制，如下。\n泛化：也就是继承，实线三角形指向父类。 实现：也就是接口实现，虚线三角形指向父接口。 关联：也就是成员变量，实线箭头指向被关联。 依赖：也就是局部变量，虚线箭头指向被依赖。 组合：也是关联，强调整体-局部关系，局部不可独立存在，实心菱形指向整体。 聚合：也是关联，强调整体-局部关系，局部可独立存在，空心菱形指向整体。 大家可以在理解的基础上去记忆，下一节，我们就着重讲解需求的分析和大纲设计。\n25.软基本功:需求的评估与反馈 在上一章中，我们讲解了对象的 UML 关系图，根据这个，我们可以绘制出类图，以此来实现我们的顶层框架设计。\n当然，我们的所有代码都是为需求服务的，本章我们就来看一下需求设计是怎么评估的，又应该怎么对需求的不合理地方进行反馈。\n需求分析 其实，在需求分析之前，是有个可行性分析的，可行性分析是分析软件的可行性，也就是：能不能做，值不值得做。比如：我想要造个时光机，这不可能做；我想要造个打败微信的 App，能做，但是不值得。所以，这两个就是不可行的，想出这样需求的人建议直接叉出去。\n当然，可行性分析是产品经理负责的事，跟我程序员没半毛钱关系。而程序员要参与的第一道工序，就是需求分析。\n需求分析是干啥的？\n需求分析是软件开发的第一个阶段，它最基本的定义是规定我们要做什么。\n也就是说，如果没有需求分析，程序员是处于懵逼状态的，没价值的，自己都不知道自己要干什么。直到需求分析出来后，程序员才知道自己要干啥，才有了与产品经理 PK 的矛盾点。\n总的来说，需求分析分为两大类：功能需求和性能需求。\n功能需求 功能需求指的是：提出新功能，来吸引一部分新用户。\n这个就很好理解了，比如：我们要做一个 App 的直播间需求，这个需求是现在没有的，需要从头实现的。这就是功能需求。\n对于参加功能需求的每个人来说，他们的心理期望大致如下。\n产品经理：我这需求总算是出了，我要讲给他们听，希望他们不要有太多意见，免得我脸上挂不住，最重要的是，希望他们的工时估测能尽量短一下，能尽量早地估出来，另外，希望上线后能迎来一大波新增用户。这样我的绩效就有指望了，季度的 OKR 也可以吹吹了。\n新增用户指的是：新安装 App 或者使用新功能的用户数量。\n程序员：今天要开需求会议了，希望他的这个地方能商量下改一改，毕竟这一块不好做，希望工时能估长点，毕竟不确定的因素太多了，希望测试期间能少点 bug，上线后也别出 bug，最好能迎来一大波新增用户，这样我的年终奖就可以多一些了，毕竟只有我们部门整体增长，年终奖才能多一些。\n测试：这个需求我看过了，发现了几个问题，待会儿在会议上就提出来，完善我的测试用例，并且让产品和开发意见一致，免得他们理解偏差导致开发的和需求不一致，进而导致我这边测试时间延长，希望开发能如期提测，也别出那么多 bug，考虑得全面点，能考虑到我没考虑到的，线上也别出问题，能迎来一波新增用户最好，这样我的季度 OKR 就有指望了，也有底气参加年度优秀员工了。\n到这里，我们可以总结一下每个人的期望。\n产品：讲解需求，期待上线时间。 开发：评估需求，输出提测时间。 测试：评估需求，输出上线时间。 所以，这里我们就连上了，需求-\u0026gt;开发-\u0026gt;提测-\u0026gt;测试-\u0026gt;上线。\n这里面有三个时间点：需求评估时间、提测时间、上线时间。\n其中需求评估时间之前都是产品在忙活，忙活着输出需求文档；需求评估时间到提测时间这段时间主要就是开发在忙活，忙活着写代码实现功能；而提测时间到上线时间这段时间就是开发和测试一起忙活，测试提 bug，开发补 bug。\n可以看到，对于我们程序员来说，主要的工作时间就是：需求评估之后到上线之前。\n而且，我们知道，产品、开发和测试，都有一个共同点：新功能能迎来一波新增用户。\n所以，我们到这里就可以理清功能需求的目的了：新功能能带来一部分新增用户。\n比如说：我看到别人在玩微信的跳一跳功能，我发现很有趣，我就装了微信，于是我就成了一个新用户。\n那么，如果玩了之后，我发现它很卡，我想卸载了，这个时候，怎么让我不卸载呢？\n嗯，这就涉及到性能需求了。\n性能需求 性能需求指的是：优化现有的功能，来留住一部分老用户。\n这个也很好理解，比如：我们的直播间太卡了，用户点击一下得等个 10 分钟才能进去，结果有的人进去发现都直播完了，退出还得 10 分钟，人家就直接去 0 星差评加卸载了。于是产品就让优化下，这就是性能需求。\n其实，你可以在你的代码里，时不时偷偷来个Thread.sleep(10_000)，这样创造需求，后面产品必定要提出性能优化需求，你再把它删掉就好了，但是你要假装忙了很久很久。\n当然，我个人是不建议这么干的，这是互联网，大家都是读书人，懂得都懂。\n比如微信的跳一跳功能，如果太卡，那么用户就会失去兴趣，就不玩了，第一天可能有 100 个用户玩，第二天只剩 50 个了，我们用第二天的用户数量除以第一天的用户数量可以得到存留率，这里的存留率就是 50%。\n所以，一个常规的套路就是：先快速开发一个新功能抢占新增用户，然后再逐渐优化这个功能来提高用户的存留率。比如，我先快速更新一个跳一跳功能，有 bug 也没事，反正能带来用户就行；然后，我再去优化这个功能，比如：提高加载速度，提供不同的青蛙模型等。\n所以，性能优化的主要目的就是：提高老用户的存留率。\n这些内容好像都是产品的工作，好像跟我们程序员没关系啊？\n有关系！\n程序员视角的需求分析 对于程序员来说，最重要的就是需求分析会议了，因为你接下来要做什么，都是在这里决定的。\n因为大部分产品都是不懂技术的，他们提出的需求都是默认程序员动动手就能实现的。\n比如，对于移动端来说，99.999% 的产品都是抄袭现有功能，而且抄袭的目标对象是苹果手机，大家都知道，苹果手机是不开源的，而且系统自带一些动画，差劲的产品就会让 Android 程序员仿写一个相似的动画，WQNMLGB！\n因为我们知道，不同的系统有不同的体验，久而久之就成了习惯，比如：我用 Android 手机返回键久了，就改不回去了，如果一个产品无视 Android 用户的习惯，直接想强制 Android 程序员仿照苹果手机的操作习惯去实现相关功能，那么这个产品就是个差劲产品，就是不合格的，我希望我们能少一些这样的人，而多一些有包容心的人；大格局的人；有意义的人；高尚的人；纯粹的人；有道德的人；脱离了低级趣味的人；有益于人民的人……\n换句话说，你怎么不让苹果添加一个返回键呢？你怎么不让 IE 浏览器添加一个开发者模式呢？\n对于这种需求，你要大胆地说：No！No！No！\n如果你现在不拒绝，那么以后你就更难拒绝了，因为他会说：那上一次的怎么就能实现呢？人性的恶是远大于人性的善的。\n所以，第一点就是：对于不合理的需求要大胆地拒绝。\n你有没有想过一个问题：你自己写的代码每天运行了多少次？\n同样的if-else，如果我是抖音开发者，我的代码每天运行上亿次，而你做的一个不知名的 App 每天可能只有一次，甚至从来都没运行过。假如代码每跑一次就给 1 毛钱的话，我就是几千万，你就是不值钱，白送都不要的那种。\n这，就是代码的价值！\n我们要做有价值的人，写有价值的代码！\n换句话说，我们要做有价值的需求。而这个需求，是靠自己争取的。\n比如说，咱俩都是做微信 App 的，我做了朋友圈功能，而你做了设置里面的修改系统语言功能，你觉得咱俩谁更有价值呢？换句话说，咱俩谁更容易加钱呢？\n所以，我们在需求会议上，如果觉得产品的某个需求没有价值，就要大胆提出质疑，发表自己的看法，有些功能可能是产品一时冲动，心血来潮，根本就没做市场调研，就凭着一腔热血提出来的。而此时你要做的，就是滋醒他，他可能还会感激你呢，换句话说，我们要避免无价值的需求，让无价值的需求腹死胎中。\n那么，产品每次提出的需求可能有很多个，你怎么分辨出哪些是有价值的需求呢？\n这个很简单，就看你们 App 的定位了，比如：社交的类的 App，其核心一定是聊天和圈子；购物类的 App，其核心一定是商品的展示和交易。最简单的，你就去看你们 App 的埋点，埋点多的地方，就是核心！\n啥？你说你没权利看埋点？\n大哥，听我一句劝，赶紧跑路吧，公司没把你当自己人啊。\n那么，如果我知道了核心，我要怎么把它揽入怀中呢？\n很简单啊，主动争取。\n核心功能是使用得最多的，一定要保证稳定，所以，你要在这方便表现出自己 Cow B 的地方，争取展示给其他人，并且主动争取过来。\n如果你就想着混混日子，不想那么累，那么推荐你去看看本小册的第一章，你是否有所改变，如果还没有，那么你也别看了，你留言联系下我，我把钱给你退了。趁早改行，送外卖、炒粉都行，乐夫天命复奚疑奚?\n最后一点就是：学会讨价还价，工时是自己估测的，自己一旦做出了决定，就要负起责任，所以，如果你觉得自己可能 3 天开发完毕，那么你可以要 4 天时间，最后一天作为缓冲，你要了 4 天时间，可以第三天就提测；但是如果你要了 3 天时间，你却不能第 4 天才提测。这就是人性的恶！人总是朝着有利于自己的情况奔跑。\n到这里，我们程序员在需求会议上要做的事情就三点：\n拒绝不合理需求； 拒绝无价值需求，争取有价值需求； 给自己的工时添加缓冲期。 当然，以上三点是在合理的范围内做的，不能太过分，你不能直接把产品的所有需求全部否定，也不能直接给自己的缓冲期加个几百天，如果你是国企，当我没说。\n总结 本文到这里就结束了，我们本章主要讲了需求会议的目的，以及程序员在需求评审会议上要做的事情。\n需求会议的目的是确定要做的事情，以及上线的日期。 需求分为功能需求和性能需求。 功能需求的目的是提高新增用户；性能需求的目的是提高存留用户。 我们要拒绝不合理和无价值的需求，争取有价值的需求。 我们估测工时一定要留缓冲期。 下一章中，我们就带着这些理论，来做一个实际的、沉浸式的直播间的需求评审，例子来源于某大型千万级用户直播 App，大家可以一起体验下产品、开发、测试的心路历程。\n26.需求分析:直播间的需求评审 上一章，我们讲述了需求评审的目的，以及在需求评审中我们程序员应该注意的事项，我们知道，对于一个需求来说，产品和开发有共同的地方，那就是：用户量能增长。\n我们上班是为了赚钱，但是我们的工资是公司发的，公司的钱是靠用户给的，用户的钱我们做的 App 带来的。所以，我们真正的老板是用户，而不是领导，领导是直接老板，而不是最终老板；所以，讨好用户就是我们的最终目的。\n那么，怎么讨好用户呢？\n这就不是我们这些直男程序员的事情了，而是那些不一定高智商但一定高情商的产品经理的事情了。\n说实话，产品经理是一门心理学，要学会猜测用户的心理。产品经理的上限更高，比程序员要高得多，但是下限也很低，趋近于负无穷。\n那么，产品经理是怎么制定需求的呢？我们又能从中学到什么呢？\n就让我们一起来瞧一瞧。\n直播间的目的 大家下午一起开个需求会议，在 9 楼的 1101 房间。\n\u0026hellip;\u0026hellip;\n好，大家都到了，本次会议的目的是做一个语音直播间。\n我们经过调研国际市场发现，近 5 年来，语音直播的需求一直在增长，具体表现为：很多主流的社交应用都引入了语音聊天的功能，而且也开通了语音聊天室。我们发现，语音聊天室可以自由说话，没有时间限制，也不像视频直播间那样对网络要求高，市场上的几款主要社交 App 的语音功能使用量都在千万以上。\n所以，我们要做个语音直播间来带动用户，为将来的其他功能铺路。\n到这里，我们大概知道了产品的意思：跟风！\n因为其他 App 的这个功能火了，所以觉得我们也应该顺应潮流做一个一样的需求。\n跟风需求的意思就是：我们也没把握一定成功，但是别人都成功了，我们应该也行，先做出来看看再说，如果还可以，就继续做下去，否则就算了。\n其实到这里，我们可以仔细想一想，既然别人能成功，说明什么？说明只要我们做得比他好，那就大概率能成功，你看腾讯的 App，有几个是原创？但是人家能抄得比原来的更好，这也是一种本事。\n所以，我们可以得出一个结论：一个 App 能火，要么是做出了别人都没有的功能，要么是抄得比别人的更好。说白了就是：要么有创新，要么有质量。\n很明显，我们属于后者，所以这个 App 我们一定要以质量为主，也就是代码一定要写的性能好一点。\n直播间的需求 那么，本次需求有以下几个功能。\n房间列表 首先，我们要有个房间列表，房间列表按照活跃度排序。看到房间列表，我们就应该想到分页加载逻辑了。 然后，我们要有个搜索房间的功能，要能输入房间号来搜索对应的房间。这里我们要能想到，房间号应该定义成字符串类型。因为如果定义成整型，那么 1111 和 01111 是相同的，就会出现串房的问题了。 最后，如果我自己创建有房间，则需要在底部特别展示我自己的房间，以便我能快速进入自己的房间。 好，列表页就这么多，我们看房间主界面。\n房间主页面 房间主界面的排版如下：\n房间标题，需要显示房间名字、房间号，以及人数和设置按钮； 房间麦位，有 8 个麦位（后面可能动态扩展），房主点击可以上麦以及对麦位进行关闭/打开/踢下等操作； 消息列表，展示用户发送的文字消息，以及送礼消息； 操作栏，有打开/关闭麦克风、文字输入框、发送按钮以及送礼按钮等。 看到这里，我们心里应该有个大概，房间整体是一个页面，但是上面的每一块都是可以拆分的，也就是说，我们可以定义四块 UI：标题栏、麦位栏、消息栏、操作栏；每一块单独实现自己的逻辑，然后把它们组装起来，就是房间的主页面了。\n这就是对 UI 的单一职责，但是，不同的 UI 模块之间的数据通信，要怎么做呢？比如：我通过操作栏发了一条消息，标题栏怎么能知道我发了消息呢？\n嗯，这里留个悬念，我们后面会讲。\n礼物模块 礼物模块是重头戏，也是房间的主要收入来源。\n首先，点击送礼按钮，唤起礼物面板，来展示不同的礼物，礼物按照价值从低到高排序。 点击一个礼物，可以选择要送出的数量，默认是 1 个。 点击的礼物要有选中的动画效果，如果选中的礼物特效还没有下载，那么就先下载这个礼物的特效，下载完了才能送出。 礼物支持连送，连送则连续播放，同时只能播放一个，如果连送 100 个，就 100 个依次播放。 礼物可以复用，其他模块也要能用这一套送礼逻辑。 好，需求很明确了，我们需要注意的就两点：\n礼物依次播放，也就是需要个排队的功能，那么，此时你应该能想到我们第 11 章讲到的队列了。 礼物可以复用，那么就需要把礼物单独写成一个模块了。并且礼物不能持有聊天室的逻辑，而是聊天室持有礼物。换句话说就是：聊天室单向依赖礼物模块。 好，这一块也没什么问题了。\n语音模块 最后就是语音了。\n首先，麦上的人有开麦/关麦功能，并且要有音浪表示麦上用户是否在说话。 其次，我们的聊天室要支持小窗功能，也就是可以退出到小窗但是声音不能停。 最后，语音模块也要能复用，将来我们的其他功能也需要这个语音的功能。 核心也是一个：复用，同样的，我们的语音也要写成一个单独的模块，并且聊天室单向依赖语音模块。\n好，这一块到这里也结束了。\nQA 和评定 接下来就是精彩绝伦的撕逼阶段了，瓜子阔洛矿泉水，坐看好戏，反正我这里没啥大问题。\n服务器率先开撕了。\n服务器：你这说房间列表根据活跃度排序，活跃度是怎么决定的？\n产品：根据上麦频率、送礼物频率、发消息频率得到相应的积分，综合排序即可。\n服务器：直接根据人数不行吗？人数多的排在前面。\n产品：不行，这样会导致所有人都去前面的房间，后面房间就没人了，就出现了资源不平衡，就像现实中的北上广深一样。如果根据活跃度排名，即使房间只有寥寥几人，只要聊得欢，送礼送得多，也会出现霸榜的情况，比如有的土豪就喜欢这种感觉。\n(不得不说，产品这个思路还挺有道理的！)\n服务器问这个目的是什么？难不成是想把排序逻辑写死？写死的话就需要客户端做了，房间列表肯定是要分页的，分页的情况下去排序肯定行不通。这不行，这我得问问了：\n这个排序应该是服务器排好之后返回给客户端吧，客户端只负责展示就行了，不然如果放在客户端排序，就等于写死了排序逻辑，将来有调整就需要客户端发版，而且会导致老版本和新版本显示的列表顺序不一样，放在服务器就能避免这个问题。\n原因都说透彻了，服务器不同意也不行。美滋滋，爽歪歪，不愧是我。\n服务器又来了。\n服务器：每个人能创建多少个房间呢？应该是只有一个吧，不然太浪费服务器资源了。\n产品：嗯，目前只能创建一个，跟用户 ID 绑定，如果后面运营得好，用户有这方面需求，有可能可以创建多个，但是不会太多。\n到这里你明白什么了吗？\n你应该明白，服务器想要把用户 ID 和他创建的房间号关联起来，这样来做房间列表里面“我的房间”的功能，但是他不知道该怎么关联，如果是一个用户只能创建一个房间，那么他就用一个Map\u0026lt;String,String\u0026gt;来保存，其中 key 是用户 id，value 是房间号；如果一个用户可以创建多个房间，那么他就得用Map\u0026lt;String,List\u0026lt;String\u0026gt;\u0026gt;来保存了。\n动机我知道了，对我没啥影响，那就没啥事，机智如我。\n那我也得问个问题啊，不然多没面子。\n如果用户开麦说话过程中，有电话打过来了，要怎么办？直接关闭麦克风吗？\n产品明显没想到这个问题，怔了一下，问道：\n来电时可以关闭吗，电话挂了再打开。\n当然可以，最好再加个提示，不然用户不知道麦克风已关闭，可能会自己去手动关一下，没必要。\n好！\n接下来都知道，要决定提测日期了。\n得有个缓冲期，先开口为好。\n我：这个功能，我们这边得调研下语音的 SDK，得跟 SDK 提供者沟通一下通话质量问题，可能要花费一两天。还有，那么个礼物特效，具体什么样子也不知道，得等特效出来我们看怎么绘制，所以我们这边不能给出具体的时间，只能给出个大概时间。\nUI：礼物特效是个 MP4 文件，直接播放就行，应该不难吧。\n我：MP4 文件有声音，如果用户说话期间有礼物播放，怎么处理？\n产品：能让礼物静音吗？\n我：可以，这样逻辑就复杂了，而且 MP4 文件不能太大，下载也要压缩下吧；时间也不能太长，如果太长了，100 个礼物半天播不完，都得考虑下。\n产品：嗯，UI 这方面看一下。\n好，成功，我们的开发周期，有了弹性的时间，这样，目的就达到了。\n最后，我们也发现了，这是个功能性需求，也就是以新增为主，但是却是个抄袭的功能，抄袭就要抄得好一点，至少不能比目标差，这就要求性能要好一点了。\n那么，这里面最有价值的功能是什么呢？\n很明显：语音模块和礼物模块。\n所以，我们要尽可能把这两块揽过来做，即使聊天室不行，因为这两块是复用的，也可以在其他模块显出价值。\n总结 本章我们参与了一个语音直播间的需求评审，知道了需求的目的，也知道了自己接下来该做什么。\n对于我们程序员来说，我们要注意的就是以下几点。\n听别的开发跟产品的对话，肯定是有目的的，要能听出这个目的，危险总是悄悄到来。 将所有涉及到自身的不明白的地方都问明白，不仅仅局限于需求，也包括技术。 将所有不确定的因素提出来，并提出缓冲时间。 如果没有十足的把握，尽量不要给出具体的提测日期，而是给一个弹性的时间。 尽量做有价值的需求，尽量做有价值的需求，尽量做有价值的需求。 本篇文章基本都是教你套路的，但是没办法，有人的地方就有江湖，那么下一章，我们就开始搭建我们的直播间框架了。\n27.概要设计:设计我们的项目架构 上一章节我们进行了直播间的需求评审，对我们的需求进行了详细探讨，那么，既然需求已定，接下来就是撸码阶段了。\n我们知道，好的设计是成功的一半，我们要先好好地思考一下，并把我们代码的地基打瓷实了。\n全局的委任模式 首先，针对直播间来说，我们的直播间是一块功能，我们称之为一个模块。\n其实，我们可以这么理解：我们的项目就是一个个的模块组成的，我们把项目比喻成一个国家，那么模块就像是三省六部一样，而皇帝呢，直接管理这三省六部即可。\n我们把项目称为 App，把模块称为 Module。\n所以，到这里，我们可以总结出来：项目管理模块，模块实现自己的功能。\n这像不像一个委任模式呢？\n其中，App 管理着 Module，Module 管理着自己内部的逻辑。\n好，那么，我们来实现一下相关的代码。\n首先，我们定义一下模块的相关逻辑：\n1 2 3 4 5 // 抽象的模块逻辑 interface IModuleContext { // 返回模块类型 IModuleType getModuleType(); } 定义模块的类型：\n1 2 3 4 5 6 7 enum ModuleType(int value) { HOME(1), // 首页 CHAT(2), // 聊天 MOMENTS(3), // 朋友圈 PROFILE(4), // 个人信息 VOICE_ROOM(5), // 语音聊天室 } 接下来，定义一下我们的直播间的顶层模块：\n1 2 3 4 // 直播间的顶层接口定义，需要实现模块类的Context interface IVoiceRoomContext extends IModuleContext { // ... 具体的业务定义，App一级的不感兴趣 } 就是这么一个接口，只需要继承IModuleContext表示自己是一个Module即可，就是这么简单。\n等等，写的不太对，因为我们第 23 章说过分层思想，我们应该把直播间的基础功能抽离出来，抽成一个IBaseRoomContext，没错，搞起来。\n1 2 3 4 5 6 7 interface IBaseRoomContext extends IModuleContext { // 房间基础功能 } interface IVoiceRoomContext extends IBaseRoomContext { // 房间语音功能 } 这样就定义完我们的顶层架构了。\n然后，我们需要让App管理这些Module，那么，怎么管理呢？\n其实，所谓管理，就是控制生命周期，也就是控制你的存在和销毁，换句话说就是控制这些 Module 的创建和删除，我们可以用一个集合来管理这些Module。\nNo BB，Show Code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // App代表我们的主项目 class App { // 存放所有的模块数据,key是类型，value是对应的Module的数据 private Map\u0026lt;ModuleType,IModuleContext\u0026gt; modulePoll = new HashMap\u0026lt;\u0026gt;(); // 根据模块类型，获取对应的模块数据 // 这里采用了泛型，其中MC代表泛型 public \u0026lt;MC extends IModuleContext\u0026gt; MC getModuleContext(ModuleType type) { if(!modulePoll.containsKey(type)) return null; // 需要强转一下 retrun \u0026lt;MC\u0026gt; modulePoll.get(type); } // 注册模块，因为map自带去重功能，所以不需要去重 // IModuleContext可以获取自己的ModuleType，所以一个参数就够了 public void addModuleContext(IModuleContext moduleContext) { modulePoll.put(moduleContext.getModuleType(), moduleContext); } // 删除模块，根据最小知识原则，我们只需要知道ModuleType就行，没必要传递IModuleContext过来 public void rmModuleContext(ModuleType type){ modulePoll.remove(type); } 因为我们的App代表项目，所以只有一个，且全局存在，所以可以采用单例模式，且不用考虑内存泄露 private static App instance = new App(); public static void getApp() { return instance; } } 好，到这里，我们的App层的逻辑就完成了，我们在任意地方可以通过：\n1 App.getApp().getModuleContext() 来获取到对应的模块数据，可以通过addModuleContext()和rmModuleContext()来控制，从而达到控制模块生命周期的目的。\n那么，这个模块什么时候开始存在，什么时候死亡呢？换句话说，这个模块的生命周期是多长呢？\n当我们点击按钮进入直播间的时候，直播间的生命周期就开始了，我们就应该通过addModuleContext()来保存我们的直播间数据；当我们退出直播间的时候，直播间的生命周期就结束了，我们就应该通过rmModuleContext()来移除直播间数据。\n假如，我们通过长链接来实现我们的直播间，我们的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void onReceiveData(String json) { String type = json.optString(\u0026#34;type\u0026#34;); String data = json.optString(\u0026#34;data\u0026#34;); if(\u0026#34;enterRoom\u0026#34;.equals(type)) { // 进入房间成功，创建直播间数据 IVoiceRoomContext voiceRoomContext = new VoiceRoomContextImpl(); voiceRoomContext.enterRoom(data); // 存储数据 App.getApp().addModuleContext(voiceRoomContext); // 启动页面 VoiceRoomPage.start(); } } 退出房间的时候，就是：\n1 2 3 4 5 6 // 退出房间 voiceRoomContext.exitRoom(); // 移除数据 App.getApp().rmModuleContext(voiceRoomContext); // 销毁页面 exitPage(); 上述只是伪代码，我们需要根据具体业务来实现具体逻辑。\n那么，VoiceRoomContextImpl是什么玩意儿呢？它里面的具体逻辑是什么呢？\n我们就来看一看它的具体逻辑。\n局部的 MVC 好，现在，我们就要对直播间下手了，现在，我们可以完全无视上述代码，我们的眼里只有直播间，直播间就是全部。\n经过分析，我们可以很简单地定义出直播间的功能，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 interface IVoiceRoomContext extends IBaseRoomContext { // 进房间 并且使用json初始化数据 void enterRoom(String json); // 退房间 成功则回调 true:退出成功 false:退出失败 void exitRoom(Action\u0026lt;Boolean\u0026gt; callback); // 上座位 position:目标位置 void seatDown(int position); // 下座位 void leaveSeat(); // 打开麦克风 void openMic(); // 关闭麦克风 void closeMic(); // 发消息 void sendMsg(String msg); // 送礼物 void sendGift(Gift gift, String uid) } 好，这就是最基本的业务逻辑了。\n等等，不对，这些函数全部定义到IVoiceRoomContext里面了，那么，IBaseRoomContext有什么意义呢？为了看看？\n大哥质疑的对，我这就改。\n经过分析，我们知道IVoiceRoomContext的重点就是Voice，也就是跟语音相关的，那么，跟语音无关的，就意味着其他非Voice系列的Room也可以使用，就是共用的，可以提取出来，放到上层逻辑（也就是父类）中去。所以，我们修改过的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 基础房间功能 interface IBaseRoomContext { // 进房间 并且使用json初始化数据 void enterRoom(String json); // 退房间 成功则回调 true:退出成功 false:退出失败 void exitRoom(Action\u0026lt;Boolean\u0026gt; callback); // 上座位 position:目标位置 void seatDown(int position); // 下座位 void leaveSeat(); // 发消息 void sendMsg(String msg); // 送礼物 void sendGift(Gift gift, String uid) } // 语音房间功能 interface IVoiceRoomContext extends IBaseRoomContext { // 进入语音流 void enterVoice(); // 退出语音流 void exitVoice(); // 打开麦克风 void openMic(); // 关闭麦克风 void closeMic(); // 打开扬声器 void openSpeaker(); // 关闭扬声器 void closeSpeaker(); } 好，完事了，这样是不是好很多了？如果将来有一个新直播间 A，不需要语音功能，只需要基础功能，那么这个 A 只需要继承IBaseRoomContext即可，就不会有任何语音功能，完全符合最小知识原则；如果 A 需要有语音功能，那么直接修改继承自IVoiceRoomContext即可；反正你需要啥就找啥，然后继承它就可以了。\n那业务逻辑到这里就完事了。\n上一章我们讲了，需要将语音模块单独定义出来，其他地方可能要使用，语音模块的功能是啥呢？\n正是我们上面定义在IVoiceRoomContext里面的功能。\n那我们直接在里面实现不就行了吗？反正它也是一个模块。\n不行！因为IVoiceRoomContext还继承了IBaseRoomContext，也就是里面不光有语音相关功能，还有房间相关功能，如果将来我们的其他模块不需要房间功能呢？这不符合最小知识原则。\n所以我们应该单独定义出来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 单纯的语音直播间功能 interface IAudioEngine { // 进入语音流 void enterVoice(); // 退出语音流 void exitVoice(); // 打开麦克风 void openMic(); // 关闭麦克风 void closeMic(); // 打开扬声器 void openSpeaker(); // 关闭扬声器 void closeSpeaker(); } 然后，让我们的IVoiceRoomContext也继承它就可以了，如下：\n1 2 3 // 语音房，也就是在普通房间上 添加了 语音功能 interface IVoiceRoomContext extends IBaseRoomContext, IAudioEngine { } 可以看到，我们的IVoiceRoomContext其实就是个功能的结合体。\n语音房，语音房，偏正短语，一个房间，一个带语音功能的房间，所以就是俩功能：语音功能+房间功能。而接口，就是代表某种功能，所以，语音房，只要用两个接口接合一下，就完美实现了。\n有人说，不对啊，java不是只能继承一个吗？你这都继承了两个了。\n问这个问题的人，就是语言能力不过关，或者说，根本就没有彻底理解面向对象设计理念。\nTips：在面向对象语言中，继承表示：是什么；接口表示：有什么功能；因为你要么是 A 要么是 B，所以如果你是对象，你只能单继承；而如果你是接口，你可以既有 A 功能，又有 B 功能，你就可以多继承。\n当你明白了上述道理后，你就不会纠结于有几个父类了，你会看得更远，理解得更深刻，你就会开始去理解语言的设计理念了。比如C++就可以多继承，但是无所谓啊，它这个多继承描述的设计理念跟java是一样的，并补互斥，这里不再废话。\n好，那么到这里，我们的语音直播间，就完全可以使用IVoiceRoomContext来表示了，并且，我们的App对象，不需要做任何修改，因为App存储的是IModuleContext，是接口，是抽象，我们做的是面向抽象编程，也就是依赖倒置原则，这正如我们第 21 章所讲的。\n那么，假如，我们的 UI 页面叫VoiceRoomPage，那么，它应该由 4 部分组成，就像我们在上一章需求评审里面讲的一样：\n顶部标题栏； 座位栏； 消息栏； 底部操作栏。 所以，我们可以定义四个部分来处理 UI，如下：\n1 2 3 4 5 6 7 8 9 10 11 // 标题栏 class TitlePanel {} // 座位栏 class SeatPanel {} // 消息栏 class MsgPanel {} // 操作栏 class OptionPanel {} 为了方便处理，我们可以将 UI 抽离一层，叫做房间组件，那么上述四个 UI 块，就是四个组件，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 房间组件 abstract class VoiceRoomPanel { // 房间组件都持有房间上下文数据类 protected IVoiceRoomContext voiceRoomContext; // 通过构造函数传入上下文 public void VoiceRoomPanel(IVoiceRoomContext voiceRoomContext) { this.voiceRoomContext = voiceRoomContext; } } // 标题栏 class TitlePanel extends VoiceRoomPanel { } // 座位栏 class SeatPanel extends VoiceRoomPanel { } // 消息栏 class MsgPanel extends VoiceRoomPanel { } // 操作栏 class OptionPanel extends VoiceRoomPanel { } 这样，我们的四个 UI 组件都持有了同一份VoiceRoomContext，那就意味着数据是共享的，其中OptionPanel如果进行了操作，那么就会修改VoiceRoomContext里面的数据，TitlePanel再去拿，就是修改过的数据。\n还记得我们上一章留下的悬念吗?\n不同的 UI 模块之间的数据通信，要怎么做呢？\n就是这么做的，通过数据共享。\n接下来我们来看一看我们的VoiceRoomPage的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class VoiceRoomPage { protected IVoiceRoomContext voiceRoomContext; private List\u0026lt;VoiceRoomPanel\u0026gt; panels = new ArrayList(); public void init() { // 获取语音房上下文数据 this.voiceRoomContext = App.get().getModuleContext(ModuleType.VOICE_ROOM); // 进入语音流 this.voiceRoomContext.enterVoice(); // 初始化房间组件 panels.add(new TitlePanel(voiceRoomContext)); panels.add(new SeatPanel(voiceRoomContext)); panels.add(new MsgPanel(voiceRoomContext)); panels.add(new OptionPanel(voiceRoomContext)); } } 上面就是初始化逻辑，我们看到，经过上述初始化，我们的上下文数据已经分发到房间的各个 UI 块里面了，任何想使用它的地方，都可以直接使用，并且，所有的操作都是共享的，因为它们用的是同一份VoiceRoomContext。\n其实，我们可以将我们的 UI 看作一棵树，我们的VoiceRoomContext在树根创建，然后沿着我们的 UI 树向下分发，到达不同的分支节点、叶子结点。这样一来，任何节点的操作，都会反馈到这个树的其他节点，达到数据共享。\n那么，A 节点操作了之后，B 节点怎么能立刻知道呢？\n没错，就是我们第 22 章讲的观察者模式，这个我们在下一章的具体实现里面会仔细列出代码。\n好，现在让我们来捋一下我们的代码流程：\n我们通过长链接建立连接，进入了房间； 用长链接返回的数据创建VoiceRoomContext，并保存起来； 进入语音流，默认打开扬声器； 启动房间页面，并获取上一步的VoiceRoomContext，用来初始化各个 UI 块。 这样，我们的房间页面就起来了，并且也能听到声音了。\n到这里，我们的顶层框架就搭建完成了，我们通过VoiceRoomContext来控制非 UI 逻辑，通过IAudioEngine来实际控制声音，我们的 UI 不做任何数据逻辑。这样，即使要实现上一章的小窗口功能，我们只需要销毁 UI 就行了，因为数据还在App的modulePoll里存放着，还在执行着，只是不更新 UI 而已。\n总结 本章我们仔细分析了语音直播间的功能，并搭建出顶层架构，我们没看到任何具体的实现代码，但是光看接口定义就已经知道这个需求的所有功能了，这就是面向抽象编程，不写具体的实现代码也能知道在干什么。其实这可以分为几个步骤：\n深入理解需求，并剖析成一个个的功能块； 定义接口来描述这些功能块； 找出不是当前需求独有的特性的功能块，并抽离成公用的； 整理上面定义的接口，找出符合当前需求的最小接口集合； 将这个接口集合集中到一个接口里面，这个接口就是我们要实现的需求。 当然，光嘴说没用，还得多实践，多体会，那么，下一节，我们就来实现我们的详细业务代码，来深入体会一下自顶向下的编程理念。\n28.详细设计:开始实现业务逻辑 上一章中，我们搭建了项目的顶层架构，我们知道，我们项目的整体是一个个的模块组成的，并且直播间这个模块，宏观上是一个 MVC 框架。\n那么，本章我们就来实现具体的业务逻辑。\n基础房间逻辑的实现 首先，我们先来实现房间的基础功能，我们先定义下IBaseRoomContext的实现类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 房间基础功能实现类 class BaseRoomContextImpl implements IBaseRoomContext { // 这个用来发送长链接消息，我们假设用的是socket private SocketEngine socketEngine = new SocketEngine(); // 进房间 并且使用json初始化数据 void enterRoom(String json) { } // 退房间 成功则回调 true:退出成功 false:退出失败 void exitRoom(Action\u0026lt;Boolean\u0026gt; callback) { // 发送退出房间消息给服务器 socketEngine.sendMsg(\u0026#34;{type:exit}\u0026#34;) } // 上座位 position:目标位置 void seatDown(int position) { socketEngine.sendMsg(\u0026#34;{type:seatDown,position:$position}\u0026#34;) } // 下座位 void leaveSeat() { socketEngine.sendMsg(\u0026#34;{type:levelSeat}\u0026#34;) } // 发消息 void sendMsg(String msg) { socketEngine.sendMsg(\u0026#34;{type:msg,msg:$msg}\u0026#34;) } // 送礼物 void sendGift(Gift gift, String uid) { socketEngine.sendMsg(\u0026#34;type:gift,gift:$gift,uid:$uid\u0026#34;) } } 逻辑很简单，我们只是实现了IBaseRoomContext接口，并且定义了一个SocketEngine用来向服务器发消息。\n那么，接收服务器消息的逻辑在哪里处理呢？\n我们先来定义一个处理服务器消息的接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 interface IBaseRoomObserver { // 退出房间的回调 void onExitRoom(); // 上座的回调 void onSeatDown(int position); // 下坐的回调 void onLeaveSeat(); // 收到聊天消息的回调 void onRecvMsg(String msg); // 收到礼物的回调 void onRecvGift(Gift gift, String uid); } 好，我们定义完了，看名字就像是个观察者模式。\n然后，我们来修改下IBaseRoomContext，添加如下代码：\n1 2 3 4 5 interface IBaseRoomContext { void addBaseRoomObserver(IBaseRoomObserver observer); void removeBaseRoomObserver(IBaseRoomObserver observer); } 没错，我们添加了两个方法，一个用来添加观察者，一个用来移除观察者。\n然后，我们在BaseRoomContextImpl里实现一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class BaseRoomContextImpl implements IBaseRoomContext { // 定义观察者集合 private List\u0026lt;IBaseRoomObserver\u0026gt; observers = new ArrayList(); // 添加观察者 void addBaseRoomObserver(IBaseRoomObserver observer) { // 这里添加一个拦截，不能重复添加观察者 if(observers.contains(observer)) return; observers.add(observer); } // 移除观察者 void removeBaseRoomObserver(IBaseRoomObserver observer) { observers.remove(observer); } } 好，到这里，我们已经添加完了观察者了，这个观察者是提供给 UI 用的，用来将自己接收到的服务器数据解析后，通知到 UI 层。\n那服务器发送的数据你到底怎么处理呢？\n别急别急，往下看。\n我们知道，对于Socket来说，他有个onMessage(String msg)方法，用来接收服务器发送的消息，那么突破点就来了，我们就通过这个方法接收并解析服务器的消息。\n我们先定义一个Socket行为的观察者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 定义socket行为的观察者 interface SocketActionObserver { // 连接成功 void onConnect(); // 断开连接 void onDisconnect(); // 重连成功 void onReconnect(); // 收到消息 void onMsg(String msg); } 然后，再实现SocketEngine的逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class SocketEngine { private List\u0026lt;SocketActionObserver\u0026gt; socketActionObservers = new ArrayList(); // 添加观察者 public void addObserver(SocketActionObserver observer) { //... } // 移除观察者 public void rmObserver(SocketActionObserver observer) { //... } // 接收到服务器的消息 void onMessage(String msg) { // 分发到观察者里面去 for(SocketActionObserver observer : socketActionObservers) { observer.onMsg(msg); } } //... } 最后，我们需要观察Socket的消息行为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class BaseRoomContextImpl { // 这个用来发送长链接消息，我们假设用的是socket private SocketEngine socketEngine = new SocketEngine(); // 定义一个Socket观测器 private SocketActionObserver sicketActionObserver = new SocketActionObserver { void onMsg(String msg) { // 我们假设msg是个json，那么，这里就应该在IO线程中解析json，然后在UI线程中分发 withIO() { // .....解析数据 withUI() { // ....分发数据，分发到我们上面定义的IBaseRoomObserver里面去。 } } } // ... } // 在构造函数里面开始注册观察者 void BaseRoomContextImpl { // ...初始化数据 // 注册观察者 socketEngine.addObserver(sicketActionObserver); } } 懵逼吗？有点。\n好，我们来整理下逻辑：\n我们定义了BaseRoomContextImpl，用来实现房间的基础逻辑。 我们定义了SocketEngine，用来向服务器发数据和接收服务器数据。 我们定义了SocketActionObserver，来让BaseRoomContextImpl观察SocketEngine，以此将数据从SocketEngine传送到BaseRoomContextImpl中。 我们定义了IBaseRoomObserver，用来将BaseRoomContextImpl中解析过的数据进行分发，分发给谁呢？肯定是 UI 了。 所以，我们的数据流向现在明白了，就是： 服务器 -\u0026gt; SocketEngine的onMessage() -\u0026gt; SocketActionObserver(观察者) -\u0026gt; BaseRoomContextImpl(解析) -\u0026gt; IBaseRoomObserver(观察者) -\u0026gt; UI。\n可以看到，我们的目标就是：让服务器数据传送到 UI 上，UI 来进行绘制，以便让用户看到。\n那么，数据怎么分发到 UI 上呢？\n用户有很多行为，比如：发消息、送礼物、上座下座等，你怎么区分呢？\n所以，我们需要定义一个类型来区分这些行为。\n好，上类型，我们用枚举定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 enum ActionType { // 构造函数，传递一个code，跟服务器商量好的code ActionType(int code) {} // 发消息 SEND_MSG(0x0001), // 送礼物 SEND_GIFT(0x0002), // 上座位 UP_SEAT(0x0003), // 下座位 DOWN_SEAT(0x0004); // ... 其他 } 好，定义好了类型，我们就要定义对应的解析对象了，我们定义上述四个解析对象如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 收到消息 class OnReceiveMsgBean { String msg; long fromUID; long msgTime; } // 收到礼物 class OnReceiveGiftBean { Gift gift; int fromUID; long toUID; } // 上座 class OnUpSeatBean { long uid; int toPosition; int oldPosition; } // 下座 class OnDownSeatBean { long uid; int oldPosition; } 那么接下来，我们就开始解析并分发我们的数据了，我们来重写下BaseRoomContextImpl里面的SocketActionObserver：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class BaseRoomContextImpl { // 定义一个Socket观测器 private SocketActionObserver socketActionObserver = new SocketActionObserver { void onMsg(String msg) { // 我们假设msg是个json，那么，这里就应该在IO线程中解析json，然后在UI线程中分发 withIO() { // 解析数据 int code = msg.getInt(\u0026#34;code\u0026#34;) String json = msg.getString(\u0026#34;data\u0026#34;); // 根据type选择不同的对象去解析 switch(code) { case ActionType.SEND_MSG.code: { // 发消息的，就用消息实体去解析 OnReceiveMsgBean bean = JsonUtil.parseToBean(msg, OnReceiveMsgBean.class); // 分发到UI withUI(){ for(IBaseRoomObserver observer : observers) { // 这里传递整个消息实体 observer.onReceiveMsg(bean); } } } case ActionType.SEND_GIFT.code: { // 发消息的，就用消息实体去解析 OnReceiveGiftBean bean = JsonUtil.parseToBean(msg, OnReceiveGiftBean.class); // 分发到UI withUI(){ for(IBaseRoomObserver observer : observers) { // 这里传递整个消息实体 observer.onRecvGift(bean); } } } // ... 其他类型 } } } // ... } } 好，现在，我们的消息分发解决了，但是你看这大量的switch-case，屎一样的代码，是可忍孰不可忍？\n我们之前的章节讲过代码优化啊，像这种switch-case的，明显就是一个对应关系，既然是对应关系，那就可以用map来优化，那key不就是我们定义的枚举的 code 吗？value不就是一个实体类型吗？\n是是是，这样是可以，但是～，这只是解析，你后面的分发，不是还得判断吗？你这样一改，大体代码如下：\n于是，代码就变成了这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class BaseRoomContextImpl { // 用来处理socket消息的map private Map\u0026lt;Int,Class\u0026gt; actionMap = new HashMap\u0026lt;\u0026gt;(); // 然后需要在构造器中，初始化这个map void BaseRoomContextImpl { actionMap.put(ActionType.SEND_MSG.code, OnReceiveMsgBean.class) actionMap.put(ActionType.SEND_GIFT.code, OnReceiveGiftBean.class) // ...其他 } // 定义一个Socket观测器 private SocketActionObserver sicketActionObserver = new SocketActionObserver { void onMsg(String msg) { // 我们假设msg是个json，那么，这里就应该在IO线程中解析json，然后在UI线程中分发 withIO() { // 解析数据 int code = msg.getInt(\u0026#34;code\u0026#34;) String json = msg.getString(\u0026#34;data\u0026#34;); switch(code) { case ActionType.SEND_MSG.code: { // 这里直接getCode了 OnReceiveMsgBean bean = JsonUtil.parseToBean(msg, actionMap.get(code)); // 分发到UI withUI(){ for(IBaseRoomObserver observer : observers) { // 这里传递整个消息实体 observer.onReceiveMsg(bean); } } } // ... 其他类型 } } } // ... } } 你看这，一点意义都没有啊，并没有节省代码，因为你虽然根据code知道了是哪个解析对象，但是你不知道要走哪个分发函数，所以，还需要让code跟分发函数对应上。\n既然如此，那不如这样：我直接将code作为key，将code对应的一套逻辑（也就是 switch）的分支，整体作为 value。没错！就该如此！\n好，我们定义一个Action如下：\n1 2 3 interface Action { void action(String json); } 然后修改上述代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class BaseRoomContextImpl { // 用来处理socket消息的map private Map\u0026lt;Int,Action\u0026gt; actionMap = new HashMap\u0026lt;\u0026gt;(); // 然后需要在构造器中，初始化这个map void BaseRoomContextImpl { // 发消息的逻辑处理 actionMap.put(ActionType.SEND_MSG.code, Action { json-\u0026gt; // 在IO线程中解析，下发的时候，调用方已经直接切换收到IO线程了 OnReceiveMsgBean bean = JsonUtil.parseToBean(json, OnReceiveMsgBean.class); // 在UI线程中分发 withUI() { for(IBaseRoomObserver observer : observers) { // 这里传递整个消息实体 observer.onReceiveMsg(bean); } } }) // 送礼的逻辑处理 actionMap.put(ActionType.SEND_GIFT.code, Action { json-\u0026gt; OnReceiveGiftBean bean = JsonUtil.parseToBean(msg, OnReceiveGiftBean.class); withUI() { for(IBaseRoomObserver observer : observers) { observer.onRecvGift(bean); } } }) // ...其他 } // 定义一个Socket观测器 private SocketActionObserver sicketActionObserver = new SocketActionObserver { void onMsg(String msg) { // 我们假设msg是个json，那么，这里就应该在IO线程中解析json，然后在UI线程中分发 withIO() { // 解析数据 int code = msg.getInt(\u0026#34;code\u0026#34;) String json = msg.getString(\u0026#34;data\u0026#34;); // 已经在IO线程了，直接分发即可 actionMap.get(code).action(json); } } } } 你看你看，上述的观察者好简单啊，就是获取code和json然后在actionMap找到对应的执行者，neng 一下就完事了，将来新加其他类型的消息，它也不用动，简直美滋滋。\n将来新加消息怎么办呢？直接在actionMap新加一个key-value就行，完全符合OCP原则。\n语音逻辑的实现 语音逻辑就相对简单了，不过我们还是要设计一下，进行二次包装，因为大部分语音 SDK 都是用的第三方的，万一将来要替换，我们二次包装的威力就出来了，因为顶层逻辑不用动啊。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 单纯的语音直播间功能 interface IAudioEngine { // 进入语音流 void enterVoice(); // 退出语音流 void exitVoice(); // 打开麦克风 void openMic(); // 关闭麦克风 void closeMic(); // 打开扬声器 void openSpeaker(); // 关闭扬声器 void closeSpeaker(); } 1 2 3 4 5 6 7 8 9 10 class AudioEngineManager implements IAudioEngine { // 这是第三方的语音SDK private AudioEngine audioEngine; void enterVoice() { audioEngine.enterVoice(); } //...其他逻辑 } 很简单，核心就一个：我们二次包装一下第三方的 SDK，顶层使用我们包装过的即可，这样，将来如果要改变第三方的 SDK，我们直接替换AudioEngineManager里面的AudioEngine即可，顶层逻辑不需要变动，这也是为了OCP原则而设计。\n语音聊天室的最终实现 我们的房间基础功能实现了，并且也实现了语音模块，根据上一章的内容我们知道，语音聊天室就是集成了这两块功能。\n我们需要先来修改下我们的语音房接口，需要添加对语音功能的观测行为：\n1 2 3 4 5 // 语音房也需要添加自己的观察者，以此来观察跟语音相关的内容 interface IVoiceRoomContext { void addObserver(IVoiceRoomObserver observer); void rmObserver(IVoiceRoomObserver observer); } 而我们知道，语音房的行为肯定比基础房间多，那么它的可观测行为就比基础房间多，因为包含了基础房间的行为，所以我们可以让IVoiceRoomObserver实现IBaseRoomObserver：\n1 2 3 4 5 6 7 8 9 interface IVoiceRoomObserver extends IBaseRoomObserver { void onOpenMic(); void onCloseMic(); void onOpenSpeaker(); void onCloseSpeaker(); } 然后，我们就可以实现VoiceRoomContextImpl了，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class VoiceRoomContextImpl extends BaseRoomContextImpl implements IVoiceRoomContext { // 语音房间的观测器 private List\u0026lt;IVoiceRoomObserver\u0026gt; voiceRoomObservers = new ArrayList\u0026lt;\u0026gt;(); // 处理语音逻辑 private IAudioEngine audioEngineManager; public VoiceRoomContextImpl() { super(); this.audioEngineManager = new AudioEngineManager(); } @Override public void addObserver(IVoiceRoomObserver observer) { // 添加到父类中 super.addObserver(observer); // 添加到自身 if(!voiceRoomObservers.contains(observer)) { voiceRoomObservers.add(observer); } } @Override public void rmObserver(IVoiceRoomObserver observer) { // 从父类移除 super.rmObserver(observer); // 从自身移除 voiceRoomObservers.remove(observer); } @Override public void enterVoice() { audioEngineManager.enterVoice(); } @Override public void exitVoice() { audioEngineManager.exitVoice(); } @Override public void openMic() { audioEngineManager.openMic(); } @Override public void closeMic() { audioEngineManager.closeMic(); } @Override public void openSpeaker() { audioEngineManager.openSpeaker(); } @Override public void closeSpeaker() { audioEngineManager.closeSpeaker(); } } 可以看到，我们的语音房是一个实现了语音功能的基础房间，因为它继承了BaseRoomContextImpl，说明是个房间，而又实现了IAudioEngine接口，说明集成了语音功能。\n那为啥不是继承AudioEngineManager而实现IBaseRoomContext呢？\n语音房，语音房，你品，你仔细品，语音房是个偏正短语，主体是房间，什么房间？有语音功能的房间。而不是有房间功能的语音。\n所以，就应该继承BaseRoomContextImpl实现IAudioEngine。\n继承表示是什么，实现表示有什么功能。\n有人说，你这样的话，VoiceRoomContext不就有了两个添加观察者的方法了吗？\n没错！\n这样的话，不就会重复了吗？\n不会！因为子类和父类都做了去重判断。\n那也不对啊，你这子类的voiceRoomObservers和父类的observers都添加了，那不就执行两次了吗？\n不会！因为分发的时候，只有语音逻辑才会走voiceRoomObservers，非语音逻辑就走observers，所以没问题。这个就需要在分发时注意了，不要做无谓的重复操作。\n接下来，我们来看下我们的主页面要怎么实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 主页面 class VoiceRoomPage { protected IVoiceRoomContext voiceRoomContext; private List\u0026lt;VoiceRoomPanel\u0026gt; panels = new ArrayList(); public void init() { // 获取语音房上下文数据 this.voiceRoomContext = App.get().getModuleContext(ModuleType.VOICE_ROOM); // 进入语音流 this.voiceRoomContext.enterVoice(); // 初始化房间组件 panels.add(new TitlePanel(voiceRoomContext)); panels.add(new SeatPanel(voiceRoomContext)); panels.add(new MsgPanel(voiceRoomContext)); panels.add(new OptionPanel(voiceRoomContext)); // 注册观察者 this.voiceRoomContext.addObserver(roomMainObserver); } // 观测房间行为 private IVoiceRoomObserver roomMainObserver = new IVoiceRoomObserver() { // ... 处理对应逻辑 } } 接下来我们看下消息栏MsgPanel：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class MsgPanel extends VoiceRoomPanel{ public void init() { // 初始化UI initUI(this.voiceRoomContext) // 添加观察者 this.voiceRoomContext.addObserver(roomMainObserver); // 点击就发消息 this.sendButton.setOnClick { String msg = this.textView.text; this.voiceRoomContext.sendMsg(msg) } } // 观测房间行为，服务器发送的消息都会在这里收到，并且是已解析过的 private IVoiceRoomObserver roomMsgObserver = new IVoiceRoomObserver() { // 只需要处理消息逻辑 public void onReceiveMsg(OnReceiveMsgBean bean) { // 将消息添加到UI上 msgList.add(msg); } } public void onDestroy() { // UI销毁就移除观察者 this.voiceRoomContext.rmObserver(roomMainObserver); } } 其他逻辑都跟消息栏逻辑一样，每一个模块都注册个观测器，然后只处理自己关心的逻辑，这不就是宏观的最小知识原则吗？\n有人说，这不对啊，你这观察者是个接口，得所有方法都实现出来。\n没错，你可以写个抽象类，默认实现了这个观察者接口，添加观察者的时候，直接创建这个抽象类即可。\n1 2 3 4 5 6 7 8 9 abstract class LightVoiceRoomObserver implements IVoiceRoomObserver { @Override public void onReceiveMsg(OnReceiveMsgBean bean) { } // ... 其他方法的默认实现 } 然后，将上述的IVoiceRoomObserver替换为LightVoiceRoomObserver即可。\n最后，我们的礼物模块是跟语音模块类似的，一定是独立的，不依赖于语音房，而是被语音房依赖，这样才能复用，这里就不废话了。\n总结 本章代码比较多，大家可以仔细体会一下，理解一下其中的逻辑思想，尤其是持有和被持有、依赖和被依赖的关系。\n我们再来回顾一下我们的整体代码流程：\n在 App 层面，我们收到服务器消息，就创建出房间上下文VoiceRoomContext。 我们的VoiceRoomContext被创建出来，就会自动创建出语音引擎AudioEngine，并且进入语音流。此时其实已经进入房间了，只不过我们的 UI 还不可见。 然后我们启动我们的 UI 页面，用上一步创建出来的VoiceRoomContext初始化我们的页面，并且初始化房间各个 UI 模块。 各个 UI 模块也依次使用VoiceRoomContext初始化数据，然后就向VoiceRoomContext注册自己创建的观察者，开启后续的各个房间行为的监听。 由于我们的房间是语音房，带有语音功能的房间，所以我们继承了房间类，实现了语音接口。\n由于我们考虑到了拓展性，所以对房间进行了分层，将非语音功能都分到了房间基础层。\n我们使用了两层观察者模式，第一是RoomContext对Socket的观察，第二是UI对RoomContext的观察。这两层观察的目的是不同的，前者是为了找到房间的数据，并进行解析；后者是为了找到对自己有用的数据，并刷新 UI。\n那么，下一章，我们就来做一下收尾工作，来看下我们代码中做的不好的地方，以及做的好的地方。\n29.复盘:代码的Review与评估 前两章，我们已经把直播间的需求搞完了，那么本章节，我们就来 Review 下我们项目中的问题，我们主要反思做得不好的地方，次要反思做得好的地方。\n对于做得不好的地方，我们重点分析原因，到底是因为理性还是因为感性，是因为时间问题还是因为性格问题，最后反思出解决方法；对于做得好的地方，我们主要记录下结果和心得，以便下次还这么做。\n且把闲话休提，只说正话，我们的复盘就开始了。\n我们先说做得不好的地方（减分点），后说加分点，这样就能有个好结尾，也就能给人留个好印象。\n减分点 成大事者，不虑胜先虑败。\n我们就首当其冲地来痛定思痛，看一下我们哪里做得不够好。\n1. 数据安全问题 我们第一个做得不好的地方就是数据安全问题，我们的所有数据都是通过json传递的，不够安全，别人很容易通过我们传递的数据推测出我们的意图，然后自己去模仿数据向服务器发送，这样以来，我们的直播间就有了安全隐患。\n那么怎么办呢？\n嗯，加密！\n用什么加密呢？MD5？\n算了洗洗睡吧，你这加密加的连你们自己服务器都不认识了。\n我们肯定要选个可逆的加密，对称加密还是非对称加密就看你们自己怎么定的了，加密这个事情一般都是服务器出策略的。客户端照着接上就行。\n假如，我们采用了 RSA 加密，我们岂不是在所有发送数据的地方都要包装一下吗？\n非也！\n其实，我们发送数据的地方就一个，就是socke.sendMsg(json)，我们完全可以在这里直接将 json 数据用加密算法包装一下，然后发送给服务器。\n好，我知道了，那你一开始为啥不做呢？\n因为我们 app 目前不出名，而且加了代码混淆。技术差的人反编译不了，技术好的人不屑于反编译。等我们 app 用户起来了之后，再做加密这件事也不迟，不然就等于给一个 100 块钱的手机买了个 200 块钱的保护套，不值！\n\u0026hellip;\u0026hellip;行吧。\n接着说说第二点吧。\n2. 并发问题 第二点值得我们反思的就是并发问题，我们目前的解决方案很简单粗暴，在非 UI 线程中去解析数据，在 UI 线程中去分发事件来处理 UI。\n这是没问题，但是，不够细化。\n如果有其他耗时操作，比如读取文件，网络请求，要放在哪里呢？\n嗯，统一放在非 UI 线程中吗？肯定不行。这样可能就导致数据解析变慢，而 UI 的更新又是在数据解析之后的，这明显就会影响 UI 的更新，让户看起来可能就会卡顿。\n所以，我们应该有个细化操作，可以将非 UI 线程细分为：网络请求线程，文件读取线程，数据解析线程等。\n对应的操作就放在对应的线程中去做，这样达到各司其职，避免拥堵，让逻辑更合理。\n当然有的语言可以采用线程池技术去处理，其实，不用也没问题，但是前提是自己维护好、管理好这些线程，只要能达到目标，采用什么方式都是可以的。\n那这个为什么当初没做呢？\n还是因为时间太紧急了，而这个又属于低优先级任务，不算是功能点，算是优化点，所以，后面再加也是可以的。毕竟，我们是先保证功能能用、有人用，然后再去优化功能点的。如果一次做到最好很浪费时间，那就先做成，再做好从而让时间分配灵活些。\n接下来，再说说频控问题吧。\n3. 频控问题 啥是频控问题呢？\n嗯，你有没有想过这样一个问题：假如我点击一个按钮请求一次数据，那么，当我第一次点下按钮的时，到第一次数据过来时，这期间我们的按钮时应该让点击呢，还是不让点击呢？\n如果不让点击，用户就会觉得：这是不是卡了？如果让点击，那就会频繁地请求数据，导致出现一些无用的请求。\n那怎么办呢？\n我们可以让按钮可以点击，一直都可以点击，但是请求数据的时候就要做个判断了，如果当前正在请求 A 这个数据，后续如果还有请求 A 这个数据的动作，我们就直接忽略这个请求。\n这样以来，用户自己也点了，他觉得自己请求了，他的心理得到了满足；而实际上，我们也只请求了一次，我们的心理也得到了满足，双赢！也就是赢两次！\n那这样是不是太费劲了？\n每个接口我都得加个标记来判断吗？烦死了。\n其实也不用，我们考虑一下，如果网络正常的情况下，一个数据请求大概都是几百毫秒，我们就取 500ms 吧，然后，我们就对可点击的控件，比如Button，它的点击事件加个拦截，让其 500ms 内只响应一次点击事件，但是点击效果还是有的，只是拦截了点击事件。\n这样以来，所有使用Button的地方，他们点击事件在 500ms 只会响应一次，那么点击请求数据的场景，也就是 500ms 内最多请求一次了。\n有人说，如果网络不好，500ms 内数据还没请求过来呢？\n那也没问题啊，那就多一次请求呗，假如你的网络卡得要死，请求一次数据需要的时间是 T，那么你最多请求这个数据的次数就是T/500，假如 5000ms 才请求过来数据，那最多就是 10 个请求这个数据的调用，这还是发生在用户疯狂连点的情况下，用户的单身时间要足够长，手速要足够快、心态要足够爆炸，网络还要卡，这是多小小概率事件啊，比谷歌收购微软 还 腾讯收购阿里，真是离谱他妈给离谱开门，离谱到家了，我们就不用咸吃箩卜淡操心了，多干点有用的事吧。\n上述这个，就是频控问题，也就是我们要控制某个事件发生的频率，从而减少无效事件的发生次数，这样能节省流量，节省 CPU，各种节省，简直美滋滋。\n那这为啥一开始不做呢？\n嗯，还是没时间，要不是项目急着上线，产品经理猴急猴急地催，谁都想把代码写到最好。\n\u0026hellip;\u0026hellip;好吧。\n好，接下来就该吹吹我的加分点了，我都迫不及待了。\n加分点 终于到了加分点了，这个我可要往死里吹，先把优点列出来，然后该扩句的扩句，往死里写，不解释。\n1. 生命周期的控制 首先，第一个，就是我用了逻辑转移，也就是把直播间的逻辑处理从全局转移到了局部，在代码里就是从Socket中转移到了自己创建的RoomContext中，大家都知道，Socket是App一级的，就是全局的，它的生命周期跟App一样长，这样的话，就算直播间销毁了，这一块的逻辑还会有，可读性差，不利于维护。\n所以，我就自己创建了个RoomContex来处理直播间逻辑，这样一来，直播间的生命周期就跟着RoomContext走，生命周期就比App短，直播间没了，房间处理的逻辑也没了，有效控制了房间的生命周期，可读性好，容易维护。\n2. 代码的设计优先原则 这一块功能我用了大量的设计模式以及设计思想，代码完全解耦，拓展性强，后面如果有其他改动，就会非常容易。\n比如，我在消息分发的时候，使用了Map来存储事件，而不是用if-esle跳转，这样后续有新事件添加或者删除，就只需要添加/删除一个键值对就行，非常方便，且不会有其他影响。\n而且，项目的整体架构我采用的是分层模式，顶层是基础房间，第二层才是我们的语音直播间，如果将来要扩展其他类型的房间，直接在适合的层级添加一个对应的RoomContext即可，逻辑完全能够复用。\n我在房间层级的实现是采用的 MVC 模式，数据放在RoomContext中，完全和 UI 分离，即使将来要换皮，换 UI，完全不会影响到数据部分。\n最后，我设计了直播间的相关类图，将来如果有其他同学要参与到项目中，可以看下这个类图，逻辑应该就会清晰很多：\n大家应该还记得对象的 UML 图，如果不记得的话，就去复习下第 24 章。\n我们光看代码很容易迷失，看类图是不是清晰多了？我们看这个就知道谁继承谁，谁持有谁，当然，这个类图并不完善，因为只是列出了类名和它们之间的关系，并没有列出它们的函数和变量，所以看不到它们的功能，这个就要靠你去实现了，你可以看下相关的书籍，然后把这个类图补全，等到补全之后，你光看类图就大概知道整个项目的代码是怎么设计的了，这就是软件工程的必修本领——UML 图——的强大之处。\n等你看完本小册时，你再回来看下这个类图，看看它是不是和你补完的一样吧。\n总结 本章，我们讲解了一个项目的复盘实战，总结来说就是这么几点。\n反思自己的缺点，以及为什么会犯，要怎么改。 总结自己的优点，哪里做得好，值得大家学习。 给自己打分，建议不要太高，但是也别太低。 项目复盘必不可少，且是大公司的最爱。一般来说，我们要做到以下几点，那么就能从容应对各种复盘。\n提前列出自己的缺点，并想好应对措施和答词。应对措施是让自己反思的，答词是给别人听的。 反思缺点时候一定要认真，态度要真诚。其中认真是为自己考虑的，态度是给别人看的。 说优点时一定要放大，这里面有多少水分自己知道就行。放大是为了别人看得懂、看得清，知道其中的利害。 打分时，不要太高，也别太低，太低会让人觉得自己不够自信，太高会让别人觉得自己自大，别人心里都清楚的。 相信，看到这里，你应该比油条“老”那么一点了吧。\n好，那么关于技术的，我们到这里就结束了，后面的两章，我们就开始学习程序员必须掌握的基本功能——版本控制，我们就一起来看看Git是怎么使用的吧，我们下一章见。\n30. Git 基础:工作流程与原理 前面的 5 个章节，我们已经把一个项目的完整生命周期走了一遍，从需求分析开始，到项目的复盘，我们已经经历了一个完整项目的开发流程。\n不对不对，并不完整，你见过开发中不用提交代码的程序员吗？没有版本控制的代码安全感何在？程序员直接删库跑路怎么办？\n这肯定是不行的，所以我们要学习版本控制，那么，本章我们就开始来学这些东西。让你的代码不再随着电脑走，而是随着心情走，说白了就是放在云端，你可以随时随地拉取。\n好，我们就开始正题。\n版本控制工具 自太古以来，版本控制工具有两个，一个叫做SVN，一个叫做Git，日久天长，Git把SVN干死了，所以现在我们见到的大多数版本控制都是Git，SVN已经少生优生幸福一生了。\n版本控制工具是用来干啥的呢？\n就是用来控制版本的。\n比方说，我写了一首诗：辣条真好吃，夹馍更好吃。\n然后呢，我觉得不太好，想改改，但是又不能肯定能改得更好，所以想先保存下来，那咋弄呢？\n嗯，简单，我就把这首诗拍个照片保存下来，然后重新写，万一写得不好就把这照片拿出来直接在上面改就行。\n这就叫做版本控制：每次有改动，就拍个照片存起来，将来有一天想反悔，就可以找到旧照片，在旧照片上面改就行了。\nGit的工作原理就跟这个类似，只不过我们叫照片，Git叫快照，嗯，反正差不多。\nGit 的工作原理 要了解Git的工作原理，我们首先来了解下仓库的概念。\n对于Git来说，我们可以将我们的工作空间分为四个区域。\n工作区：我们的代码存放的区域，比如你在c:/workspace/helloworld目录下写代码，那么这个目录就是工作区。 暂存区：当你在工作区执行了git add之后，被add的文件就在暂存区了。 本地仓库区：当你执行了git commit之后，被commit的文件就在本地仓库区了。 远程仓库区：当你执行了git push之后，被push的文件就在远程仓库区了。 其实，我们实际只有本地和远端两个区域，也就是只有工作区和远程仓库区两个区域，而暂存区和本地仓库区，是我们虚拟出来的。\n举个例子：我要给玉皇大帝写封信。\n首先，我肯定用信纸写信，那么，我正在写的那个信纸，就是工作区；等我写完后，我就放在信封里，信封就是暂存区；等我都写完了，我就装进信封放在信箱里，这个信箱，就是本地仓库区；然后等邮递员把信取走送到邮局，这个邮局，就是远程仓库区。\n现在，我们打开编辑器，新建一个项目叫做helloworld，它存放在c/workspace/helloworld，然后我们在这个目录下执行命令： git init，这个目录下就多了一个隐藏文件夹.git，这个目录就变成了一个 git 目录，也就可以在这里面进行 git 对应的操作了。\n好，现在我们新建一个文件test.java，然后执行git status（查看当前 git 的状态），就会看到如下提示：\n1 2 3 4 5 6 7 8 9 on branch master No commits yet Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) hello.java nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) 第一行的意思是：你当前在master分支。 第二行的意思是：当前没有提交。 接下来的三行的意思是：hello.java没有被跟踪，可以使用git add来添加，添加后的文件就会被跟踪，也就是会被版本控制。 最后一行的意思是：没有文件被添加，但是存在没有被跟踪的文件，可以使用git add来跟踪。 当我们初始化一个git目录时，会默认创建一个叫做master的分支（分支的概念我们下一章节再说）。我们可以这么理解：分支就是一个文件夹，我们在某个分支上开发，就等于代码放在一个文件夹下。\n那么，什么是跟踪呢？\n跟踪指的就是：这个文件要不要进行版本控制。如果不进行跟踪，就是不进行版本控制，那么，后面你对这个文件的所有改动，git 都不进行记忆，可以理解为：拍照片时把你抹掉，不记录你的历史状态。那么，就无法把你还原到之前的状态。\n所以，我们可以执行git add hello.java来跟踪这个文件，然后再执行git status，就会看到如下提示：\n1 2 3 4 5 6 7 On branch master No commits yet Changes to be committed: (use \u0026#34;git rm --cached \u0026lt;file\u0026gt;...\u0026#34; to unstage) new file: hello.java 前两行我们不废话了，我们只看后三行。\n它的意思是：改动等待被提交，可以使用git rm --cached撤销暂存，新文件hello.java。\n用人话说就是：有个新文件被暂存了，也就是可以提交了，可以使用git rm --cached撤销暂存。\n如果我们执行git rm --cached hello.java撤销暂存会怎么样子呢？\n嗯，它就会变成未跟踪状态，也就是我们刚新建文件之后的状态。好，我们直接执行git commit -m \u0026quot;添加文件\u0026quot;来将这个文件提交一下，发现如下信息:\n1 2 3 [master (root-commit) 837dd77] 添加文件 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 hello.java 它的意思就是：master分支的代码已经被提交，提交的 id 是837dd77，提交的信息是\u0026quot;添加文件\u0026quot;，1 个文件改动，0 个插入，0 个删除。\n然后，我们再执行git status来看下：\n1 2 On branch master nothing to commit, working tree clean 意思很简单：当前位于master分支，没有需要提交的，工作区很干净。\n那么，一次提交就完成了。\n等等，你这些操作好像都是本地操作，并没有涉及到网络啊，既然有远端仓库，肯定要涉及到网络啊。\n没错，我们来创建一个远程仓库，这里我们使用 Gitee，我们在Gitee中选择新建仓库：\n然后输入仓库名HelloWorld，点击“创建”，就会自动生成一个远程仓库，并提示如下页面：\n我们使用git config --global user.name和git config --global user.email配置下用户名和邮箱，记得邮箱要验证下。\n然后，我们直接在我们的项目目录下执行: git remote add origin xxxxx，将 xxxxx 替换为你的远程仓库，这就等价于为本地仓库配置了一个远程仓库，远程仓库就是刚刚创建的HelloWorld仓库。\n然后我们执行git push -u origin master，也就是将本地仓库的代码上传到远程仓库，发现提示如下：\n1 2 3 4 5 6 7 8 Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Writing objects: 100% (3/3), 293 bytes | 293.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: Powered by GITEE.COM [GNK-6.4] To https://gitee.com/xxxxxx/Helloworld.git * [new branch] master -\u0026gt; master Branch \u0026#39;master\u0026#39; set up to track remote branch \u0026#39;master\u0026#39; from \u0026#39;origin\u0026#39;. 这就是本地代码上传成功了。\n好，我们刷新下Gitee的页面看看，就会发现如下：\n其中可以看到我们提交的文件、提交的信息，以及提交的时间。\n好，我们点击右边的克隆/下载，然后选择Https，点击复制，如下：\n然后我们在电脑上新建一个目录，在终端打开并跳转到这个目录中，执行命令git clone xxxx，其中xxx就是我们刚刚复制的地址，直接粘贴即可，就会发现它开始下载了，如下：\n1 2 3 4 5 Cloning into \u0026#39;Helloworld\u0026#39;... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. 这就表示我们已经把远程仓库的代码下载下来了，我们可以直接使用这个代码了。\n好，到这里，相信你已经可以上传并下载代码到Git了，那么，刚刚的那些git add、git commit、git push操作，你是不是感觉有点乱呢？\n我们这里就来梳理下。\n我们上面说过，我们的工作空间分为四个区，并且任何一个新文件都在工作区，我们就来列一下执行相关指令后代码的状态和区域。\n工作区：执行git add就到暂存区。 暂存区：执行git rm --cached就还原到工作区，执行git commit就到本地仓库区。 本地仓库区：执行git reset就还原到暂存区，执行git push就到远程工作区。 远程仓库区：执行git clone将整个仓库下载到本地，或者执行git pull将变化的部分下载到本地。 我们把流程整理如下图：\n那么，这些我都懂了，但是有的代码我不想被跟踪呢？比如我的本地配置文件。\n你可以不git add啊。\n这样太麻烦了，它老是提示，烦死了。\n嗯，那我们就可以使用gitignore文件了。\ngitignore 文件 gitignore 文件，顾名思义，就是 git 忽视文件，让你的文件可以被 git 无视，从而不进行跟踪。\ngitignore 文件的规则如下：\n所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 我们可以直接看官方的模版。\n我们在helloworld目录下新建一个.gitignore 文件，然后添加如下内容：\n1 2 world.java /nb 这个就意味着我们的world.java文件会被无视，并且/nb目录也会被无视，然后我们在项目中创建world.java文件，紧接着再执行git status命令，发现输出如下：\n1 2 3 4 5 6 7 8 On branch master Your branch is up to date with \u0026#39;origin/master\u0026#39;. Untracked files: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to include in what will be committed) .gitignore nothing added to commit but untracked files present (use \u0026#34;git add\u0026#34; to track) 嗯，只有.gitignore文件提示了，world.java并没有被提示，然后我们再创建nb文件夹，发现还是这样。\n我们再把.gitignore文件中的world.java删除，再执行git status命令，发现world.java文件又被提示了。\n到这里，我们已经明白了gitignore文件的用法了，这里就不再废话了。\n总结 本章，我们简单地介绍了git的工作流程，以及git工作区的概念，并且我们梳理了文件在不同区域之间的流转，最后，我们介绍了gitignore文件的使用，我们再来回顾下。\ngit有四个区域：工作区、暂存区、本地仓库区、远程仓库区。 工作区：执行git add就到暂存区。 暂存区：执行git rm --cached就还原到工作区，执行git commit就到本地仓库区。 本地仓库区：执行git reset就还原到暂存区，执行git push就到远程工作区。 远程仓库区：执行git clone将整个仓库下载到本地，或者执行git pull将变化的部分下载到本地。 gitignore可以用来对文件进行无视，从而让git不跟踪对应的文件。 其实，我们只需要牢牢记住一条指令——git help——即可，任何时候，如果你忘了该怎么操作，只要执行一下这条指令，你就知道下一次该干什么了。\n最后，再给大家推荐一本免费的书籍 Git pro，有空可以看看，你对git的认识就会大大提高。\n我们下一章节就来讲一下git的 GUI 工具和分支的操作，我们下一章见。\n31. Git 实践: 常用的GUI工具和命令 上一章，我们讲了git的工作流程和原理，本章我们就回到使用的层面，来看看日常工作中，该怎么使用git进行实操。\n其实，就使用来说，我们可以把git的操作分为两类。\n一类是用GUI工具的，这种看起来比较直观，比较简单，但是缺点就是耗内存，需要单独安装软件，有些场景下使用起来不是很方便。\n另一类就是使用命令行的，这个刚用起来比较费劲，让人有想骂娘的冲动，但是时间久了就会觉得真香，而且不需要安装额外的软件，熟了之后你就会发现真方便。\n本章我们就一起来看看这两类用法。\nSourceTree GUI 工具中，最好用的应该就是SourceTree了，大家可以去官网下载对应的版本，这里就不废话了，我们直接下载完成安装即可。\n我们安装完启动，就会看到如下画面：\n我们直接点击“新建” -\u0026gt; “添加已经存在的本地仓库”，然后选择我们上一章的helloworld项目目录即可，然后就会发现我们的项目已经列出来了。\n然后我们打开我们的项目，随便修改一个文件，比如，修改我们的.gitignore文件，添加一行/nm，然后就会发现sourcetree中项目的目录右边有个 1，如下所示：\n这就表示我们的项目有一个改动等待提交。\n我们双击打开，如下：\n其中最左边列出了我们项目的分支，上面是本地分支，可以看到当前只有一个master分支，并且有个小圆圈，这表示当前所在的分支就是master，下面有“远端”，表示远程的分支。中间列出了.gitignore文件，并且被打勾，表示已经暂存，右边列出了文件的改动，-表示删除了一行，+表示添加了一行。\n现在，我们选中.gitignore文件，点击右键，选择“重置”，如下：\n就会发现文件不提示了，其实，重置的意思就等于放弃修改，也就是把文件还原到上次提交后的状态。\n这不是我们想要的，我们希望修改保留，但是不放在暂存区，怎么做呢？我们只需要取消文件前的打勾即可，如下：\n这就是取消暂存，等价于执行了git rm --cached命令，如果我们想要提交呢？\n我们先勾选文件，让它变为暂存文件，然后在下方输入框中输入提交信息，点击右下方的“提交”即可提交，等价于执行了git commit；如果你同时勾选了下面的“立即推送变更到 origin/master”，则文件在提交的同时也会推送，等价于同时执行了git push。\n如下图：\n1 代表提交信息。 2 代表提交。 3 代表同时推送到远程仓库。 好，我们执行完提交之后，再来看看历史记录，我们点击左侧的“历史”，就能在右边看到历史的提交记录，如下图：\n我们选择任意的一个提交，下方就会列出提交的具体内容，如下：\n这样很方便以后的查找，当然，有些想偷偷摸摸干坏事的人，这里就要小心了，你的每一行代码都会记录在案，作为呈堂供词，千万别再胡写八写了。\n有人说，提交我知道了，下载代码怎么弄呢？\n我们关闭我们的仓库，回到sourcetree的首页，然后选择“新建” -\u0026gt; “从URL克隆”，这就会从你输入的地址下载代码，等价于我们上一章执行的git clone命令。\n那么，要拉取变动的内容呢？\n我们就可以选择左边的“远端” -\u0026gt; “拉取origin/master到master”：\n这也就等价于执行了git pull指令。\n好，到这里，你应该知道了sourcetree的每一个操作跟对应的指令的关系了。\n其实说白了，sourcetree就是把指令实现的功能，用图形表示出来，提供一个可视化的操作方式，使用起来更直观、更方便而已。\n当然，对于高手来说，命令是最好的、最快捷的。\n终端命令 终端命令是装 x 耍帅必备的看家技能之一。一个程序员技术的高低，一方面取决于头发的稀少程度，另一方面就取决于终端命令的熟练程度。\n不仅Linux有终端命令，我们的git也有很多终端命令，我们在这里就列出一些常见的命令，来提供给大家记忆并使用。\n初始化命令 git init，将当前目录初始化为一个git目录。 克隆命令 git clone xxxxxxx，拉取远程仓库的代码到本地。 暂存命令 git add xxx，其中 xxx 是文件名，将对应文件添加到暂存区，如果将xxx换为.，就是将当前目录的所有文件添加到暂存区，并且 xxx 支持正则表达式。 撤销暂存命令 git rm --cached xxx，将 xxx 撤销暂存，同样可以替换为点号，同样支持正则表达式，下面的 xxx 都一样。 提交命令 git commit -m \u0026quot;aaa\u0026quot;，其中 aaa 为提交信息。 回退版本命令git reset bbb，用于将本地版本进行回退，其中 bbb 是你想要回退到的版本号，将bbb替换为HEAD^可以直接回退到上一个版本。HEAD后面^的个数表示回退的版本的个数，比如， HEAD^^就表示上上个版本。 推送命令git push -u aaa bbb 将本地仓库的代码推送到远端，其中 aaa 表示远程仓库，bbb 表示本地分支。其实，当我们已经提交过一次之后，我们就可以不再输入aaa bbb，而是直接使用git push -u即可。 拉取命令git fetch，拉取远程仓库的代码到本地。 合并命令git merge aaa，将当前分支的代码和 aaa 分支的代码合并，当然可能会出现冲突。 查看命令git diff，对比当前分支和合并分支的异同点。 拉取合并命令git pull，将远端仓库的代码拉取到本地并合并，等价于同时执行了git fetch和git merge。 查看状态命令git status，用得最频繁的一个命令，用来查看当前目录的状态。 接下来，我们就来看看分支命令：\n新建分支 git branch -xxx，从当前分支新建一个分支 xxx。 切换分支 git checkout xxx，从当前分支切换到 xxx 分支。 从当前分支检出新分支：git checkout -b xxxx，xxx 是分支名，b是 branch 的简写，就表示分支，这其实就等于先新建分支，然后切换到新分支，等于同时执行了git branch -xxx和git checkout xxx这两条指令。 合并分支 git merge xxx，将当前分支和 xxx 分支合并。 删除分支 git branch -d xxx，将 xxx 分支删除。 查看分支 git branch，会列出本地的所有分支，如果加上参数-a，就会列出本地和远端的所有分支。如果加上参数-v，就会看到所有分支的最新一次的提交信息。 最后，也是我们最需要的，就是log命令：\n查看提交记录 git log。 查看最近的 3 次提交 git log -p -3，其中p表示param，也就是参数的意思。 单行展示提交信息 git log --pretty=oneline。 格式化展示提交记录 git log --pretty=format。 以图表形式查看提交记录 git log --graph。 以上就是我们常用的命令，当然，git 有很多命令，大家在工作中都可以搜索出来，我们这里就不再废话了。\ngit 分支 终于到了分支的部分了，其实，git 最重要的就是分支，如果没有分支，git 的存在也就没有什么意义了。\n那么，什么是分支呢？\n我们可以这么理解，我们的代码就像是向上生长的树，我们刚开始的代码就是树干，也就是master分支，随着时间的推移，我们开发了很多版本，就像树干生出了很多树枝，也就是master分支生出了很多很多的分支，这个时候，我们想要回到之前的某个版本上，我们直接切换到那个分支即可。\n到这里，你应该明白了，分支就是一个个的代码版本，随着时间的推移，随着项目的发版和迭代，我们就拥有不同版本对应的不同代码，那么，每一个版本对应的代码都应该是一个分支。\n我们可以在分支之间切换，也就是回到不同版本的代码上去。\n好，我们就来实际操作一下。\n首先打开我们上一章的helloworld项目，我们默认就是在master分支，现在，让我们从master分支创建一个新分支test_branch1出来，我们直接执行git checkout -b test_branch1即可，根据前面的命令，我们知道这是创建一个新分支并切换到这个分支。如果你想用sourcetree，你就直接点击顶部的“分支”。\n然后就回弹出如下一个创建新分支的提示框，直接输入test_branch1然后点击“创建分支”即可。\n这样，我们就创建出了一个新分支，我们直接执行git status，发现打印如下:\n1 2 On branch test_branch1 nothing to commit, working tree clean 这就意味着我们已经在test_branch1这个新分支上了。然后我们修改一下hello.java这个文件，添加一行文字hello git，然后提交一下。这样，我们的test_branch1分支上的hello.java就是带有hello git的，我们的master分支上的hello.java就是不带hello git的，我们可以切回到master分支验证一下。\n那么，如果将来有一天，我想让master分支也跟test_branch1分支一样，都带有hello git的话，该怎么办呢？\n这就要说到分支的合并了，我们直接切到master分支，然后执行git merge test_branch1，这样，就会将test_branch1上的提交合并到当前的master分支，如果我们没有针对同一个文件做修改，那么git会自动将所有的文件进行合并，如果我们对同一个文件做了修改，那么就会出现冲突，这个时候我们就需要手动解决下冲突了。\n好，我们切换到master分支，在hello.java中添加一行文字hello git2，然后提交一下。\n此时，我们的master分支是hello git2，我们的test_branch1分支是hello git，它们自己分别有改动，并且是针对同一个文件的，那么，现在我们让master分支合并一下test_branch1分支，我们直接执行命令:git merge test_branch1，或者在sourcetree上执行如下操作。\n先选择顶部的“合并”：\n然后在弹出框中选择“合并已抓取”，并选择origin/test_branch1分支（如果没有这个分支，就是没有 push，push 下就可以了）：\n此时，我们就会发现合并冲突，因为我们两个分支都修改了同一个文件，如下：\n1 2 3 Auto-merging hello.java CONFLICT (content): Merge conflict in hello.java Automatic merge failed; fix conflicts and then commit the result. 此时，我们打开sourcetree，选择文件状态，就会看到文件被标记为感叹号，并且右边列出了冲突的内容：\n其中，感叹号表示冲突，右边的\u0026lt;\u0026lt;\u0026lt;HEAD和=====之间的内容表示当前分支的改动，而=====和\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;之间的内容表示合并的分支的改动，这里我们要手动处理下，我们把两行都保留即可，然后把====和\u0026gt;\u0026gt;\u0026gt;以及\u0026lt;\u0026lt;\u0026lt;\u0026lt;删除即可，如下：\n可以看到，它告诉我们本次修改添加了一行hello git，我们注意到hello.java还是带有感叹号，这就需要我们手动把文件标记为已解决了，我们选中文件，右键点击，然后选择解决冲突 -\u0026gt; 标记为已解决。\n这样，我们的一次合并就完成了。\n当然，如果两个分支没有修改同一个文件，那么git就会直接把我们的代码自动合并，也就不会有上述处理冲突的过程了。所以，我们要尽量避免同时修改同一文件。\n怎么避免呢？那就要只添加不修改，遵循开放闭合原则，遵循 OCP 了。\n总结 本章我们着重讲了sourcetree的操作，以及一些终端命令，最后，我们讲了分支的概念、分支的合并和冲突的解决方式，我们再来回顾下：\nsourcetree提供了一个 GUI 用来操作 git，操作直观，查看文件很方便。 终端命令不需要打开额外的软件，操作简便、高效、快速，但是不够直观，且不容易记忆。 分支代表着git的每个代码版本，我们可以切换不同的分支来回到历史版本。 分支的合并可能会出现冲突，所以我们要尽量避免修改同一个文件。 最后，在这里，我要鼓励下我们每个人多使用终端命令，或者说，我们对git的日常操作尽量用命令，只要合并不冲突，就尽量使用命令；当合并冲突的时候，再使用sourcetree等可视化工具来对比差异，从而进行修改。日久天长，锻炼的不仅仅是你的打字速度，同时也是你对git系统的认识。到最后你会发现，原来我们的编辑器、我们的操作系统、我们的计算机，全部都是跑在一套套的命令里面的。\n这里我就不再废话了，本小册的所有技术层面的知识到这里就完事了，接下来的三个章节，我们就一起来返璞归真，大道至简，站在做人的层面来俯察下技术的真谛吧。\n32.做事的核心: 可靠 可靠是最聪明的聪明。\n世界上最聪明的事情是什么呢？\n可靠！\n那么，什么是可靠呢？\n可靠就是事事有回应，件件有着落。\n那么，怎么变成可靠的人呢？\n你需要先思考几件事情。\n从感性变为理性 自我感觉良好是大部分人的通病。\n人发明了镜子，却只是用它来臭美；上帝给了人脑子，大部分人却用它来做坏事。\n反思自己有这么难吗？承认自己的不足有这么难吗？如果你站在你不是你的角度，你早就想把自己揍一顿了。\n你可以静下心来想一想，当你做了一件错事的时候，有人批评你，你第一个反应是什么呢？\n是反驳？是辩解？还是反思？\n大部分人的第一反应都应该是不服气：你竟敢这么说我！一点面子都不给我，大家都是人，都有做错的时候，你凭什么这么说我？\n当你听到对自己不利的话的时候，你的第一反应不是反思他说得对不对，有没有道理，而是先反驳回去，为自己找回面子，所以说，你要的不是道理，是面子。这个时候你是感性占上风的，你不是被脑子左右的，而是被感情左右的，你的想法、你的语言、你的行动是不经过大脑的。好听点说就是冲动，难听点说就是急眼了。\n这种情况下你千万不要做决定，千万不要做决定，千万不要做决定。你可以先让自己做一遍快速排序，做对了再去做决定。\n有句话说：我们最大的敌人是自己。这是不对的，我们最大的敌人不是自己，而是自己的情绪。\n每个人都有两个自己，一个是理性的，一个是感性的，理性的自己跟着道理走，让自己变得更清醒；感性的自己跟着情绪走，让自己变得更糊涂。感性的自己注重的是你当下的感觉，只管你当前爽不爽，理性的自己注重的是长远的利益，考虑的是划算不划算。比如，618 期间、双 11 期间你的冲动消费，你花钱的那一瞬间确实挺爽的，你需要的不是买的东西，而是付款那一瞬间的刺激感，此时你就是感性主导的；而当几天过后，你买的东西就开始盖泡面了，开始吃灰了，你就开始后悔了，此时你的理性又出来了。\n可见，理性的你大部分时候都是后知后觉的，那么，当你想冲动的时候，你可以让子弹飞一会儿，不要急于下决定，这样就多少能降低一些损失。\n做事的时候，我们要理性，不要感性。你越理性，你做事就越有逻辑，成功率也越大，计算机为什么比人牛呢？因为它是 100% 理性的。当你绝对理性的时候，你就不是人，你就是神，此时你不是站着的，而是飘着的，你的双脚就离地了，感性就关闭了，聪明的智商就占领高地了，就能大大提高决策的成功率了。\n那么，怎么才能变得理性呢？\n很简单，站在你不是你的角度看问题就可以了。\n当你不是你的时候，你做的一切都与你无关，既然与你无关，就不涉及到你的利益，也就不会触发你的情感波动，那么，你看待这件事就是理性的，那么，你的决策就是偏向正确的。\n举个例子，你在挤地铁的时候，看见某人插队了，你是不是想揍他一顿呢？\n肯定想啊。\n那么，假如插队的这个人是你，别人是不是也想揍你一顿呢？\n回答我的问题，是还是不是？\n是！\n这就对了，假如你不是你，你自己都看不顺眼这种行为，你自己都想揍你自己，所以，插队这种行为是错误的。但是如果你是你，你就对自己抱有同理心，你就会觉得这种行为是对的，不同的视角导致不同的结论。所以，转换视角很重要。\n当你变得理性的时候，你就想明白很多事物的运转规则，你也会明白很多事物的运转逻辑，你的问题就会多起来，你的求知欲也会强烈起来，你就变得不容易冲动了，很多事情你也不会难于抉择了，但是同时，你也会变得严苛了，虽然你的心是善良的，但是给人的感觉却是威严的。有人开始怕你了，因为你讲道理，讲逻辑，不容易被忽悠了，而人人都喜欢和傻子打交道。这也从侧面说明一件事：世界上还是感性的人多，不用管他们，老子要做的就是鹤立鸡群，就是木秀于林，凭什么为了照顾你们的情绪让我放弃我的正确选择呢？我是为自己活的，为道理活的，不是为了照顾你们的情感活的。如果，所有的事情都要考虑个人情绪，那么，规则就无方圆，法律将不公平，一切都将腌臜不堪。\n世界的前进需要理性的人，纵观历史，哪一次社会前进靠的不是理性的人？\n理性的人更睿智，更可靠！理性是可靠的前提。\n给出结果大于给出建议 有一种人，凡是你问他问题，他都能给出 n 种建议，但是就是不能给出决定，这种人就是聪明。他太聪明了，没给出决定就意味着出事了不怪他，但是如果成功了就归于他的建议。\n其实，我们自己想想，真正难的不是出主意，而是决策。反正出主意不需要承担责任，他说你可以这样，你可以那样，你可以先这样再那样，一张嘴开出了天花，随便说。\n那好，键盘给你，你来给我写一下。\n他就懵逼了，他不会啊，你让他说说可以，但是让他写出来，那简直就是公鸡下蛋。\n给出一千种建议的人是很聪明，但是不如直接给出结果的人。大部分情况下，我要的是结果，而不是建议。\n当然，给出建议的人肯定比连建议都给不出的人强。但是最高级的肯定是直接给出结果的人。\n大厂的面试为什么要有上机算法题呢？因为光靠嘴说，真是太容易了，人人都是聪明人，都能张嘴就来。不上机实战一下，怎么淘汰掉那些牛鬼蛇神。\n给出结果比给出建议更可靠，更能让人觉得你牛 X。\n举个例子，测试主管拿着手机来找我，说这里有个 bug，我一看就说，这是服务器的错，你去找下服务器吧。\n仔细想想，我做得也没错，这确实是服务器的错，而我也确实聪明，一眼就看出了问题，避免自己背锅。\n但是，我不会这么做，我会找到这个错误的地方，然后告知服务器去修改，然后告诉测试主管，这个是服务器的问题，已经跟他说了让他修改了。我不仅发现了问题，还直接解决了问题，这个问题，到我这里，就彻底终结了。\n这个时候测试主管想的是什么呢？\n他会想，这个人真靠谱，做事效率也高，有机会一定要抬他一下。\n同样一件事，不同的处理方式就有不同的效果，仔细想下为什么呢？\n很简单，这件事到我这里彻底结束了。说白了就是，我直接给出了结果，而不是给出了建议。\n那么，是不是所有的事情都直接给出结果好呢？\n不是！\n在你的职责范围内的事你直接给出结果，不在你的职责范围内的事你给出建议。\n学会拒绝 大家都知道一个道理，做的事情越多，就越容易犯错。\n其实，这句话不够准确，并不是做的事越多，就越容易犯错。而是做的事越不熟悉，就越容易犯错。\n比如，1+1 你做 100 次也不会错，因为太简单了。\n我们每次做的事都不同，这就有不同的处理方式，每次有新的问题，都不能用老的经验，所以就容易出错了。\n比如，有次我请假期间，项目要上线，就找到 A 同学来负责上线，结果这哥们没上过线，不熟悉上线流程，自己也不检查，直接打了个测试环境的包提交到线上了。\n这下可热闹了，让你上线你却上了个 bug，你要是看公司不顺眼想让它倒闭就直接说，不用来这一套。\n其实，这个事情的处理很简单，只要这哥们当初直接拒绝就好了。但是他非要表现自己，而自己又不熟悉，自己亲手立起来的牌坊，自己又亲手推倒，悲哉，痛哉，呜呼哀哉。\n所以，我们要学会拒绝，拒绝不丢人，拒绝是对自己有清醒的认识。明知不可为而为之，结果还弄错了，这才是最丢人的事。\n你直接拒绝一个人，他的心情就是从 0 分到 0 分的，毫无波澜。你先答应一个人，再把事情搞砸，他的心情就从 0 分直接飙到 10 分，然后又直接跌下来，这跟坐过山车似的，并且是以沮丧结尾的，你说刺激不刺激。心理承受能力差的人，可能就需要叫\u0026quot;erla erla\u0026quot;了。\n所以，你还不如直接拒绝，让他直接死了这份心，干净利落毫不拖泥带水，既不让自己有压力、有痛苦，也避免他的心理波动，从而减缓他的情感痛苦，变相地延长了他的寿命。\n换位思考 最后一点，就是要换位思考，这是理性的核心，就像六大设计原则中的开放闭合原则一样。\n站在你不是你的角度，就是换位思考。换的是“感性的你”和“理性的你”的视角。\n给出结果而不是给出建议，也是换位思考。换的是“给出结果之后对方的心理”和“给出建议之后对方的心理”的视角。\n学会拒绝还是换位思考。换的是“你直接拒绝后对方的心理”和“你接受了但是把事情搞砸了之后对方的心理”的视角。\n所以，学会换位思考吧，大部分情况下“你以为他以为的”和“他实际以为的”并不是一样的。\n比如，你点了外卖，外卖小哥说：我到了。你以为的他到了是到你家门口了，而他说的到了是还在电梯里，快到了。他为了省自己的时间，就故意说到了，让你在门口等他呢。\n假如换位思考一下，你就都懂了。\n换位思考就是“影分身之术”，一定要学会。\n总结 本章节是我们批斗自己的第一节，我们从 4 个方面来对自己进行测试，然后针对自己的 bug 提出了如下的 fix 建议：\n让自己变得更理性，这个前提是站在自己不是自己的角度。 能给出结果的情况下尽量给出结果，给不出结果的情况下，就给出建议。 对于自己没有把握的事情，一定要学会拒绝。 换位思考是理性的核心，是非科学中的科学，最值得学习。 那么，你能否修复自己的这些 bug 呢？嗯，站在你不是你的角度，你大概率都能修复了。\n33. 沟通的核心: 高效 什么叫沟通呢？\n这不废话吗，不就是你听我说一会儿，我听你说一会儿吗？\n不，这不叫沟通，这叫拍闲话，或者叫无效沟通。\n沟通是以传达信息为目的的，所以，以传达信息为目的的交流才是沟通。\n沟通的目的 沟通的目的就是传达信息。\n比方说，A 对 B 说：今天天气好热啊。\nB 说：是啊是啊。\n这就不叫沟通。有人说，这怎么不算呢？这不就传达了信息吗？传达的信息是“今天天气好热啊”。\n不对。这虽然传达了信息，但不是以传达信息为目的的，而是以“发牢骚，找话说”为目的的，所以就不叫沟通。\n再比如，你在玩 LOL，遇见了对面一个盲僧，你一看段位，好家伙，大师级别的，你觉得可能打不过。于是开局就喷他：盲仔，小学僧，段位挺高的啊，代练代打的吧。\n这就是沟通，你传递的是一些侮辱的信息，那么，你的目的是什么呢？不就是“刺激他，激怒他，让他失去冷静全盘针对你，从而让你有可乘之机吗”。没错，你就是以这个为目的去传达信息的，所以这就是沟通。\n所以，当你想跟某人沟通之前，先想想你本次沟通的目的是什么；当你沟通完之后，你再反思下你的目的有没有达到。这样形成一个完整的链，才能保证滴水不漏。\n比如，开需求分析会议，目的就是为了让大家都了解需求，并且解决大家的疑问。开技术研讨会，目的就是为了拿出一个可行的技术方案。\n所以，每一个会议都是一个沟通，而每一个沟通都有一个目的，所以每一个会议都有一个目的。没有目的的会议就不要参加了。一直开没有目的的会议的公司就是垃圾，垃圾到垃圾回收器都不想回收的程度。比如大多数形式主义会议。\n好，我懂了，沟通的目的是传达信息，那么，这个信息要怎么传达呢？光靠嘴说吗？\n当然不是。\n沟通的方式 沟通的方式有很多，通过声音交流只是其中一种。\nhi，美女，约吗？\n滚！\n这就是声音沟通。\n哟，写 bug 呢？\n我弄死你！\n这也是声音沟通。\n我们日常的沟通方式，基本上除了声音就是图像。\n比如，你看到个美女，想去加个微信，你怕她拒绝，就“先亮了亮自己的余额宝，又亮出了自己的微信二维码”。\n先亮自己的余额宝是传达信息，亮自己的微信二维码是目的，这就是有效沟通。\n其实，沟通的本质是什么呢？\n就是输入和输出。\n我表达了我的意思给你，那么，我就是输出者，输出的是我的信息，你就是输入者，输入的是我输出的信息。\n对于我们每个人来说，输出很简单，有很多种方式。但是，输入却太难了，因为对方不是计算机，不是敲几行代码就能直接输入的。对方是人，是有感情的、会受到情绪影响的生物，所以，合适的输入方式就很有必要了。\n输入是受到输出方式影响的，所以，我们要努力的方向就变成了：怎么输出，或者说是：怎么表达。\n我们表达信息的的方式有很多，上面说的声音和图像，说白了就是听觉和视觉。\n我们可以通过触觉来接收信息，比如盲文；我们可以通过嗅觉和味觉来接收信息，比如吃饭；我们甚至还可以通过第六感来接收信息。\n我们仔细想一想，如果你要向一个人表达一幅画有多好看，任凭你怎么描述得天花乱坠，都不如直接把画拿给他看更高效；你要表达一首曲子有多好听，不如直接让他听听更高效；你要表达一个框架有多好用，不如直接把它写出来展示给别人更高效。\n所以，这里的核心莫非就是两个字：高效。\n那么，怎么才能高效呢？\n高效沟通 首先，就是选择合适的表达方式，表达要直接，要简单明了。\n比如说，我们日常的开发中，免不了有客户端跟服务器的沟通，那么，我们与其在那撕半天，倒不如直接上接口文档，这样不仅节省了双方的时间，还能让后面的开发者拿过来看。所以，对于开发来说，文档是很重要的，这属于一个通用基本功。\n再比如，我们跟产品讨论需求的时候，一定要先通过口头沟通好、理解好双方要表达的意思，然后再用文档记录下来，因为大部分产品和技术想的都不是一回事，你以为他以为的，和他以为你以为他以为的，可能完全不同，所以，需要先让 A 描述给 B 听，然后 B 再用自己的理解描述给 A 听，这样对齐一下双方的想法，完事后再让 A 记录下来，确保万无一失。\n当然，并不是说，文档就只能记录文字，我们还可以附上图表、图片以及视频，来尽可能更直接地表达我们要表达的意思。\n而且，我们的文字不要太博大精深，因为中国的文字太博大精深了，所以我们要言简意赅一些，比如：尽可能不使用双重否定。\n比如这么一句话：“这个我觉得不实现的话不太好。”你直接写成：“这个我觉得还是实现了吧。”这不就行了嘛。\n我们的文档不是写 600 字作文，是给自己人看的，要尽量简单明了，尽量直接，尽量高效。\n其次，要直接表达出自己的意图，采取先果后因的方式。\n我们跟产品或者开发沟通，肯定是带有目的的，我们要直接表达出自己的想法，不要有模糊的词语，不要弯弯绕绕。\n比方说，有个功能实现起来很复杂，并且时间又紧急。那么我就找到产品说：“这个功能不太好实现，时间不太充足，我估计不能如期提测。”\n这句话就是坑，听的人都不知道你到底要表达什么，你是觉得不好写，想改一下功能？还是说时间不够，想延期提测？而你又用了“不太”“估计”这种模糊词语，到底要延期几天？\n那么，我到底要怎么说呢？\n“这个功能不好实现，除非延期一天，建议把这一块改成这样。”\n这个表达就堪称完美。\n直接说了功能不好实现，需要延期一天，而且给出了自己的看法。\n我们在开发中，就应该这样表达：直接说出目的。\n那么，为什么要采取先果后因呢？\n因为大家大部分时间都是很忙的，有的事情也就一个改动，不需要扯那么多没用的，那么原因就可以省了不说了；再者，大家都是人精，你只要说出了结果，他就知道你要干什么，这么干的原因是什么，就不用再那么唠唠叨叨的了。如果，他真的不明白这么做的原因，你再说原因也不迟。\n所以，“先果后因”在一些情况下可以省去原因，变相节省时间，提高效率。\n沟通的结果 其实，沟通的结果说白了就是对方接受和不接受，换句话说就是目的有没有达到。\n达到了当然是最好的，那么，如果没达到呢？是不是就是我们自己的问题了呢？\n其实，我们在沟通前就应该想好，对方有多大的概率接受这件事，我们要做的，就是想法设法提高这个概率。\n其中最重要的，还是我们上一章说的换位思考。\n人都是利己的，无一例外。有人说，自己爱国，大公无私，那你咋不去爱外国，所以，这还是利己，只不过是大的利己而已。\n既然人都是利己的，那么，我们本次沟通的目的，就不能伤害对方的利益，反而得让他觉得对自己有利。\n比如：我们的 app 有个送礼的功能，我需要给服务器传个收礼人的id过去。但是，这样只符合当前的需求，如果将来扩展了个多人送礼，就需要修改了，所以我就想把这个id改成一个数组ids，这样方便以后扩展。所以我就找到服务器，直接说想要把id改成ids，服务器不答应，他说如果将来多人送礼，多次调用这个接口就行了。站在服务器的角度来说，他就是不想改而已，那么，怎么让他想改呢？很简单，找到他的一个bug就行了。\n“如果是一个人想给多个人送同一个礼物呢？调用多次接口，明显费流量、效率还低，改成数组的话，将来咱们都不用改了。”\n服务器就妥协了，因为站在他的角度看问题，确实是对他有利的，因为他将来也不用修改了。\n这就是换位思考。\n其实，对于大部分有经验的开发来说，只要你一说id要改成数组，他立刻就懂了，这就是先果后因的原因。\n有人说，拍马屁能提高沟通的成功率。\n没错，确实是这样。有时候，拍马屁也是值得的。\n正如我们上一章所说，大部分人都是感性的，他们做事决策不取决于逻辑，而取决于自己的情绪。所以，只要你能吹，能奉承，能拍马屁，拍得好，拍得妙，拍得呱呱叫，就能让他感性占上风，他觉得自己轻飘飘的，云里雾里的，都飞起来了，双脚离地了，智商关闭了，感性和冲动占领高地了，他一冲动，就应承了，赶紧让他签字画押，一定要赶在他的理性回来之前把事情搞定。\n你说，这么做是不是有点儿趁人之危，有点卑鄙呢？\n非也非也，能被拍马屁拍得美滋滋的人，大概率自己都不觉得这样卑鄙，因为对于他来说，我答应这件事对我造成的损失，完全可以被你那几句马屁带来的好心情弥补回来。\n所以，有时候，马屁也是一味良药。\n但是，对于我们自己，还是尽量做理性的人，因为，我们大部分人还没有资格、没有资本做感性的人。\n总结 其实，对于聪明人来说，沟通根本就不需要任何技巧，因为大家都心知肚明，但是我们还是要照顾那些不聪明的人，对于不聪明的人，我们的沟通方式就很重要了。\n我们要注重的无非就是以下几点：\n带有目的进行沟通； 沟通有很多方式，采用最合适的方式表达自己的目的； 沟通要高效，要直接表达目的，要先果后因； 要学会换位思考，用对方的利益打动对方。 本章我们站在感性的角度，总结了沟通的几个重点，其实，沟通的核心无非就是把目的转达给对方，只要围绕着这个核心，加上一定的手段，相信大部分事情都不难办。那么，下一章，我们就要回到理性的角度，来看看怎么通过学习来提高自己的能力了。\n34.学习的诀窍: 总结 学习是最伟大的事情，是人的基本行为。一些动物通过学习变得比其他动物更强大，自称为高级动物，也就是人。在这些人中，有一部分通过更好的学习，变得比其他人更强大，被称为“人上人”。\n所以，学习就是造物主给我们最大的馈赠，这是人人都有的技能，就看我们会不会用它了。\n如何学习 一谈到学习，我的话就多了，从 15 年毕业开始，到现在，我没有停止过看书，即使在春节这种特殊的日子里，晚上也会去挑几本书看看，因为有很多东西，特别是知识方面的东西，只有看书，慢慢地看，一行一行地看，一个字一个字地看，反复地看，才能细嚼慢咽，才能领会到其中的意思。\n这是看视频所领悟不到的。换句话说，如果你看视频，你追求的是学得快，而不是学得深；因为你的思路是跟着视频走的，能停下来思考的机会不多。如果你看书，你可能学得慢，但是学得就深，因为你可以停下来去思考。\n所以，这里我总结一种方法：可以先看视频，快速了解你要学的东西，跟着视频讲解的思路去理解消化；然后再找专业的书籍去细读，一定要思考，要对比，对比自己看到的、想到的，跟视频里不同的地方，要有自己的理解；完事之后去看书评，看别人的评论，看别人的提问，看别人的回答，然后尝试自己回答。这一套流程下来，你一定会有很大的收获，并且很难忘记。\n然后，我们还要学会反思，学会举一反三，学会类比，学会归纳，学会总结，学会抽象。\n学习应该是一个自发性的行为，不应该是被逼迫的。如果你是被逼迫的，那么请你跟逼迫你的那个人生活一辈子，他对你来说，绝对是一个无尽的宝藏。\n因为我们每个人都是非自律的，都在不断地跟自己体内的惰性对抗，而能逼迫你的人，其实就是在给你加油打气，在帮助你成功。\n说白了，就是他在帮你坚持。\n坚持学习 坚持是最困难的事情，坚持是成大事的人必备的素养，朝三暮四的人不会成气候。\n什么叫坚持？\n今天做了，明天做了，连续做了一个月，第二个月不做了，这不叫坚持，这叫上头；今天做了，明天不做，后天不做，第十天再做，这样每隔 10 天做一次，做了一年，这就叫坚持。\n换句话说，坚持不是短时间内的频繁重复，而是长时间的规律性重复，是一种长周期的、可重复执行的、有规律的行为。\n在我看来，我们要坚持的无非就是两件事：读书和写作。读书是输入，写作是输出。\n读书好，多读书，读好书。这是谢婉莹老师在初中一年级给我们的总结，当初我觉得她就是在滥用排比这种修辞手法，现在看来，是我太嫩了。\n读书不是摇头晃脑，不是扯脖子叫唤，更不是比谁的嗓门大，而是思想输入，需要我们仔细体会书中的理论、书中的技巧、书中的思想。\n其实，我们在第 21 章的末尾说过了读书的技巧，最终要做的，就是用自己的语言和体会，将书中的精华提炼出来，写出来，写给其他人，这不仅是对书籍的自我提炼，自我升华，也是对自己思想的一种表达，更是对读者思想的一种传承，对他人的一种帮助。\n所以，我们需要写作。\n有人说，读书和写作，读书是输入，将别人的想法从纸上输入到自己的大脑；写作是输出，将自己的想法从大脑输出到纸上。其实这是不对的，因为写作是输出的同时也是输入，写作的过程本身就是个记忆加强的过程，就好比你小时候抄作业，抄作业本身是输出，但是抄得多了你也记住了，所以这也算是一种输入。\n而且，写作的时候，会调动你的很多知识库，会让你加深记忆的同时加深理解，这也算对知识的一种加强。\n所以，就从现在，拿起笔吧，把你想说的，想记忆的，想理解的，都写下来，表达出来，这不仅可以让你自己反思，也能让别人看到，从而帮你纠正观点，何乐而不为呢。\n学会总结 总结是知识快速增长的技巧。\n知识想要快速增长，无非就是：总结、归纳、类比。\n比如，我们背英文单词的时候，就有词根记忆法、词缀记忆法。学习也是这样。\n你看，单一职责原则，放在日常生活中就叫各司其职，放在工厂中就叫流水线，放在代码中就叫单一职责，这里面的道理都是一样的，都是一个人只干一件事。\n其实，世界上的知识都是有限的，只不过有限的知识又衍生出半有限的知识，半有限的知识又衍生出无限的知识，所以给我们的感觉就是无限的，永远学不完。一生二二生三三生万物，就是这个道理。\n总结不仅能扩大我们的知识面，还能帮我们反思，帮我们改错，帮我们进化。\n同样的代码出现两次，就是图省事；同样的代码出现三次，就是这个人懒；同样的代码出现四次，就是这个人有病！如果你总结了这个道理，你大概率会开始学习设计模式了；如果你不总结这个道理，你就是拥有一年工作经验的十年老员工，需要被特殊照顾的群体。\n学得越多，本事越大，你就越有价值。那么怎么在有限的时间尽可能学到更多的东西呢？\n学会总结，学会归纳，学会提炼，即可！\n我们应该优先学那些通用的技术，比如数据结构、设计模式等，这样收益最大。\n对于程序员来说，做的最多的无非就是写代码，你有没有想过，你写的所有代码，都是一个个的函数、一个个的语句、一个个的变量组装起来的，而组装起来的思维，就是设计模式和算法。换句话说：代码就是利用设计模式和算法去操作变量。所以，只要我们学好了这些基础，就等于拿到了问题的答案，至于想用什么样的语言把答案描述出来，就看你的喜好了。\n学以致用 学到的东西，如果不用出来，那么永远都只是 demo 阶段，比如我在 2016 年用了一周时间学了 React，然后项目中根本没用到，一个月之后，全部忘光光，那么我面试的时候简历上要不要写我会 React 呢？\n写了你就挂了！\n这就是坏处，简历上不写你觉得亏，写了你又心虚。合着你学了一个月，到头来就是为了纠结简历上写不写这个技能来的。\n所以，别学那些跟你工作不相关的知识，尽量学跟你当前工作直接相关的，这样学了之后能立刻用到，等于有了实践机会，很容易就能熟练，从而掌握这门技能。\n有人说：劳资就是想学，劳资对当前学的技术烦了，想换个口味。当然可以，不过你得先承认你是个渣男，你喜新厌旧。\n换口味可以，先想想对新口味你能保持多久的新鲜感，在这个期间能不能学完，能不能搞出点名堂来，如果能，去吧，恭喜你喜提 skill+1。如果不能，去厕所闻会儿臭味儿冷静下吧，千万不要犯一时兴起学习症，这属于情绪导向的，是不经过大脑的决定，是人从感性进化到理性、从低端进化到高端必须摈弃的弱点之一。\n学习的好处 那么学习有啥子好处呢？\n第一就是可以装 X，这个不言而喻。别人不会的，你都会；别人会的，你会的更深，不出手则已，一出手就是秒杀，让别人对你五体投地，这小弟不就来了吗，人脉也随之来了。\n第二就是可以生财。你会的越多，价值越高，就越有机会获取更多的财富，人永远赚不到自己认知之外的财富，那么你认知到了，你就有机会赚到，你怎么才能认知到呢？学习！\n第三就是可以提升眼界，能长寿。人能长生不老吗？不能！但是能长寿，世界上只有一种人容易长寿：无忧无虑的人。 比如傻子，傻子之所以能长寿，是因为啥都不懂，啥都不管，无忧无虑，但是也有风险，比如：因为太傻去自杀。再比如富豪，富豪之所以能长寿，是因为不用为生计发愁，没有生活压力，无忧无虑。\n我们不可能每个人都是傻子，更不可能每个人都是富豪，但是我们可以通过学习，开拓眼界，看透一些东西，进而悟出一些东西，并且作为精神的寄托，这样也能达到无忧无虑的境界，再加上肉体上的锻炼，精神和物理双休，即使不能长生，也能长寿。\n总结 学习是一件伟大的事情，我们人类能进化到今天，都是因为我们不断地学习，不断地发展，所以，如果你想不被时代抛弃到脑后，你就要不断学习，不断学习，不断学习。\n对于学习来说，我们要多看，多想，多反思，更要坚持。要学会读书，学会写作。\n知识都有通用性，有个成语叫做触类旁通，这就说明我们的知识有很多共同点，我们就要找出其中的共性，学会类比，学会总结，学会归纳，学会反思，这样就能迅速扩大知识面，做到举一反三。\n最后，我们学到的知识，一定要用出来，不要侮辱了“学以致用”这个词语，更不要白白浪费自己辛苦学到的东西。\n其实，我们每个人都能做到读万卷书，行万里路的，古人也没有什么了不起的。古人的万卷书，也就是现在的几十本书而已，你在有电灯泡、有电子书的情况下，还干不过古人吗？\n抽空先去坐几趟高铁，把行万里路的这个愿望给实现了，你就只剩下读万卷书这个目标了，希望你在有生之年能做成这件事，来证明我们不比古人差。万岁万岁万万岁！\n35.结尾 终于，要跟大家说结束了。这本小册是周三发布的，恰好今天也是周三，总算是画上了句号了。\n这本小册是从 3 月份开始写的，截止到目前经历了大概 3 个月的时间，延期了近一个月，这里我要跟大家道歉。延期的原因有两个：第一就是五一期间万恶的 LOL 出了无限火力来勾引我，我没能忍住就上了恶当了；第二就是五月十二号任天堂推出了塞尔达传说王国之泪，这次我的脑子倒是忍住了，可是手没忍住，于是又上当了。\n悟以往之不谏，知来者之可追。这个小册会在后面添加一些附录内容，比如之前有的读者问的用例图和时间序列图，有的读者问过的哈希表的源码等，希望以此能减轻一些我延期的罪过。\n好，现在先让我们回到 2023 年的 3 月份，大概似乎差不多就在那个时间，你看到了这本小册。\n你看这本小册的原因是不是被第一章刺激到了呢，你是不是觉得那说的就是你自己，所以冲动之下就开始阅读呢？现在，你终于看到结尾了，你可以平心静气地想一想，再反思一下，你当初看这个小册的目的达到了吗？这段时间你都学到了什么？\n回顾 现在，假如有这么一段代码：\n1 2 3 int a = 1; int b = 2; int c = a+b; 你大概能知道，cpu先把a读入寄存器，再把b读入寄存器，然后将a和b相加，存入c中。如果你还不熟悉，那么就再去看下第 6 章。\n再比如这段代码：\n1 2 3 4 5 6 7 8 9 10 11 void handleA(int a){ if(a == 10) { func1(); }else if(a = 12) { func2(); }else if(a = 20) { func3(); }else { func4(); } } 你应该能立刻想到能改成map的形式：\n1 2 3 4 5 6 7 8 9 10 11 12 Map\u0026lt;String,Runnable\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(10,Runnable{func1()}) map.put(12,Runnable{func2()}) map.put(20,Runnable{func3()}) void handleA(int a) { if(map.containsKey(a)) { map.get(a).run(); return; } func4(); } 如果你想不到，那么就再去读一下第 21 章、第 22 章和第 23 章的关于设计模式的内容。\n这里，只是抽查下大家的学习质量，我们就不再废话了。\n我们再来整体回顾下我们的学习历程。\n第 1 章，属于激励和鞭策的，就是为了逼你能让自己奋起，让自己脱离舒适区，从而让自己行动起来。\n第 2 章到第 9 章，我们讲了编程的基本功，这里面涉及到了位运算、数据类型、控制流，以及面向对象的思想转换。这部分属于必须理解的内容，这是基础中的基础，不需要刻意记忆，必须理解。比如二进制的移位运算，一定要能熟练地进行左移右移动，还有按位运算，这个在底层代码中可太常见了，是区分编程硬实力的参照物，也是必须掌握的。\n第 10 章到第 20 章，我们讲了计算机的四大专业部分的课程，其中包括数据结构、操作系统、计算机网络和计算机组成原理部分的知识。这部分就是基础内容了，非计算机专业的一定要理解这部分内容，这是科班和非科班的主要差距之一，一定要理解并让自己转变自己的思路，摈弃老的惯性思维并养成新的惯性思维。比如，看到计算机网络中的连续 ARQ 协议，你应该做到“凡是涉及到发送方和接收方的地方都应该能立刻想到滑动窗口思想”。\n第 21 章到第 25 章，我们讲了设计模式和软件工程的部分知识，我们应该已经学会了如何画 UML 图，如何评估需求。但是，设计模式这部分知识，不是一朝一夕的，需要有心的时间积累，无心的积累不行，有心但是不积累也不行。这是我们从程序员向工程师转变的最重要的一步，是区分程序员技术高低的最重要参照物，我们需要理解并运用，希望将来有一天你能达到\u0026quot;手中无设计，心中有设计\u0026quot;的境界。\n第 26 章到第 31 章，我们实际参与了一个项目的评审、设计、开发、以及 review，这应该能给没有经验的或者经验少的同学带来一些帮助和防范，让他们心里有个数。我们也讲了Git的用法，Git的四个区域属于一定要理解的东西，希望我们每个人都能理解，做到码在纸上，理在心中。\n第 32 章到第 34 章，我们又回到了做人做事的层面，因为任何知识，都是以做事为出发点的。在这个层面，换位思考就非常重要，我们每个人都是一个个体，无法干预其他人。但是，我们却可以有上帝视角，来体会其他人的想法和心理活动，那就是换位思考。换位思考不是用来办坏事的，比如，你看到某人女朋友长得好看，你就想通过换位思考把自己当成他。洗洗睡吧！换位思考是让你用来做事的，不是让你用来意淫的。最后，再说下学习的方式，其核心就一个：总结。世界上所有的知识，就是一个树，我们学的知识就是这个树的一个叶子或者分支，我们需要不断总结，不断类比，才能将其他分支的知识掌握，从而向顶层分支移动，直到最后移动到树根（当然这是不可能的），或者移动到主干（这是可能的），主干就是：数学、物理学、化学，等等。我们就可以成为一个领域的专家，是专家，专家，专家！不是天天扯脖子叫唤让你二胎三胎买房的带石字旁的砖家。\n最后，也就是本章了，在这里，希望你能记录一下这一路学到的内容、对你有意义的内容、让你反思的内容。\n展望 时间是向前流逝的，肉体是不断衰老的，一切都有其生命规律。但是知识和阅历却是不断增加的，我们的知识跟我们的年龄成正比，所以，年纪越小，就越应该多学知识；年龄越大，就越应该多做事。\n在这里，我有十个字想来分享一下：目标、行动、坚持、不馁、不骄。\n无论你是干什么的，无论你想干什么，你都要先下定目标，这是你将来要努力的方向；当你下定目标之后，你要做的，就是行动，不行动就是空谈；你的目标不是一时半会儿就能成的，所以你要坚持，不能朝三暮四，不能三分钟热乎气；当然，你的坚持不一定能让你成功，你可能失败了，但是你不要气馁，因为失败是成功它妈，你都遇见它妈了，害怕遇不见她吗？最后，你可能成功了，但是你不要骄傲，因为骄傲是失败他妈，一旦骄傲了，你们指不定就生出失败来了，只有这样，你才能永久成功。\n最后，我希望大家能养成一个良好的作息习惯，每天能有 1 小时的运动时间，学习是用来强化自己的精神的，而运动则是用来强化自己的肉体的，这两个都要抓，且双手都要硬。诚能如此，则可以达到物魔双修的境界，就是毫无缺点、无懈可击的金刚不坏之体。\n回到现实中来，我还是有一些展望的，希望各位都能早日达到物质满足，从而向精神满足进化，说白了就是早点有钱解决温饱问题去追求更高的精神满足。大部分人，都是为了就业而学习的，为解决温饱而读书的，读书是件神圣的事，我们用神圣的事来解决吃喝问题？非也，我们这么想：我们在做一件神圣的事情，我们学到了更多的知识，不仅能满足自己的物质所需，还让自己的精神更上层楼。\n我们可以读一些其他方面的书，比如财经类、心理学类等，来增长自己的认知，从而让自己能赚到认知之外的财富，让自己在满足物理需求的基础上，也能满足自己的精神依托吧。\n希望各位可以多读书，从而让自己可以心平气和地和别人说话；多健身，从而让别人可以心平气和地和自己说话。这样文武相辅，就能让别人知道你文武双全。\n也希望各位能保持乐观的心理，保持必胜的信心，做好充足的准备，等到时机来临，就充分燃烧自己体内的小宇宙吧。 $$\n","date":"2025-07-14T15:33:07+08:00","permalink":"https://example.com/p/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%85%E4%BF%AE%E8%AF%BE/","title":"程序员的必修课"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://example.com/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://example.com/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://example.com/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://example.com/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://example.com/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://example.com/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://example.com/p/emoji-support/","title":"Emoji Support"}]